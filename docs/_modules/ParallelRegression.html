<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">


<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>ParallelRegression &#8212; ParallelRegression v1.0.0b3 - tools for conducting parallel analysis of a shared memory data set</title>
    
    <link rel="stylesheet" href="../_static/classic.css" type="text/css" />
    <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
    
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    '../',
        VERSION:     '1.0.0b3',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true,
        SOURCELINK_SUFFIX: '.txt'
      };
    </script>
    <script type="text/javascript" src="../_static/jquery.js"></script>
    <script type="text/javascript" src="../_static/underscore.js"></script>
    <script type="text/javascript" src="../_static/doctools.js"></script>
    <script type="text/javascript" src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" /> 
  </head>
  <body role="document">
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="nav-item nav-item-0"><a href="../index.html">ParallelRegression v1.0.0b3 - tools for conducting parallel analysis of a shared memory data set</a> &#187;</li>
          <li class="nav-item nav-item-1"><a href="index.html" accesskey="U">Module code</a> &#187;</li> 
      </ul>
    </div>  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <h1>Source code for ParallelRegression</h1><div class="highlight"><pre>
<span></span><span class="c1">## (C) 2017 by Richard Bellamy</span>
<span class="c1">##</span>
<span class="c1">## This software is licensed under the terms of version 3 of the GNU Affero</span>
<span class="c1">## General Public License.</span>
<span class="kn">from</span> <span class="nn">copy</span> <span class="k">import</span> <span class="n">deepcopy</span>
<span class="kn">from</span> <span class="nn">collections</span> <span class="k">import</span> <span class="n">abc</span><span class="p">,</span> <span class="n">UserList</span><span class="p">,</span> <span class="n">Sequence</span><span class="p">,</span> <span class="n">OrderedDict</span>
<span class="kn">from</span> <span class="nn">contextlib</span> <span class="k">import</span> <span class="n">suppress</span><span class="p">,</span> <span class="n">ContextDecorator</span><span class="p">,</span> <span class="n">contextmanager</span>
<span class="kn">from</span> <span class="nn">io</span> <span class="k">import</span> <span class="n">StringIO</span><span class="p">,</span> <span class="n">BytesIO</span>
<span class="kn">import</span> <span class="nn">unittest</span>
<span class="kn">import</span> <span class="nn">sys</span>
<span class="kn">import</span> <span class="nn">re</span>
<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="kn">from</span> <span class="nn">multiprocessing</span> <span class="k">import</span> <span class="n">sharedctypes</span><span class="p">,</span> <span class="n">Queue</span><span class="p">,</span> <span class="n">Process</span><span class="p">,</span> <span class="n">cpu_count</span>
<span class="kn">import</span> <span class="nn">array</span>
<span class="kn">import</span> <span class="nn">math</span><span class="o">,</span> <span class="nn">itertools</span><span class="o">,</span> <span class="nn">random</span><span class="o">,</span> <span class="nn">keyword</span>

<span class="n">__all__</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;vCovMatrix&#39;</span><span class="p">,</span>                          <span class="c1"># Functions</span>
           <span class="s1">&#39;FStatistic&#39;</span><span class="p">,</span>
           <span class="s1">&#39;syncText&#39;</span><span class="p">,</span>
           <span class="s1">&#39;val_if_present&#39;</span><span class="p">,</span>
           <span class="s1">&#39;has_term&#39;</span><span class="p">,</span>
           <span class="s1">&#39;mask_brackets&#39;</span><span class="p">,</span>
           <span class="s1">&#39;masked_dict&#39;</span><span class="p">,</span>
           <span class="s1">&#39;masked_iter&#39;</span><span class="p">,</span>
           <span class="s1">&#39;masked_split&#39;</span><span class="p">,</span>
           <span class="s1">&#39;terms_in&#39;</span><span class="p">,</span>
           <span class="s1">&#39;formulas_match&#39;</span><span class="p">,</span>
           <span class="s1">&#39;termString&#39;</span><span class="p">,</span>
           <span class="s1">&#39;despace&#39;</span><span class="p">,</span>
           <span class="s1">&#39;CategoryError&#39;</span><span class="p">,</span>                       <span class="c1"># Errors &amp; warnings</span>
           <span class="s1">&#39;UnsupportedColumn&#39;</span><span class="p">,</span>
           <span class="s1">&#39;mathDictKeyError&#39;</span><span class="p">,</span>
           <span class="s1">&#39;RankError&#39;</span><span class="p">,</span>
           <span class="s1">&#39;setList&#39;</span><span class="p">,</span>                             <span class="c1"># Building block classes</span>
           <span class="s1">&#39;typedDict&#39;</span><span class="p">,</span>
           <span class="s1">&#39;categorizedSetDict&#39;</span><span class="p">,</span>
           <span class="s1">&#39;laggedAccessor&#39;</span><span class="p">,</span>
           <span class="s1">&#39;termSet&#39;</span><span class="p">,</span>                             <span class="c1"># Parallel regression-</span>
           <span class="s1">&#39;mathDataStore&#39;</span><span class="p">,</span>                       <span class="c1"># oriented classes</span>
           <span class="s1">&#39;mathDictMaker&#39;</span><span class="p">,</span>
           <span class="s1">&#39;mathDictHypothesis&#39;</span><span class="p">,</span>
           <span class="s1">&#39;mathDictConfig&#39;</span><span class="p">,</span>
           <span class="s1">&#39;mathDict&#39;</span><span class="p">]</span>

<div class="viewcode-block" id="vCovMatrix"><a class="viewcode-back" href="../ParallelRegression.html#ParallelRegression.vCovMatrix">[docs]</a><span class="k">def</span> <span class="nf">vCovMatrix</span><span class="p">(</span> <span class="n">X</span><span class="p">,</span> <span class="n">u</span><span class="p">,</span> <span class="n">vcType</span><span class="o">=</span><span class="s1">&#39;White1980&#39;</span> <span class="p">):</span>
    <span class="sd">&#39;&#39;&#39;Computes a variance-covariance matrix.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    X : 2-dimensional array</span>
<span class="sd">        Matrix of X values.</span>
<span class="sd">    u : vector array</span>
<span class="sd">        Vector of residuals.</span>
<span class="sd">    vcType : {&#39;White1980&#39;, &#39;Classical&#39;}, optional</span>
<span class="sd">        Type of variance-covariance matrix requested.  &#39;Classical&#39; for the</span>
<span class="sd">        classical statistics formula, or &#39;White1980&#39; for the</span>
<span class="sd">        heteroskedasticity-robust formula originally proposed by Halbert White</span>
<span class="sd">        in his 1980 paper, &#39;A Heteroskedasticity-Consistent Covariance Matrix</span>
<span class="sd">        Estimator and a Direct Test for Heteroskedasticity&#39;.</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    The heteroskedasticity-robust formula supported is the formula explained</span>
<span class="sd">    in the documentation to the &quot;car&quot; R package&#39;s &quot;hccm&quot; function:</span>

<span class="sd">    &quot;The classical White-corrected coefficient covariance matrix (&quot;hc0&quot;) (for</span>
<span class="sd">    an unweighted model) is</span>

<span class="sd">    &quot;V(b) = inv(X&#39;X) X&#39; diag(e^2) X inv(X&#39;X)</span>

<span class="sd">    &quot;where e^2 are the squared residuals, and X is the model matrix.&quot;</span>

<span class="sd">    This is the same formula proposed by White in 1980.  However, the car</span>
<span class="sd">    pachage documentation is substantially more clear and concise than either</span>
<span class="sd">    the original paper or most textbook discussions.</span>
<span class="sd">    &#39;&#39;&#39;</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span> <span class="nb">getattr</span><span class="p">(</span> <span class="n">X</span><span class="p">,</span> <span class="s1">&#39;shape&#39;</span><span class="p">,</span> <span class="s1">&#39;&#39;</span> <span class="p">)</span> <span class="p">)</span> <span class="o">!=</span> <span class="mi">2</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;X must be a 2-dimensional ndarray with exactly two &#39;</span>
                         <span class="s1">&#39;dimensions.&#39;</span><span class="p">)</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span> <span class="n">X</span><span class="p">[:,</span><span class="mi">0</span><span class="p">]</span> <span class="p">)</span> <span class="o">!=</span> <span class="nb">len</span><span class="p">(</span> <span class="n">u</span> <span class="p">):</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;Length of `u` must match the number of rows in `X`.&#39;</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">nobs</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span> <span class="n">u</span> <span class="p">)</span>
    <span class="n">XpXi</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">inv</span><span class="p">(</span> <span class="n">X</span><span class="o">.</span><span class="n">T</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span> <span class="n">X</span> <span class="p">)</span> <span class="p">)</span>

    <span class="n">horse</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span> <span class="p">(</span> <span class="n">nobs</span><span class="p">,</span> <span class="n">nobs</span> <span class="p">)</span> <span class="p">)</span>
    <span class="n">u</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span> <span class="n">u</span> <span class="p">)</span>
    <span class="n">sigma_sq</span> <span class="o">=</span> <span class="n">u</span><span class="o">.</span><span class="n">T</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span> <span class="n">u</span> <span class="p">)</span> <span class="o">/</span> <span class="p">(</span> <span class="nb">len</span><span class="p">(</span> <span class="n">u</span> <span class="p">)</span> <span class="o">-</span> <span class="nb">len</span><span class="p">(</span> <span class="n">X</span><span class="p">[</span><span class="mi">0</span><span class="p">,:]</span> <span class="p">)</span> <span class="p">)</span>
    <span class="k">if</span> <span class="n">vcType</span> <span class="o">==</span> <span class="s1">&#39;White1980&#39;</span><span class="p">:</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span> <span class="n">nobs</span> <span class="p">):</span>
            <span class="n">horse</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">u</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">**</span><span class="mi">2</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span> <span class="n">nobs</span> <span class="p">):</span>
            <span class="n">horse</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">sigma_sq</span>
    <span class="n">inner</span> <span class="o">=</span> <span class="n">X</span><span class="o">.</span><span class="n">T</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span> <span class="n">horse</span> <span class="p">)</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span> <span class="n">X</span> <span class="p">)</span>

    <span class="n">vCovM</span> <span class="o">=</span> <span class="n">XpXi</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span> <span class="n">inner</span> <span class="p">)</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span> <span class="n">XpXi</span> <span class="p">)</span>
    <span class="k">return</span><span class="p">(</span> <span class="n">vCovM</span> <span class="p">)</span></div>

<div class="viewcode-block" id="FStatistic"><a class="viewcode-back" href="../ParallelRegression.html#ParallelRegression.FStatistic">[docs]</a><span class="k">def</span> <span class="nf">FStatistic</span><span class="p">(</span> <span class="n">X</span><span class="p">,</span> <span class="n">u</span><span class="p">,</span> <span class="n">coefs</span><span class="p">,</span> <span class="n">R</span><span class="p">,</span> <span class="n">r</span><span class="p">,</span> <span class="n">vcType</span><span class="o">=</span><span class="s1">&#39;White1980&#39;</span> <span class="p">):</span>
    <span class="sd">&#39;&#39;&#39;Computes an F statistic that by default is heteroskedasticity-robust.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    X : 2-dimensional array</span>
<span class="sd">        Matrix of all regressors including the intercept.</span>
<span class="sd">    u : vector array</span>
<span class="sd">        Vector of all residuals.</span>
<span class="sd">    coefs : vector array</span>
<span class="sd">        All coefficients from the model that is being tested, including the</span>
<span class="sd">        intercept and untested parameters.</span>
<span class="sd">    R : 2-dimensional array</span>
<span class="sd">        Linear restrictions in matrix form.</span>
<span class="sd">    r : vector array</span>
<span class="sd">        Linear restriction values in vector form.</span>
<span class="sd">    vcType : {&#39;White1980&#39;, &#39;Classical&#39;}, optional</span>
<span class="sd">        Type of variance-covariance matrix requested.  Keep the default setting</span>
<span class="sd">        for a heteroskedasticity-robust result.  See vCovMatrix function for</span>
<span class="sd">        details.</span>
<span class="sd">    &#39;&#39;&#39;</span>
    <span class="n">vc</span> <span class="o">=</span> <span class="n">vCovMatrix</span><span class="p">(</span> <span class="n">X</span><span class="p">,</span> <span class="n">u</span><span class="p">,</span> <span class="n">vcType</span> <span class="p">)</span>
    <span class="n">Rterm</span> <span class="o">=</span> <span class="n">R</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span> <span class="n">coefs</span> <span class="p">)</span> <span class="o">-</span> <span class="n">r</span>
    <span class="n">Lterm</span> <span class="o">=</span> <span class="n">Rterm</span><span class="o">.</span><span class="n">T</span>
    <span class="n">Mterm</span> <span class="o">=</span> <span class="n">R</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span> <span class="n">vc</span> <span class="p">)</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span> <span class="n">R</span><span class="o">.</span><span class="n">T</span> <span class="p">)</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span> <span class="n">r</span> <span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
        <span class="n">Mterm</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">inv</span><span class="p">(</span> <span class="n">Mterm</span> <span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">Mterm</span> <span class="o">=</span> <span class="n">Mterm</span><span class="o">**-</span><span class="mi">1</span>
    <span class="n">F</span> <span class="o">=</span> <span class="n">Lterm</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span> <span class="n">Mterm</span> <span class="p">)</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span> <span class="n">Rterm</span> <span class="p">)</span> <span class="o">/</span> <span class="nb">len</span><span class="p">(</span> <span class="n">r</span> <span class="p">)</span>
    <span class="k">if</span> <span class="n">math</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span> <span class="n">F</span> <span class="p">):</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span> <span class="s1">&#39;F Statistic calculation resulted in nan.&#39;</span><span class="p">,</span> <span class="n">vcType</span><span class="p">,</span>
                                                                      <span class="n">vc</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span>
                                                                      <span class="n">F</span><span class="p">,</span>
                                                                      <span class="n">Mterm</span><span class="p">,</span>
                                                                      <span class="n">Rterm</span><span class="p">,</span>
                                                                      <span class="n">r</span> <span class="p">)</span>
    <span class="k">return</span><span class="p">(</span> <span class="n">F</span> <span class="p">)</span></div>

<div class="viewcode-block" id="syncText"><a class="viewcode-back" href="../ParallelRegression.html#ParallelRegression.syncText">[docs]</a><span class="k">def</span> <span class="nf">syncText</span><span class="p">(</span> <span class="n">strA</span><span class="p">,</span> <span class="n">strB</span><span class="p">,</span> <span class="n">addA</span><span class="p">,</span> <span class="n">addB</span><span class="p">,</span> <span class="n">pre</span><span class="o">=</span><span class="s1">&#39;&#39;</span> <span class="p">):</span>
    <span class="sd">&#39;&#39;&#39;Adds necessary spacing to align simultaneous additions to two strings.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>

<span class="sd">    strA : string</span>
<span class="sd">        The first of the two strings.</span>
<span class="sd">    strB : string</span>
<span class="sd">        The second of the two strings.</span>
<span class="sd">    addA : string</span>
<span class="sd">        The string to be appended to the first string.</span>
<span class="sd">    addB : string</span>
<span class="sd">        The string to be appended to the second string.</span>
<span class="sd">    pre : string, optional</span>
<span class="sd">        This string is appended to `strA` and `strB` immediately before `addA`</span>
<span class="sd">        and `addB`.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>

<span class="sd">    strA : string</span>
<span class="sd">        The first string, with `addA` appended.</span>
<span class="sd">    strB : string</span>
<span class="sd">        The second string, with `addB` appended, starting at the same index as</span>
<span class="sd">        `addA` in the first string.</span>

<span class="sd">    Example</span>
<span class="sd">    -------</span>

<span class="sd">    &gt;&gt;&gt; upper, lower = (&#39;John&#39;, &#39;Proper Noun&#39;)</span>
<span class="sd">    &gt;&gt;&gt; for a, b in [(&#39;ate&#39;, &#39;Verb&#39;),(&#39;an&#39;, &#39;Article&#39;),(&#39;apple.&#39;, &#39;Noun&#39;)]:</span>
<span class="sd">    &gt;&gt;&gt;     upper, lower = syncText( upper, lower, a, b, &#39; &#39; )</span>
<span class="sd">    &gt;&gt;&gt; print( upper, &#39;\\n&#39;, lower )</span>
<span class="sd">    John        ate  an      apple.</span>
<span class="sd">    Proper Noun Verb Article Noun</span>
<span class="sd">    &#39;&#39;&#39;</span>
    <span class="c1">## Please pardon the inconsistency in the headings&#39; line spacing between</span>
    <span class="c1">## this and other docstrings, and the escaping the backslash in &#39;\n&#39;.  Both</span>
    <span class="c1">## were necessitated by Sphinx.</span>
    <span class="n">spaces</span> <span class="o">=</span> <span class="nb">abs</span><span class="p">(</span> <span class="nb">len</span><span class="p">(</span> <span class="n">strA</span> <span class="p">)</span> <span class="o">-</span> <span class="nb">len</span><span class="p">(</span> <span class="n">strB</span> <span class="p">)</span> <span class="p">)</span>
    <span class="n">spaces</span> <span class="o">=</span> <span class="s1">&#39;&#39;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span> <span class="p">[</span><span class="s1">&#39; &#39;</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span> <span class="n">spaces</span> <span class="p">)]</span> <span class="p">)</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span> <span class="n">strA</span> <span class="p">)</span> <span class="o">&gt;</span> <span class="nb">len</span><span class="p">(</span> <span class="n">strB</span> <span class="p">):</span>
        <span class="n">strB</span> <span class="o">+=</span> <span class="n">spaces</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">strA</span> <span class="o">+=</span> <span class="n">spaces</span>
    <span class="n">strA</span> <span class="o">+=</span> <span class="n">pre</span> <span class="o">+</span> <span class="n">addA</span>
    <span class="n">strB</span> <span class="o">+=</span> <span class="n">pre</span> <span class="o">+</span> <span class="n">addB</span>
    <span class="k">return</span><span class="p">(</span> <span class="n">strA</span><span class="p">,</span> <span class="n">strB</span> <span class="p">)</span></div>

<div class="viewcode-block" id="val_if_present"><a class="viewcode-back" href="../ParallelRegression.html#ParallelRegression.val_if_present">[docs]</a><span class="k">def</span> <span class="nf">val_if_present</span><span class="p">(</span> <span class="n">obj</span><span class="p">,</span> <span class="n">attr</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">alt</span><span class="o">=</span><span class="kc">None</span> <span class="p">):</span>
    <span class="sd">&#39;&#39;&#39;Returns the requested value if it is set and is not None.  Otherwise</span>
<span class="sd">    `alt` is returned.</span>

<span class="sd">    Avoids errors if the requested value does not exist, while handling the</span>
<span class="sd">    presence of a None value and a default value in a different manner than</span>
<span class="sd">    getattr( ).</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    obj</span>
<span class="sd">        An object from which to attempt to retrieve an attribute value.</span>
<span class="sd">    attr : string, optional</span>
<span class="sd">        The name of the attribute to be retrieved.  If `attr` is not set, then</span>
<span class="sd">        the value of `obj` will be returned unless it is equal to None.  If &#39;.&#39;</span>
<span class="sd">        is present in this string, child objects will be retrieved recursively.</span>
<span class="sd">        See example below.</span>
<span class="sd">    alt, optional</span>
<span class="sd">        The value to be returned if the requested attribute does not exist, or</span>
<span class="sd">        is equal to None, or if the object&#39;s value is requested but is equal to</span>
<span class="sd">        None.  If this is not set, then None will be returned in these</span>
<span class="sd">        scenarios.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    obj</span>
<span class="sd">        If the requested value is set and is not equal to None, then the</span>
<span class="sd">        requested value is returned.  Otherwise, `alt` is returned.  No error</span>
<span class="sd">        is raised if `obj` does not have an attribute named `attr`.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; class testFixture(object):</span>
<span class="sd">    &gt;&gt;&gt;     NoneVal = None</span>
<span class="sd">    &gt;&gt;&gt;     number = 123</span>
<span class="sd">    &gt;&gt;&gt; testFix = testFixture( )</span>
<span class="sd">    &gt;&gt;&gt; val_if_present( testFix, &#39;NoneVal&#39;, &#39;ABCdef&#39; ) == &#39;ABCdef&#39;</span>
<span class="sd">    True</span>
<span class="sd">    &gt;&gt;&gt; testFix.fixtureTwo = testFixture( )</span>
<span class="sd">    &gt;&gt;&gt; testFix.fixtureTwo.dict_object = {&#39;a_key&#39;: &#39;has a value.&#39;}</span>
<span class="sd">    &gt;&gt;&gt; val_if_present( testFix, &#39;fixtureTwo.dict_object.a_key&#39; ) \\</span>
<span class="sd">    &gt;&gt;&gt;               == &#39;has a value.&#39;</span>
<span class="sd">    True</span>
<span class="sd">    &#39;&#39;&#39;</span>
    <span class="k">if</span> <span class="n">obj</span> <span class="o">==</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">return</span><span class="p">(</span> <span class="n">alt</span> <span class="p">)</span>
    <span class="k">if</span> <span class="n">attr</span> <span class="o">==</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">return</span><span class="p">(</span> <span class="n">obj</span> <span class="p">)</span>
    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span> <span class="n">attr</span><span class="p">,</span> <span class="nb">str</span> <span class="p">)</span> <span class="ow">and</span> <span class="n">attr</span><span class="o">.</span><span class="n">count</span><span class="p">(</span> <span class="s1">&#39;.&#39;</span> <span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
        <span class="n">attr</span> <span class="o">=</span> <span class="n">attr</span><span class="o">.</span><span class="n">split</span><span class="p">(</span> <span class="s1">&#39;.&#39;</span><span class="p">,</span> <span class="n">maxsplit</span><span class="o">=</span><span class="mi">1</span> <span class="p">)</span>
        <span class="k">if</span> <span class="n">attr</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="ow">in</span> <span class="n">obj</span><span class="o">.</span><span class="n">__dir__</span><span class="p">(</span> <span class="p">):</span>
            <span class="n">tpl</span> <span class="o">=</span> <span class="p">(</span> <span class="nb">getattr</span><span class="p">(</span> <span class="n">obj</span><span class="p">,</span> <span class="n">attr</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="p">),</span> <span class="n">attr</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">alt</span> <span class="p">)</span>
            <span class="k">return</span><span class="p">(</span> <span class="n">val_if_present</span><span class="p">(</span> <span class="nb">getattr</span><span class="p">(</span> <span class="n">obj</span><span class="p">,</span> <span class="n">attr</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="p">),</span> <span class="n">attr</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">alt</span> <span class="p">)</span> <span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span><span class="p">(</span> <span class="n">alt</span> <span class="p">)</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">attr</span> <span class="ow">in</span> <span class="n">obj</span><span class="o">.</span><span class="n">__dir__</span><span class="p">(</span> <span class="p">):</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span> <span class="n">obj</span><span class="p">,</span> <span class="nb">dict</span> <span class="p">)</span> <span class="ow">and</span> <span class="n">attr</span> <span class="ow">in</span> <span class="n">obj</span><span class="o">.</span><span class="n">keys</span><span class="p">(</span> <span class="p">):</span>
            <span class="k">return</span><span class="p">(</span> <span class="n">obj</span><span class="p">[</span><span class="n">attr</span><span class="p">]</span> <span class="p">)</span>
        <span class="k">return</span><span class="p">(</span> <span class="n">alt</span> <span class="p">)</span>
    <span class="n">attrVal</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span> <span class="n">obj</span><span class="p">,</span> <span class="n">attr</span> <span class="p">)</span>
    <span class="k">if</span> <span class="n">attrVal</span> <span class="o">==</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">return</span><span class="p">(</span> <span class="n">alt</span> <span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span><span class="p">(</span> <span class="n">attrVal</span> <span class="p">)</span></div>

<div class="viewcode-block" id="has_term"><a class="viewcode-back" href="../ParallelRegression.html#ParallelRegression.has_term">[docs]</a><span class="k">def</span> <span class="nf">has_term</span><span class="p">(</span> <span class="n">formula</span><span class="p">,</span> <span class="n">term</span> <span class="p">):</span>
    <span class="sd">&#39;&#39;&#39;Returns True if `formula` either starts with `term` followed by one of</span>
<span class="sd">    [ )+-~*:] or contains `term` followed by one those characters, preceeded by</span>
<span class="sd">    one of [ (+-~*:].</span>
<span class="sd">    &#39;&#39;&#39;</span>
    <span class="n">before</span> <span class="o">=</span> <span class="s1">&#39; (+-~*:&lt;&gt;&#39;</span>
    <span class="n">after</span> <span class="o">=</span> <span class="s1">&#39; )+-~*:&lt;&gt;&#39;</span>
    <span class="k">if</span> <span class="n">formula</span><span class="o">.</span><span class="n">startswith</span><span class="p">(</span> <span class="n">term</span> <span class="p">):</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span> <span class="n">formula</span> <span class="p">)</span> <span class="o">==</span> <span class="nb">len</span><span class="p">(</span> <span class="n">term</span> <span class="p">)</span> <span class="ow">or</span> <span class="n">formula</span><span class="p">[</span><span class="nb">len</span><span class="p">(</span> <span class="n">term</span> <span class="p">)]</span> <span class="ow">in</span> <span class="n">after</span><span class="p">:</span>
            <span class="k">return</span><span class="p">(</span> <span class="kc">True</span> <span class="p">)</span>
    <span class="k">for</span> <span class="n">b</span> <span class="ow">in</span> <span class="n">before</span><span class="p">:</span>
        <span class="n">i</span> <span class="o">=</span> <span class="n">formula</span><span class="o">.</span><span class="n">find</span><span class="p">(</span> <span class="n">b</span> <span class="p">)</span>
        <span class="k">while</span> <span class="n">i</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">formula</span><span class="p">[</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">:]</span><span class="o">.</span><span class="n">startswith</span><span class="p">(</span> <span class="n">term</span> <span class="p">):</span>
                <span class="k">if</span> <span class="nb">len</span><span class="p">(</span> <span class="n">formula</span><span class="p">[</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">:]</span> <span class="p">)</span> <span class="o">==</span> <span class="nb">len</span><span class="p">(</span> <span class="n">term</span> <span class="p">):</span>
                    <span class="k">return</span><span class="p">(</span> <span class="kc">True</span> <span class="p">)</span>
                <span class="k">if</span> <span class="p">(</span> <span class="n">formula</span><span class="p">[</span><span class="n">i</span><span class="o">+</span><span class="nb">len</span><span class="p">(</span> <span class="n">term</span> <span class="p">)</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span> <span class="ow">in</span> <span class="n">after</span> <span class="p">):</span>
                    <span class="k">return</span><span class="p">(</span> <span class="kc">True</span> <span class="p">)</span>
            <span class="n">i</span> <span class="o">=</span> <span class="n">formula</span><span class="o">.</span><span class="n">find</span><span class="p">(</span> <span class="n">b</span><span class="p">,</span> <span class="n">i</span> <span class="o">+</span> <span class="mi">1</span> <span class="p">)</span>
    <span class="k">return</span><span class="p">(</span> <span class="kc">False</span> <span class="p">)</span></div>

<span class="n">splitter_rstr</span> <span class="o">=</span> <span class="s1">r&#39;[\+\-\~]+&#39;</span>
<span class="n">splitter</span> <span class="o">=</span> <span class="n">re</span><span class="o">.</span><span class="n">compile</span><span class="p">(</span> <span class="n">splitter_rstr</span> <span class="p">)</span>
<span class="n">splitted_rstr</span> <span class="o">=</span> <span class="s1">r&#39;(?:[^\+\-\~\ ]+\ )*[^\+\-\~\ ]+&#39;</span>
<span class="n">splitted</span> <span class="o">=</span> <span class="n">re</span><span class="o">.</span><span class="n">compile</span><span class="p">(</span> <span class="n">splitted_rstr</span> <span class="p">)</span>
<span class="n">one_star</span> <span class="o">=</span> <span class="n">re</span><span class="o">.</span><span class="n">compile</span><span class="p">(</span> <span class="s1">r&#39;\*(?!\*)&#39;</span> <span class="p">)</span>
<span class="n">paren</span> <span class="o">=</span> <span class="n">re</span><span class="o">.</span><span class="n">compile</span><span class="p">(</span> <span class="s1">r&#39;(?:\([^\(]*?\))|(?:\{[^\{]*?\})|(?:\[[^\[]*?\])&#39;</span> <span class="p">)</span>
<span class="n">varpattern_rstr</span> <span class="o">=</span> <span class="s1">r&#39;[a-zA-Z_][a-zA-Z_0-9]*(?![a-zA-Z_0-9\(\{\[\@])&#39;</span>
<span class="n">varpattern</span> <span class="o">=</span> <span class="n">re</span><span class="o">.</span><span class="n">compile</span><span class="p">(</span> <span class="n">varpattern_rstr</span> <span class="p">)</span>
<span class="n">termpat_rstr</span> <span class="o">=</span> <span class="s1">r&#39;[a-zA-Z_0-9]+(?:[ ]*[^ \+\-\(\{\[]+)*(?![a-zA-Z_0-9\(\{\[])&#39;</span>
<span class="n">termpattern</span> <span class="o">=</span> <span class="n">re</span><span class="o">.</span><span class="n">compile</span><span class="p">(</span> <span class="n">termpat_rstr</span> <span class="p">)</span>

<div class="viewcode-block" id="mask_brackets"><a class="viewcode-back" href="../ParallelRegression.html#ParallelRegression.mask_brackets">[docs]</a><span class="k">def</span> <span class="nf">mask_brackets</span><span class="p">(</span> <span class="n">string</span> <span class="p">):</span>
    <span class="sd">&#39;&#39;&#39; Mask anything inside brackets, including nested brackets, by replacing</span>
<span class="sd">    the brackets and their contents with a same-length string of repeated</span>
<span class="sd">    underscores.</span>
<span class="sd">    &#39;&#39;&#39;</span>
    <span class="k">def</span> <span class="nf">repl</span><span class="p">(</span> <span class="n">mobj</span> <span class="p">):</span>
        <span class="n">replacement</span> <span class="o">=</span> <span class="s1">&#39;&#39;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span> <span class="p">[</span><span class="s1">&#39;_&#39;</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> \
                                <span class="nb">range</span><span class="p">(</span> <span class="n">mobj</span><span class="o">.</span><span class="n">end</span><span class="p">(</span> <span class="p">)</span> <span class="o">-</span> <span class="n">mobj</span><span class="o">.</span><span class="n">start</span><span class="p">(</span> <span class="p">)</span> <span class="p">)]</span> <span class="p">)</span>
        <span class="k">return</span><span class="p">(</span> <span class="n">replacement</span> <span class="p">)</span>
    <span class="n">nsubstitutions</span> <span class="o">=</span> <span class="mi">1</span>
    <span class="k">while</span> <span class="n">nsubstitutions</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
        <span class="n">string</span><span class="p">,</span> <span class="n">nsubstitutions</span> <span class="o">=</span> <span class="n">paren</span><span class="o">.</span><span class="n">subn</span><span class="p">(</span> <span class="n">repl</span><span class="p">,</span> <span class="n">string</span> <span class="p">)</span>
    <span class="k">return</span><span class="p">(</span> <span class="n">string</span> <span class="p">)</span></div>

<div class="viewcode-block" id="masked_dict"><a class="viewcode-back" href="../ParallelRegression.html#ParallelRegression.masked_dict">[docs]</a><span class="k">def</span> <span class="nf">masked_dict</span><span class="p">(</span> <span class="n">string</span><span class="p">,</span> <span class="n">mobj</span> <span class="p">):</span>
    <span class="sd">&#39;&#39;&#39;Recovers the corresponding contents from the original string based on a</span>
<span class="sd">    regular expressions match object produced using a masked string.  Compare</span>
<span class="sd">    to mobj.groupdict( ).</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    string : string</span>
<span class="sd">        The unmasked string from which content is to be recovered.</span>
<span class="sd">    mobj : regular expression match object</span>
<span class="sd">        The match object resulting from a regular expression pattern matched to</span>
<span class="sd">        a masked version of `string`.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    dict</span>
<span class="sd">        Dictionary containing the substrings of `string` corresponding to the</span>
<span class="sd">        named subgroups of the match, keyed by the subgroup name.</span>
<span class="sd">    &#39;&#39;&#39;</span>
    <span class="k">if</span> <span class="n">mobj</span> <span class="o">==</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">return</span><span class="p">(</span> <span class="kc">None</span> <span class="p">)</span>
    <span class="n">ret</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span> <span class="p">)</span>
    <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">mobj</span><span class="o">.</span><span class="n">re</span><span class="o">.</span><span class="n">groupindex</span><span class="o">.</span><span class="n">items</span><span class="p">(</span> <span class="p">):</span>
        <span class="n">a</span><span class="p">,</span> <span class="n">t</span> <span class="o">=</span> <span class="n">mobj</span><span class="o">.</span><span class="n">span</span><span class="p">(</span> <span class="n">v</span> <span class="p">)</span>
        <span class="n">ret</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">=</span> <span class="n">string</span><span class="p">[</span><span class="n">a</span><span class="p">:</span><span class="n">t</span><span class="p">]</span>
    <span class="k">return</span><span class="p">(</span> <span class="n">ret</span> <span class="p">)</span></div>

<div class="viewcode-block" id="masked_iter"><a class="viewcode-back" href="../ParallelRegression.html#ParallelRegression.masked_iter">[docs]</a><span class="k">def</span> <span class="nf">masked_iter</span><span class="p">(</span> <span class="n">string</span><span class="p">,</span> <span class="n">mobj_iter</span> <span class="p">):</span>
    <span class="sd">&#39;&#39;&#39;Recovers the corresponding contents from the original string based on</span>
<span class="sd">    regular expression match objects produced by an iterable returned from</span>
<span class="sd">    re.finditer( ) or from a pattern object&#39;s .finditer( ) method.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    string : string</span>
<span class="sd">        The unmasked string from which content is to be recovered.</span>
<span class="sd">    mobj_iter : iterable of regular expression match objects</span>
<span class="sd">        The iterable of regular expression match objects resulting from a</span>
<span class="sd">        regular expression pattern matched to a masked version of `string`.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    list</span>
<span class="sd">        List containing the substrings of `string` corresponding to the</span>
<span class="sd">        substring matched by each match object produced by the iterable.</span>
<span class="sd">    &#39;&#39;&#39;</span>
    <span class="n">ret</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span> <span class="p">)</span>
    <span class="k">for</span> <span class="n">mobj</span> <span class="ow">in</span> <span class="n">mobj_iter</span><span class="p">:</span>
        <span class="n">a</span><span class="p">,</span> <span class="n">t</span> <span class="o">=</span> <span class="n">mobj</span><span class="o">.</span><span class="n">span</span><span class="p">(</span> <span class="p">)</span>
        <span class="n">ret</span><span class="o">.</span><span class="n">append</span><span class="p">(</span> <span class="n">string</span><span class="p">[</span><span class="n">a</span><span class="p">:</span><span class="n">t</span><span class="p">]</span> <span class="p">)</span>
    <span class="k">return</span><span class="p">(</span> <span class="n">ret</span> <span class="p">)</span></div>

<div class="viewcode-block" id="masked_split"><a class="viewcode-back" href="../ParallelRegression.html#ParallelRegression.masked_split">[docs]</a><span class="k">def</span> <span class="nf">masked_split</span><span class="p">(</span> <span class="n">string</span><span class="p">,</span> <span class="n">mask</span><span class="p">,</span> <span class="n">split</span> <span class="p">):</span>
    <span class="sd">&#39;&#39;&#39;Splits `string` based on the location(s) at which `split` is located in</span>
<span class="sd">    `mask`.  Compare to str.split( ).</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    string : string</span>
<span class="sd">        The unmasked string from which content is to be recovered.</span>
<span class="sd">    mask : string</span>
<span class="sd">        The masked version of `string` to be used to determine the the</span>
<span class="sd">        location(s) at which to split `string`.</span>
<span class="sd">    split : string</span>
<span class="sd">        The string identifying the location(s) at which to split `string`.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    list</span>
<span class="sd">        List of substrings resulting from splitting `string` based on the</span>
<span class="sd">        presence of `split` in `mask`.</span>
<span class="sd">    &#39;&#39;&#39;</span>
    <span class="n">mask</span> <span class="o">=</span> <span class="n">mask</span><span class="o">.</span><span class="n">split</span><span class="p">(</span> <span class="n">split</span> <span class="p">)</span>
    <span class="n">ret</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span> <span class="p">)</span>
    <span class="n">a</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="k">for</span> <span class="n">m</span> <span class="ow">in</span> <span class="n">mask</span><span class="p">:</span>
        <span class="n">t</span> <span class="o">=</span> <span class="n">a</span> <span class="o">+</span> <span class="nb">len</span><span class="p">(</span> <span class="n">m</span> <span class="p">)</span>
        <span class="n">ret</span><span class="o">.</span><span class="n">append</span><span class="p">(</span> <span class="n">string</span><span class="p">[</span><span class="n">a</span><span class="p">:</span><span class="n">t</span><span class="p">]</span> <span class="p">)</span>
        <span class="n">a</span> <span class="o">=</span> <span class="n">t</span> <span class="o">+</span> <span class="nb">len</span><span class="p">(</span> <span class="n">split</span> <span class="p">)</span>
    <span class="k">return</span><span class="p">(</span> <span class="n">ret</span> <span class="p">)</span></div>

<div class="viewcode-block" id="terms_in"><a class="viewcode-back" href="../ParallelRegression.html#ParallelRegression.terms_in">[docs]</a><span class="k">def</span> <span class="nf">terms_in</span><span class="p">(</span> <span class="n">formula</span> <span class="p">):</span>
    <span class="sd">&#39;&#39;&#39;Generator that yields individual terms in `formula`.</span>
<span class="sd">    &#39;&#39;&#39;</span>
    <span class="n">mask</span> <span class="o">=</span> <span class="n">mask_brackets</span><span class="p">(</span> <span class="n">formula</span> <span class="p">)</span>
    <span class="k">for</span> <span class="n">mobj</span> <span class="ow">in</span> <span class="n">termpattern</span><span class="o">.</span><span class="n">finditer</span><span class="p">(</span> <span class="n">mask</span> <span class="p">):</span>
        <span class="n">a</span><span class="p">,</span> <span class="n">t</span> <span class="o">=</span> <span class="n">mobj</span><span class="o">.</span><span class="n">span</span><span class="p">(</span> <span class="p">)</span>
        <span class="k">yield</span> <span class="n">formula</span><span class="p">[</span><span class="n">a</span><span class="p">:</span><span class="n">t</span><span class="p">]</span></div>

<span class="k">def</span> <span class="nf">_regex_split</span><span class="p">(</span> <span class="n">string</span><span class="p">,</span> <span class="n">pattern</span> <span class="p">):</span>
    <span class="sd">&#39;&#39;&#39;Like str.split( ) except that it splits on anything matching the regular</span>
<span class="sd">    expression pattern object.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    string : string</span>
<span class="sd">        The string to be split.</span>
<span class="sd">    pattern : regular expression pattern object</span>
<span class="sd">        The pattern object identifying the locations at which to split the</span>
<span class="sd">        string.  This is the object that is returned by re.compile( ).</span>

<span class="sd">    Yields</span>
<span class="sd">    ------</span>
<span class="sd">    string</span>
<span class="sd">        The strings in `string` that are between each pattern match.</span>
<span class="sd">    &#39;&#39;&#39;</span>
    <span class="n">a</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="n">wall</span> <span class="o">=</span> <span class="n">pattern</span><span class="o">.</span><span class="n">search</span><span class="p">(</span> <span class="n">string</span> <span class="p">)</span>
    <span class="k">while</span> <span class="n">wall</span> <span class="o">!=</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">t</span> <span class="o">=</span> <span class="n">wall</span><span class="o">.</span><span class="n">start</span><span class="p">(</span> <span class="p">)</span>
        <span class="k">yield</span><span class="p">(</span> <span class="n">string</span><span class="p">[</span><span class="n">a</span><span class="p">:</span><span class="n">t</span><span class="p">]</span> <span class="p">)</span>
        <span class="n">a</span> <span class="o">=</span> <span class="n">wall</span><span class="o">.</span><span class="n">end</span><span class="p">(</span> <span class="p">)</span>
        <span class="n">wall</span> <span class="o">=</span> <span class="n">pattern</span><span class="o">.</span><span class="n">search</span><span class="p">(</span> <span class="n">string</span><span class="p">,</span> <span class="n">a</span> <span class="p">)</span>
    <span class="k">if</span> <span class="n">a</span> <span class="o">&lt;</span> <span class="nb">len</span><span class="p">(</span> <span class="n">string</span> <span class="p">):</span>
        <span class="k">yield</span><span class="p">(</span> <span class="n">string</span><span class="p">[</span><span class="n">a</span><span class="p">:]</span> <span class="p">)</span>

<div class="viewcode-block" id="despace"><a class="viewcode-back" href="../ParallelRegression.html#ParallelRegression.despace">[docs]</a><span class="k">def</span> <span class="nf">despace</span><span class="p">(</span> <span class="n">string</span> <span class="p">):</span>
    <span class="sd">&#39;&#39;&#39;Removes inconsequential spaces without removing spaces that might impact</span>
<span class="sd">    the interpretation of a formula or line of code.</span>
<span class="sd">    &#39;&#39;&#39;</span>
    <span class="n">string</span> <span class="o">=</span> <span class="n">string</span><span class="o">.</span><span class="n">strip</span><span class="p">(</span> <span class="p">)</span>
    <span class="n">string</span> <span class="o">=</span> <span class="n">string</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span> <span class="s1">&#39;( &#39;</span><span class="p">,</span> <span class="s1">&#39;(&#39;</span> <span class="p">)</span>
    <span class="n">string</span> <span class="o">=</span> <span class="n">string</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span> <span class="s1">&#39; )&#39;</span><span class="p">,</span> <span class="s1">&#39;)&#39;</span> <span class="p">)</span>
    <span class="n">string</span> <span class="o">=</span> <span class="n">string</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span> <span class="s1">&#39; *&#39;</span><span class="p">,</span> <span class="s1">&#39;*&#39;</span> <span class="p">)</span>
    <span class="n">string</span> <span class="o">=</span> <span class="n">string</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span> <span class="s1">&#39;* &#39;</span><span class="p">,</span> <span class="s1">&#39;*&#39;</span> <span class="p">)</span>
    <span class="k">return</span><span class="p">(</span> <span class="n">string</span> <span class="p">)</span></div>

<span class="k">def</span> <span class="nf">_patsy_terms</span><span class="p">(</span> <span class="n">formula</span><span class="p">,</span> <span class="n">reduce_to_vars</span><span class="o">=</span><span class="kc">False</span> <span class="p">):</span>
    <span class="sd">&#39;&#39;&#39;Splits a formula string into a set of terms by splitting on `+`, `-` and</span>
<span class="sd">    `~` characters.  Then splits each term into a set of `factors` (as the</span>
<span class="sd">    Python package patsy uses the term) by splitting on `:` characters.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    formula : string</span>
<span class="sd">        The formula string to be split.</span>
<span class="sd">    reduce_to_vars : bool, optional</span>
<span class="sd">        If True, then each factor will be further split into Python variable</span>
<span class="sd">        names, with extraneous characters discarded.  In this scenario, the</span>
<span class="sd">        setList( ) representing the term contains all substrings representing</span>
<span class="sd">        valid Python variable names occuring in any factor in the term.</span>
<span class="sd">        * This is done without regard to whether or not a variable actually</span>
<span class="sd">        exists by the name in any given scope.</span>
<span class="sd">        * Python reserved keywords are discarded along with extraneous</span>
<span class="sd">        characters, but valid Python variable names that are the name of a</span>
<span class="sd">        builtin are included.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    setList( ) of setList( )s</span>
<span class="sd">    &#39;&#39;&#39;</span>
    <span class="c1">## Mask brackets so that only patsy operators are processed.</span>
    <span class="n">mask</span> <span class="o">=</span> <span class="n">mask_brackets</span><span class="p">(</span> <span class="n">formula</span> <span class="p">)</span>
    <span class="n">start</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="n">final</span> <span class="o">=</span> <span class="kc">False</span>
    <span class="n">patsySet</span> <span class="o">=</span> <span class="n">setList</span><span class="p">(</span> <span class="p">)</span>
    <span class="n">wall</span> <span class="o">=</span> <span class="n">splitter</span><span class="o">.</span><span class="n">search</span><span class="p">(</span> <span class="n">mask</span><span class="p">,</span> <span class="n">start</span> <span class="p">)</span>
    <span class="c1">## Treating `+`, `-`, and `~` as walls between terms,</span>
    <span class="c1">## create a set of factors in each term, splitting on &#39;:&#39;.</span>
    <span class="k">while</span> <span class="n">wall</span> <span class="o">!=</span> <span class="kc">None</span> <span class="ow">or</span> <span class="n">final</span> <span class="o">==</span> <span class="kc">False</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">wall</span> <span class="o">==</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">final</span> <span class="o">=</span> <span class="kc">True</span>
            <span class="n">endpos</span> <span class="o">=</span> <span class="n">wallpos</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span> <span class="n">formula</span> <span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">wallpos</span> <span class="o">=</span> <span class="n">wall</span><span class="o">.</span><span class="n">start</span><span class="p">(</span> <span class="p">)</span>
            <span class="n">endpos</span> <span class="o">=</span> <span class="n">wall</span><span class="o">.</span><span class="n">end</span><span class="p">(</span> <span class="p">)</span>
        <span class="n">factorStr</span> <span class="o">=</span> <span class="n">formula</span><span class="p">[</span><span class="n">start</span><span class="p">:</span><span class="n">wallpos</span><span class="p">]</span>
        <span class="n">factorList</span> <span class="o">=</span> <span class="n">factorStr</span><span class="o">.</span><span class="n">split</span><span class="p">(</span> <span class="s1">&#39;:&#39;</span> <span class="p">)</span>
        <span class="n">factorList2</span> <span class="o">=</span> <span class="n">setList</span><span class="p">(</span> <span class="p">)</span>
        <span class="k">for</span> <span class="n">f</span> <span class="ow">in</span> <span class="n">factorList</span><span class="p">:</span>
            <span class="n">f</span> <span class="o">=</span> <span class="n">despace</span><span class="p">(</span> <span class="n">f</span> <span class="p">)</span>
            <span class="k">if</span> <span class="n">reduce_to_vars</span> <span class="o">==</span> <span class="kc">True</span><span class="p">:</span>
                <span class="n">factorList2</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span> <span class="n">_vars_in_factor</span><span class="p">(</span> <span class="n">f</span> <span class="p">)</span> <span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">factorList2</span><span class="o">.</span><span class="n">append</span><span class="p">(</span> <span class="n">f</span> <span class="p">)</span>
        <span class="n">patsySet</span><span class="o">.</span><span class="n">append</span><span class="p">(</span> <span class="n">factorList2</span> <span class="p">)</span>
        <span class="n">start</span> <span class="o">=</span> <span class="n">endpos</span>
        <span class="k">if</span> <span class="n">wall</span> <span class="o">!=</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">wall</span> <span class="o">=</span> <span class="n">splitter</span><span class="o">.</span><span class="n">search</span><span class="p">(</span> <span class="n">mask</span><span class="p">,</span> <span class="n">start</span> <span class="p">)</span>
    <span class="k">return</span><span class="p">(</span> <span class="n">patsySet</span> <span class="p">)</span>

<span class="n">poly_rs</span> <span class="o">=</span> <span class="s1">r&#39; *([a-zA-Z_][a-zA-Z_0-9]*(?![a-zA-Z_0-9\(\{\[])) *\*\* *([0-9]+) *&#39;</span>
<span class="n">polypattern</span>   <span class="o">=</span> <span class="n">re</span><span class="o">.</span><span class="n">compile</span><span class="p">(</span> <span class="n">poly_rs</span> <span class="p">)</span>
<span class="n">polypattern_I</span> <span class="o">=</span> <span class="n">re</span><span class="o">.</span><span class="n">compile</span><span class="p">(</span> <span class="s1">r&#39;I\(&#39;</span> <span class="o">+</span> <span class="n">poly_rs</span> <span class="o">+</span> <span class="s1">r&#39;\)&#39;</span> <span class="p">)</span>

<span class="k">def</span> <span class="nf">pre_rstr</span><span class="p">(</span> <span class="n">name</span><span class="o">=</span><span class="kc">None</span> <span class="p">):</span>                        <span class="c1"># initial underscore omitted</span>
    <span class="k">if</span> <span class="n">name</span> <span class="o">==</span> <span class="kc">None</span><span class="p">:</span>                              <span class="c1"># for brevity, treat as a</span>
        <span class="k">return</span><span class="p">(</span> <span class="s1">r&#39;(?:L(?:[0-9]+))@&#39;</span> <span class="p">)</span>             <span class="c1"># private function.</span>
    <span class="k">return</span><span class="p">(</span> <span class="s1">r&#39;(?:L(?P&lt;&#39;</span> <span class="o">+</span> <span class="n">name</span> <span class="o">+</span> <span class="s1">r&#39;&gt;[0-9]+))@&#39;</span> <span class="p">)</span>

<span class="n">prefixed_varpattern_rstr</span> <span class="o">=</span> <span class="s1">r&#39;(?:&#39;</span> <span class="o">+</span> <span class="n">pre_rstr</span><span class="p">(</span> <span class="p">)</span> <span class="o">+</span> <span class="s1">r&#39;)?&#39;</span> <span class="o">+</span> <span class="n">varpattern_rstr</span>
<span class="n">prefixed_varpattern</span> <span class="o">=</span> <span class="n">re</span><span class="o">.</span><span class="n">compile</span><span class="p">(</span> <span class="n">prefixed_varpattern_rstr</span> <span class="p">)</span>
<span class="n">has_prefix_pat</span> <span class="o">=</span> <span class="n">re</span><span class="o">.</span><span class="n">compile</span><span class="p">(</span> <span class="s1">r&#39;(?:&#39;</span> <span class="o">+</span> <span class="n">pre_rstr</span><span class="p">(</span> <span class="s1">r&#39;lag&#39;</span> <span class="p">)</span> <span class="o">+</span> <span class="s1">r&#39;&#39;&#39;)</span>
<span class="s1">                               (?P&lt;column_name&gt;&#39;&#39;&#39;</span> <span class="o">+</span> <span class="n">varpattern_rstr</span> <span class="o">+</span> <span class="s1">r&#39;)&#39;</span><span class="p">,</span>
                               <span class="n">re</span><span class="o">.</span><span class="n">X</span> <span class="p">)</span>
<span class="n">prefixed_pat</span> <span class="o">=</span> <span class="n">re</span><span class="o">.</span><span class="n">compile</span><span class="p">(</span> <span class="s1">r&#39;(?:&#39;</span> <span class="o">+</span> <span class="n">pre_rstr</span><span class="p">(</span> <span class="s1">r&#39;lag&#39;</span> <span class="p">)</span> <span class="o">+</span> <span class="s1">r&#39;&#39;&#39;)?</span>
<span class="s1">                             (?P&lt;column_name&gt;&#39;&#39;&#39;</span> <span class="o">+</span> <span class="n">varpattern_rstr</span> <span class="o">+</span> <span class="s1">r&#39;)&#39;</span><span class="p">,</span>
                             <span class="n">re</span><span class="o">.</span><span class="n">X</span> <span class="p">)</span>
<span class="n">powerpattern</span> <span class="o">=</span> <span class="n">re</span><span class="o">.</span><span class="n">compile</span><span class="p">(</span> <span class="s1">r&#39;\ *(?:&#39;</span> <span class="o">+</span> <span class="n">pre_rstr</span><span class="p">(</span> <span class="s1">r&#39;lag&#39;</span> <span class="p">)</span> <span class="o">+</span> <span class="s1">r&#39;&#39;&#39;)?</span>
<span class="s1">                                (?P&lt;column_name&gt;&#39;&#39;&#39;</span> <span class="o">+</span> <span class="n">varpattern_rstr</span> <span class="o">+</span> <span class="s1">r&#39;&#39;&#39;)</span>
<span class="s1">                   (?:\ *\*\*\ *(?P&lt;power&gt;[0-9]+)\ *)?&#39;&#39;&#39;</span><span class="p">,</span> <span class="n">re</span><span class="o">.</span><span class="n">X</span> <span class="p">)</span>
<span class="c1">###############################################################################</span>
<span class="n">crosspower</span> <span class="o">=</span> <span class="n">re</span><span class="o">.</span><span class="n">compile</span><span class="p">(</span> <span class="s1">r&#39;(?:&#39;</span> <span class="o">+</span> <span class="n">pre_rstr</span><span class="p">(</span> <span class="s1">r&#39;lag_a&#39;</span> <span class="p">)</span> <span class="o">+</span> <span class="s1">r&#39;&#39;&#39;)?</span>
<span class="s1">                           (?P&lt;column_a&gt;&#39;&#39;&#39;</span> <span class="o">+</span> <span class="n">varpattern_rstr</span> <span class="o">+</span> <span class="s1">r&#39;&#39;&#39;)</span>
<span class="s1">              (?:\ *\*\*\ *(?P&lt;power_a&gt;[0-9]+)\ *)?</span>
<span class="s1">               \ *\*\ *&#39;&#39;&#39;</span> <span class="o">+</span> <span class="c1"># multiplication</span>
                         <span class="s1">r&#39;(?:&#39;</span> <span class="o">+</span> <span class="n">pre_rstr</span><span class="p">(</span> <span class="s1">r&#39;lag_b&#39;</span> <span class="p">)</span> <span class="o">+</span> <span class="s1">r&#39;&#39;&#39;)?</span>
<span class="s1">                           (?P&lt;column_b&gt;&#39;&#39;&#39;</span> <span class="o">+</span> <span class="n">varpattern_rstr</span> <span class="o">+</span> <span class="s1">r&#39;&#39;&#39;)</span>
<span class="s1">              (?:\ *\*\*\ *(?P&lt;power_b&gt;[0-9]+)\ *)?&#39;&#39;&#39;</span><span class="p">,</span> <span class="n">re</span><span class="o">.</span><span class="n">X</span> <span class="p">)</span>
<span class="c1">###############################################################################</span>
<span class="n">cross_Aor_power</span> <span class="o">=</span> <span class="n">re</span><span class="o">.</span><span class="n">compile</span><span class="p">(</span> <span class="s1">r&#39;(?:&#39;</span> <span class="o">+</span> <span class="n">pre_rstr</span><span class="p">(</span> <span class="s1">r&#39;lag_a&#39;</span> <span class="p">)</span> <span class="o">+</span> <span class="s1">r&#39;&#39;&#39;)?</span>
<span class="s1">                                (?P&lt;column_a&gt;&#39;&#39;&#39;</span> <span class="o">+</span> <span class="n">varpattern_rstr</span> <span class="o">+</span> <span class="s1">r&#39;&#39;&#39;)</span>
<span class="s1">                   (?:\ *\*\*\ *(?P&lt;power_a&gt;[0-9]+)\ *)?</span>
<span class="s1">                  \ *\*?\ *&#39;&#39;&#39;</span> <span class="o">+</span> <span class="c1"># multiplication</span>
                              <span class="s1">r&#39;(?:&#39;</span> <span class="o">+</span> <span class="n">pre_rstr</span><span class="p">(</span> <span class="s1">r&#39;lag_b&#39;</span> <span class="p">)</span> <span class="o">+</span> <span class="s1">r&#39;&#39;&#39;)?</span>
<span class="s1">                                (?P&lt;column_b&gt;&#39;&#39;&#39;</span> <span class="o">+</span> <span class="n">varpattern_rstr</span> <span class="o">+</span> <span class="s1">r&#39;&#39;&#39;)?</span>
<span class="s1">                   (?:\ *\*\*\ *(?P&lt;power_b&gt;[0-9]+)\ *)?&#39;&#39;&#39;</span><span class="p">,</span> <span class="n">re</span><span class="o">.</span><span class="n">X</span> <span class="p">)</span>
<span class="c1">###############################################################################</span>
<span class="n">crosspattern</span> <span class="o">=</span> <span class="n">re</span><span class="o">.</span><span class="n">compile</span><span class="p">(</span> <span class="s1">r&#39;\ *(?P&lt;column_a&gt;&#39;</span> <span class="o">+</span> <span class="n">varpattern_rstr</span> <span class="o">+</span> <span class="s1">r&#39;&#39;&#39;)</span>
<span class="s1">                   \ *\*\ *&#39;&#39;&#39;</span> <span class="o">+</span> <span class="c1"># multiplication</span>
                           <span class="s1">r&#39;\ *(?P&lt;column_b&gt;&#39;</span> <span class="o">+</span> <span class="n">varpattern_rstr</span> <span class="o">+</span> <span class="s1">r&#39;)\ *&#39;</span><span class="p">,</span>
                           <span class="n">re</span><span class="o">.</span><span class="n">X</span> <span class="p">)</span>

<span class="k">def</span> <span class="nf">_vars_in_factor</span><span class="p">(</span> <span class="n">factor</span> <span class="p">):</span>
    <span class="sd">&#39;&#39;&#39;Identifies valid Python variable names.</span>

<span class="sd">    This includes those used by builtins, but excludes reserved keywords.  The</span>
<span class="sd">    function&#39;s name refers to &quot;factors&quot; as patsy uses the term, as the function</span>
<span class="sd">    dates back to when patsy was used more extensively in the project for which</span>
<span class="sd">    mathDict was developed.</span>
<span class="sd">    &#39;&#39;&#39;</span>
    <span class="n">ret</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span> <span class="p">)</span>
    <span class="k">for</span> <span class="n">mobj</span> <span class="ow">in</span> <span class="n">varpattern</span><span class="o">.</span><span class="n">finditer</span><span class="p">(</span> <span class="n">factor</span> <span class="p">):</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">keyword</span><span class="o">.</span><span class="n">iskeyword</span><span class="p">(</span> <span class="n">mobj</span><span class="o">.</span><span class="n">group</span><span class="p">(</span> <span class="p">)</span> <span class="p">):</span>
            <span class="n">ret</span><span class="o">.</span><span class="n">append</span><span class="p">(</span> <span class="n">mobj</span><span class="o">.</span><span class="n">group</span><span class="p">(</span> <span class="p">)</span> <span class="p">)</span>
    <span class="k">return</span><span class="p">(</span> <span class="n">ret</span> <span class="p">)</span>

<span class="n">impr_space_pattern</span> <span class="o">=</span> <span class="n">re</span><span class="o">.</span><span class="n">compile</span><span class="p">(</span> <span class="s1">r&#39;([a-zA-Z_0-9]+) +([a-zA-Z_0-9]+)&#39;</span> <span class="p">)</span>
<div class="viewcode-block" id="formulas_match"><a class="viewcode-back" href="../ParallelRegression.html#ParallelRegression.formulas_match">[docs]</a><span class="k">def</span> <span class="nf">formulas_match</span><span class="p">(</span> <span class="n">formA</span><span class="p">,</span> <span class="n">formB</span> <span class="p">):</span>
    <span class="sd">&#39;&#39;&#39;Determines whether or not two formula strings are likely to be the same</span>
<span class="sd">    formula despite differences in the order of terms and/or spacing.</span>
<span class="sd">    &#39;&#39;&#39;</span>
    <span class="k">def</span> <span class="nf">re_sort</span><span class="p">(</span> <span class="n">item</span> <span class="p">):</span>
        <span class="sd">&#39;&#39;&#39;Divides a string into elements by splitting on single asterisks,</span>
<span class="sd">        sorts elements alphabetically, and reassembles the string by joining</span>
<span class="sd">        the elements with an asterisk.</span>

<span class="sd">        This way, terms consisting of multiple python variables multiplied</span>
<span class="sd">        together compare as equal regardless of the order in which the python</span>
<span class="sd">        variables are listed.</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="n">strList</span> <span class="o">=</span> <span class="p">[</span><span class="nb">str</span><span class="p">(</span> <span class="n">x</span> <span class="p">)</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">_regex_split</span><span class="p">(</span> <span class="n">item</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">one_star</span> <span class="p">)]</span>
        <span class="n">strList</span><span class="o">.</span><span class="n">sort</span><span class="p">(</span> <span class="p">)</span>
        <span class="n">item</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="s1">&#39;*&#39;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span> <span class="n">strList</span> <span class="p">)</span>
        <span class="k">return</span><span class="p">(</span> <span class="n">item</span> <span class="p">)</span>
    <span class="k">def</span> <span class="nf">prep</span><span class="p">(</span> <span class="n">string</span> <span class="p">):</span>
        <span class="n">mobj</span> <span class="o">=</span> <span class="n">impr_space_pattern</span><span class="o">.</span><span class="n">search</span><span class="p">(</span> <span class="n">string</span> <span class="p">)</span>
        <span class="k">if</span> <span class="n">mobj</span> <span class="ow">and</span> <span class="ow">not</span> <span class="p">(</span><span class="n">keyword</span><span class="o">.</span><span class="n">iskeyword</span><span class="p">(</span> <span class="n">mobj</span><span class="o">.</span><span class="n">group</span><span class="p">(</span> <span class="mi">1</span> <span class="p">)</span> <span class="p">)</span> <span class="ow">or</span> \
           <span class="n">keyword</span><span class="o">.</span><span class="n">iskeyword</span><span class="p">(</span> <span class="n">mobj</span><span class="o">.</span><span class="n">group</span><span class="p">(</span> <span class="mi">2</span> <span class="p">)</span> <span class="p">)):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span> <span class="s1">&#39;There is an improper space in `</span><span class="si">%s</span><span class="s1">`.&#39;</span> <span class="o">%</span> <span class="n">string</span> <span class="p">)</span>
        <span class="k">return</span><span class="p">(</span> <span class="n">string</span><span class="o">.</span><span class="n">split</span><span class="p">(</span> <span class="s1">&#39;~&#39;</span> <span class="p">)</span> <span class="p">)</span>
    <span class="k">def</span> <span class="nf">terms_match</span><span class="p">(</span> <span class="n">A</span><span class="p">,</span> <span class="n">B</span> <span class="p">):</span>
        <span class="sd">&#39;&#39;&#39;Separates each formula into a set( ) of terms, with each term</span>
<span class="sd">        represented as a frozenset( ).  Terms that are a product of multiple</span>
<span class="sd">        subterms have those subterms sorted in alphabetical order, but terms</span>
<span class="sd">        are otherwise left intact.</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="n">termsA</span> <span class="o">=</span> <span class="n">_patsy_terms</span><span class="p">(</span> <span class="n">A</span><span class="p">,</span> <span class="n">reduce_to_vars</span><span class="o">=</span><span class="kc">False</span> <span class="p">)</span>
        <span class="n">termsB</span> <span class="o">=</span> <span class="n">_patsy_terms</span><span class="p">(</span> <span class="n">B</span><span class="p">,</span> <span class="n">reduce_to_vars</span><span class="o">=</span><span class="kc">False</span> <span class="p">)</span>
        <span class="n">termsA</span><span class="o">.</span><span class="n">_re_sort</span> <span class="o">=</span> <span class="n">re_sort</span>
        <span class="n">termsB</span><span class="o">.</span><span class="n">_re_sort</span> <span class="o">=</span> <span class="n">re_sort</span>
        <span class="k">return</span><span class="p">(</span> <span class="n">termsA</span><span class="o">.</span><span class="n">as_fsets</span> <span class="o">==</span> <span class="n">termsB</span><span class="o">.</span><span class="n">as_fsets</span> <span class="p">)</span>
    <span class="k">def</span> <span class="nf">power_match</span><span class="p">(</span> <span class="n">A</span><span class="p">,</span> <span class="n">B</span> <span class="p">):</span>
        <span class="sd">&#39;&#39;&#39;Rejects the equality of the two formulas if they contain the same</span>
<span class="sd">        variable raised to different powers.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        False</span>
<span class="sd">            If there is one or more variables raised to different powers in the</span>
<span class="sd">            different formulas.</span>
<span class="sd">        True</span>
<span class="sd">            If the equality of the two formulas cannot be rejected on this</span>
<span class="sd">            narrow basis.</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="n">mobj_A</span> <span class="o">=</span> <span class="n">powerpattern</span><span class="o">.</span><span class="n">fullmatch</span><span class="p">(</span> <span class="n">mask_brackets</span><span class="p">(</span> <span class="n">A</span> <span class="p">)</span> <span class="p">)</span>
        <span class="k">if</span> <span class="n">mobj_A</span> <span class="o">==</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">return</span><span class="p">(</span> <span class="kc">True</span> <span class="p">)</span>
        <span class="n">dict_A</span> <span class="o">=</span> <span class="n">masked_dict</span><span class="p">(</span> <span class="n">A</span><span class="p">,</span> <span class="n">mobj_A</span> <span class="p">)</span>
        <span class="n">mobj_B</span> <span class="o">=</span> <span class="n">powerpattern</span><span class="o">.</span><span class="n">fullmatch</span><span class="p">(</span> <span class="n">mask_brackets</span><span class="p">(</span> <span class="n">B</span> <span class="p">)</span> <span class="p">)</span>
        <span class="k">if</span> <span class="n">mobj_B</span> <span class="o">==</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">return</span><span class="p">(</span> <span class="kc">False</span> <span class="p">)</span>
        <span class="n">dict_B</span> <span class="o">=</span> <span class="n">masked_dict</span><span class="p">(</span> <span class="n">B</span><span class="p">,</span> <span class="n">mobj_B</span> <span class="p">)</span>
        <span class="k">if</span> <span class="n">dict_A</span><span class="p">[</span><span class="s1">&#39;lag&#39;</span><span class="p">]</span> <span class="o">!=</span> <span class="n">dict_B</span><span class="p">[</span><span class="s1">&#39;lag&#39;</span><span class="p">]</span> <span class="ow">or</span> \
           <span class="ow">not</span> <span class="n">terms_match</span><span class="p">(</span> <span class="n">dict_A</span><span class="p">[</span><span class="s1">&#39;column_name&#39;</span><span class="p">],</span> <span class="n">dict_B</span><span class="p">[</span><span class="s1">&#39;column_name&#39;</span><span class="p">]</span> <span class="p">)</span> <span class="ow">or</span> \
           <span class="n">dict_A</span><span class="p">[</span><span class="s1">&#39;power&#39;</span><span class="p">]</span> <span class="o">!=</span> <span class="n">dict_B</span><span class="p">[</span><span class="s1">&#39;power&#39;</span><span class="p">]:</span>
            <span class="k">return</span><span class="p">(</span> <span class="kc">False</span> <span class="p">)</span>
        <span class="k">return</span><span class="p">(</span> <span class="kc">True</span> <span class="p">)</span>
    <span class="n">formA</span> <span class="o">=</span> <span class="n">prep</span><span class="p">(</span> <span class="n">formA</span> <span class="p">)</span>
    <span class="n">formB</span> <span class="o">=</span> <span class="n">prep</span><span class="p">(</span> <span class="n">formB</span> <span class="p">)</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span> <span class="n">formA</span> <span class="p">)</span> <span class="o">!=</span> <span class="nb">len</span><span class="p">(</span> <span class="n">formB</span> <span class="p">):</span>
        <span class="k">return</span><span class="p">(</span> <span class="kc">False</span> <span class="p">)</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span> <span class="nb">len</span><span class="p">(</span> <span class="n">formA</span> <span class="p">)</span> <span class="p">):</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">power_match</span><span class="p">(</span> <span class="n">formA</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">formB</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="p">):</span>
            <span class="k">return</span><span class="p">(</span> <span class="kc">False</span> <span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">terms_match</span><span class="p">(</span> <span class="n">formA</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">formB</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="p">):</span>
            <span class="k">return</span><span class="p">(</span> <span class="kc">False</span> <span class="p">)</span>
    <span class="k">return</span><span class="p">(</span> <span class="kc">True</span> <span class="p">)</span></div>

<span class="k">def</span> <span class="nf">_soft_in</span><span class="p">(</span> <span class="n">checking</span><span class="p">,</span> <span class="n">container</span><span class="p">,</span> <span class="n">else_unchanged</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">else_val</span><span class="o">=</span><span class="kc">None</span> <span class="p">):</span>
    <span class="sd">&#39;&#39;&#39;Checks for membership in a collection, without requiring exact string</span>
<span class="sd">    equality.</span>

<span class="sd">    If a member of the collection is determined to be a match based on</span>
<span class="sd">    formulas_match( ) finding that the strings are likely to be the same</span>
<span class="sd">    formula, then a tuple consisting of the formula as represented by the</span>
<span class="sd">    collection member, followed by True.</span>

<span class="sd">    Otherwise, it returns a tuple with either the original value for which</span>
<span class="sd">    membership is being tested or the value of the else_val parameter if set,</span>
<span class="sd">    followed by False.</span>
<span class="sd">    &#39;&#39;&#39;</span>
    <span class="c1">## Currently only used once in mathDictHypothesis.add( ).</span>
    <span class="k">if</span> <span class="n">checking</span> <span class="ow">in</span> <span class="n">container</span><span class="p">:</span>
        <span class="k">return</span><span class="p">(</span> <span class="n">checking</span><span class="p">,</span> <span class="kc">True</span> <span class="p">)</span>
    <span class="k">for</span> <span class="n">member</span> <span class="ow">in</span> <span class="n">container</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">formulas_match</span><span class="p">(</span> <span class="n">checking</span><span class="p">,</span> <span class="n">member</span> <span class="p">):</span>
            <span class="k">return</span><span class="p">(</span> <span class="n">member</span><span class="p">,</span> <span class="kc">True</span> <span class="p">)</span>
    <span class="k">if</span> <span class="n">else_unchanged</span><span class="p">:</span>
        <span class="n">else_val</span> <span class="o">=</span> <span class="n">checking</span>
    <span class="k">return</span><span class="p">(</span> <span class="n">else_val</span><span class="p">,</span> <span class="kc">False</span> <span class="p">)</span>

<div class="viewcode-block" id="termString"><a class="viewcode-back" href="../ParallelRegression.html#ParallelRegression.termString">[docs]</a><span class="k">def</span> <span class="nf">termString</span><span class="p">(</span> <span class="n">formula</span><span class="p">,</span> <span class="n">termList</span> <span class="p">):</span>
    <span class="sd">&#39;&#39;&#39;Returns the subset of terms in `termList` that occur in `formula`.</span>
<span class="sd">    &#39;&#39;&#39;</span>
    <span class="n">termString</span> <span class="o">=</span> <span class="s1">&#39;&#39;</span>
    <span class="k">for</span> <span class="n">t</span> <span class="ow">in</span> <span class="n">termList</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">has_term</span><span class="p">(</span> <span class="n">formula</span><span class="p">,</span> <span class="n">t</span> <span class="p">):</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span> <span class="n">termString</span> <span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">termString</span> <span class="o">+=</span> <span class="s1">&#39;, &#39;</span>
            <span class="n">termString</span> <span class="o">+=</span> <span class="n">t</span>
    <span class="k">return</span><span class="p">(</span> <span class="n">termString</span> <span class="p">)</span></div>

<span class="k">def</span> <span class="nf">_mapper</span><span class="p">(</span> <span class="n">ProcessQueue</span><span class="p">,</span>
             <span class="n">ReturnQueue</span><span class="p">,</span>
             <span class="n">SharedDataArray</span><span class="p">,</span>
             <span class="n">mDictCfg</span><span class="p">,</span>
             <span class="n">func</span><span class="p">,</span>
             <span class="n">placement</span><span class="p">,</span>
             <span class="n">number_results</span><span class="o">=</span><span class="kc">False</span> <span class="p">):</span>
    <span class="sd">&#39;&#39;&#39;Used by mathDict.iter_map( ) and .map( ) as a wrapper around the</span>
<span class="sd">    function to be mapped to the rows of the mathDict( ).</span>

<span class="sd">    See mathDict.iter_map( ) for usage details.</span>
<span class="sd">    &#39;&#39;&#39;</span>
    <span class="n">mDict</span> <span class="o">=</span> <span class="n">mDictCfg</span><span class="o">.</span><span class="n">rebuild</span><span class="p">(</span> <span class="n">SharedDataArray</span> <span class="p">)</span>
    <span class="n">matrix</span> <span class="o">=</span> <span class="n">mDict</span><span class="p">[:]</span>
    <span class="n">QueueObject</span> <span class="o">=</span> <span class="n">ProcessQueue</span><span class="o">.</span><span class="n">get</span><span class="p">(</span> <span class="p">)</span>
    <span class="k">while</span> <span class="n">QueueObject</span> <span class="o">!=</span> <span class="s1">&#39;Terminate.&#39;</span><span class="p">:</span>
        <span class="n">rid</span><span class="p">,</span> <span class="n">args</span><span class="p">,</span> <span class="n">kwargs</span> <span class="o">=</span> <span class="n">QueueObject</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span> <span class="n">placement</span><span class="p">,</span> <span class="nb">int</span> <span class="p">):</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span> <span class="n">args</span> <span class="p">)</span> <span class="o">&lt;</span> <span class="n">placement</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span> <span class="s1">&#39;Not enough positional arguments to insert &#39;</span>
                                  <span class="s1">&#39;the matrix at </span><span class="si">%d</span><span class="s1">.&#39;</span> <span class="o">%</span> <span class="n">placement</span> <span class="p">)</span>
            <span class="n">pargs</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span> <span class="n">args</span><span class="p">[:</span><span class="n">placement</span><span class="p">]</span> <span class="p">)</span>
            <span class="n">pargs</span><span class="o">.</span><span class="n">append</span><span class="p">(</span> <span class="n">matrix</span> <span class="p">)</span>
            <span class="n">pargs</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span> <span class="n">args</span><span class="p">[</span><span class="n">placement</span><span class="p">:]</span> <span class="p">)</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span> <span class="n">placement</span><span class="p">,</span> <span class="nb">str</span> <span class="p">):</span>
            <span class="n">kwargs</span><span class="p">[</span><span class="n">placement</span><span class="p">]</span> <span class="o">=</span> <span class="n">matrix</span>
            <span class="n">pargs</span> <span class="o">=</span> <span class="n">args</span>
        <span class="n">ReturnQueue</span><span class="o">.</span><span class="n">put</span><span class="p">(</span> <span class="p">(</span><span class="n">rid</span><span class="p">,</span> <span class="n">func</span><span class="p">(</span> <span class="o">*</span><span class="n">pargs</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span> <span class="p">))</span> <span class="p">)</span>
        <span class="n">QueueObject</span> <span class="o">=</span> <span class="n">ProcessQueue</span><span class="o">.</span><span class="n">get</span><span class="p">(</span> <span class="p">)</span>
    <span class="n">ReturnQueue</span><span class="o">.</span><span class="n">put</span><span class="p">(</span> <span class="s1">&#39;Terminated.&#39;</span> <span class="p">)</span>

<div class="viewcode-block" id="CategoryError"><a class="viewcode-back" href="../ParallelRegression.html#ParallelRegression.CategoryError">[docs]</a><span class="k">class</span> <span class="nc">CategoryError</span><span class="p">(</span><span class="ne">Exception</span><span class="p">):</span>
    <span class="sd">&#39;&#39;&#39;Raised by categorizedSetDict( ) when an error results from an invalid</span>
<span class="sd">    category as opposed to an invalid key or value that would raise a KeyError</span>
<span class="sd">    or ValueError.</span>
<span class="sd">    &#39;&#39;&#39;</span>
    <span class="k">pass</span></div>

<div class="viewcode-block" id="UnsupportedColumn"><a class="viewcode-back" href="../ParallelRegression.html#ParallelRegression.UnsupportedColumn">[docs]</a><span class="k">class</span> <span class="nc">UnsupportedColumn</span><span class="p">(</span><span class="ne">Warning</span><span class="p">):</span>
    <span class="sd">&#39;&#39;&#39;Raised by mathDict( ) when .add( ) or .add_from_RHS( ) is used in an</span>
<span class="sd">    attempt to add a string as a column that is not understood as a column by</span>
<span class="sd">    mathDict( ).</span>

<span class="sd">    Attributes</span>
<span class="sd">    ----------</span>
<span class="sd">    msg, args[0] : string</span>
<span class="sd">        Error message.</span>
<span class="sd">    columns, args[1] : list</span>
<span class="sd">        Lists the column or columns that are not understood by mathDict( ).</span>
<span class="sd">    LHS : string</span>
<span class="sd">        The left-hand-side of a formula string provided to .add_from_RHS( )</span>
<span class="sd">        when the formula string contained at least one tilde (&#39;~&#39;) character.</span>
<span class="sd">    &#39;&#39;&#39;</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="n">LHS</span><span class="o">=</span><span class="kc">None</span> <span class="p">):</span>
        <span class="ne">Warning</span><span class="o">.</span><span class="n">__init__</span><span class="p">(</span> <span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span> <span class="p">)</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span> <span class="n">args</span> <span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">msg</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">args</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span> <span class="n">args</span> <span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">columns</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">args</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">LHS</span> <span class="o">=</span> <span class="n">LHS</span></div>

<div class="viewcode-block" id="mathDictKeyError"><a class="viewcode-back" href="../ParallelRegression.html#ParallelRegression.mathDictKeyError">[docs]</a><span class="k">class</span> <span class="nc">mathDictKeyError</span><span class="p">(</span><span class="ne">KeyError</span><span class="p">):</span>
    <span class="sd">&#39;&#39;&#39;Subclass of KeyError used in error handling to distinguish between</span>
<span class="sd">    calling mathDict( ).__getitem__( ) with an invalid key/index, resulting in</span>
<span class="sd">    mathDictKeyError, or a facially-valid key/index the handling of which</span>
<span class="sd">    causes a KeyError for some other reason.</span>
<span class="sd">    &#39;&#39;&#39;</span>
    <span class="k">pass</span></div>

<div class="viewcode-block" id="RankError"><a class="viewcode-back" href="../ParallelRegression.html#ParallelRegression.RankError">[docs]</a><span class="k">class</span> <span class="nc">RankError</span><span class="p">(</span><span class="ne">Warning</span><span class="p">):</span>
    <span class="sd">&#39;&#39;&#39;Raised by mathDictHypothesis( ) when mathDictHypothesis( ).add( ) is</span>
<span class="sd">    able to determine that adding a hypothesis about the specified column would</span>
<span class="sd">    result in a matrix of insufficient rank for computing an F statistic</span>
<span class="sd">    evaluating the hypothesis.</span>

<span class="sd">    To enable mathDict&#39;s ability to anticipate matrices of less than full rank,</span>
<span class="sd">    use the .terms termSet( ) attribute of mathDict( ) to inform</span>
<span class="sd">    mathDictHypothesis( ) which terms in which forms are dummy variables.  This</span>
<span class="sd">    has been shown in profiles to be substantially more efficient than</span>
<span class="sd">    mathematically determining the impact of the additional column on the rank</span>
<span class="sd">    of the matrix.</span>

<span class="sd">    Example</span>
<span class="sd">    -------</span>
<span class="sd">    &gt;&gt;&gt; RA, MD = mathDictMaker( [details omitted] ).make( )</span>
<span class="sd">    &gt;&gt;&gt; MD.terms = termSet( [details omitted] )</span>
<span class="sd">    &gt;&gt;&gt; MD.hypothesis.add( [details omitted] )</span>
<span class="sd">    &gt;&gt;&gt; # Link the mathDict( ) to an existing termSet( ) using simple attribute</span>
<span class="sd">    &gt;&gt;&gt; # assignment.</span>
<span class="sd">    &#39;&#39;&#39;</span>
    <span class="k">pass</span></div>

<div class="viewcode-block" id="setList"><a class="viewcode-back" href="../ParallelRegression.html#ParallelRegression.setList">[docs]</a><span class="k">class</span> <span class="nc">setList</span><span class="p">(</span><span class="n">UserList</span><span class="p">):</span>
    <span class="sd">&#39;&#39;&#39;List that eliminates redundant list items and implements set comparison</span>
<span class="sd">    methods.</span>
<span class="sd">    &#39;&#39;&#39;</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">values</span><span class="o">=</span><span class="kc">None</span> <span class="p">):</span>
        <span class="n">UserList</span><span class="o">.</span><span class="n">__init__</span><span class="p">(</span> <span class="bp">self</span> <span class="p">)</span>
        <span class="k">if</span> <span class="n">values</span> <span class="o">!=</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span> <span class="n">values</span> <span class="p">)</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span> <span class="n">values</span><span class="p">,</span> <span class="p">(</span><span class="nb">set</span><span class="p">,</span> <span class="nb">frozenset</span><span class="p">,</span> <span class="nb">type</span><span class="p">(</span> <span class="nb">dict</span><span class="p">(</span> <span class="p">)</span><span class="o">.</span><span class="n">keys</span><span class="p">(</span> <span class="p">)</span> <span class="p">))</span> <span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">sort</span><span class="p">(</span> <span class="p">)</span>

    <span class="k">def</span> <span class="nf">__setitem__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">key</span><span class="p">,</span> <span class="n">value</span> <span class="p">):</span>
        <span class="k">if</span> <span class="n">value</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">lastSIOutcome</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">key</span> <span class="o">==</span> <span class="nb">len</span><span class="p">(</span> <span class="bp">self</span><span class="o">.</span><span class="n">data</span> <span class="p">):</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">append</span><span class="p">(</span> <span class="n">value</span> <span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="n">value</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">lastSIOutcome</span> <span class="o">=</span> <span class="kc">True</span>

    <span class="k">def</span> <span class="nf">append</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">value</span> <span class="p">):</span>
        <span class="k">if</span> <span class="n">value</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="p">:</span>
            <span class="k">return</span><span class="p">(</span> <span class="kc">False</span> <span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">append</span><span class="p">(</span> <span class="n">value</span> <span class="p">)</span>
            <span class="k">return</span><span class="p">(</span> <span class="kc">True</span> <span class="p">)</span>

    <span class="k">def</span> <span class="nf">extend</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">values</span> <span class="p">):</span>
        <span class="k">return</span><span class="p">(</span> <span class="bp">self</span><span class="o">.</span><span class="n">update</span><span class="p">(</span> <span class="n">values</span> <span class="p">)</span> <span class="p">)</span>

    <span class="k">def</span> <span class="nf">add</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">value</span> <span class="p">):</span>
        <span class="k">return</span><span class="p">(</span> <span class="bp">self</span><span class="o">.</span><span class="n">append</span><span class="p">(</span> <span class="n">value</span> <span class="p">)</span> <span class="p">)</span>

    <span class="k">def</span> <span class="nf">discard</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">value</span> <span class="p">):</span>
        <span class="k">if</span> <span class="n">value</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">remove</span><span class="p">(</span> <span class="n">value</span> <span class="p">)</span>
            <span class="k">return</span><span class="p">(</span> <span class="kc">True</span> <span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span><span class="p">(</span> <span class="kc">False</span> <span class="p">)</span>

    <span class="k">def</span> <span class="nf">pop</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="p">,</span> <span class="n">value</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">index</span><span class="o">=</span><span class="kc">None</span> <span class="p">):</span>
        <span class="k">if</span> <span class="n">index</span> <span class="o">!=</span> <span class="kc">None</span> <span class="ow">and</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span> <span class="n">index</span><span class="p">,</span> <span class="nb">int</span> <span class="p">):</span>
            <span class="k">raise</span> <span class="ne">KeyError</span><span class="p">(</span> <span class="s1">&#39;Index must be specified as an integer.&#39;</span><span class="p">,</span> <span class="n">index</span> <span class="p">)</span>
        <span class="k">if</span> <span class="n">value</span> <span class="o">!=</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">index</span> <span class="o">!=</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">KeyError</span><span class="p">(</span> <span class="s1">&#39;Pop can remove an item by index or value but not&#39;</span>
                            <span class="s1">&#39; both.  Value specified: </span><span class="si">%s</span><span class="s1">, index specified: </span><span class="si">%d</span><span class="s1">.&#39;</span>
                            <span class="o">%</span> <span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="n">index</span><span class="p">)</span> <span class="p">)</span>
        <span class="k">if</span> <span class="n">index</span> <span class="o">!=</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">return</span><span class="p">(</span> <span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span> <span class="n">index</span> <span class="p">)</span> <span class="p">)</span>
        <span class="k">elif</span> <span class="n">value</span> <span class="o">!=</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">value</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">KeyError</span><span class="p">(</span> <span class="s1">&#39;`</span><span class="si">%s</span><span class="s1">` not in </span><span class="si">%s</span><span class="s1">.&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span> <span class="p">)</span>
            <span class="n">i</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">index</span><span class="p">(</span> <span class="n">value</span> <span class="p">)</span>
            <span class="k">return</span><span class="p">(</span> <span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span> <span class="n">i</span> <span class="p">)</span> <span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">KeyError</span><span class="p">(</span> <span class="s1">&#39;One of `index` or `value` must be specified by &#39;</span>
                            <span class="s1">&#39;keyword arguement when calling setList.pop( ).&#39;</span> <span class="p">)</span>

    <span class="k">def</span> <span class="nf">update</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">values</span> <span class="p">):</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span> <span class="n">values</span><span class="p">,</span> <span class="p">(</span><span class="nb">set</span><span class="p">,</span> <span class="nb">frozenset</span><span class="p">,</span> <span class="nb">type</span><span class="p">(</span> <span class="nb">dict</span><span class="p">(</span> <span class="p">)</span><span class="o">.</span><span class="n">keys</span><span class="p">(</span> <span class="p">)</span> <span class="p">))</span> <span class="p">):</span>
            <span class="n">values</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span> <span class="n">values</span> <span class="p">)</span>
            <span class="n">values</span><span class="o">.</span><span class="n">sort</span><span class="p">(</span> <span class="p">)</span>
        <span class="n">counter</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">for</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">values</span><span class="p">:</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">append</span><span class="p">(</span> <span class="n">v</span> <span class="p">)</span> <span class="o">==</span> <span class="kc">True</span><span class="p">:</span>
                <span class="n">counter</span> <span class="o">+=</span> <span class="mi">1</span>
        <span class="k">return</span><span class="p">(</span> <span class="n">counter</span> <span class="p">)</span>

    <span class="k">def</span> <span class="nf">difference</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span> <span class="p">):</span>
        <span class="n">new</span> <span class="o">=</span> <span class="n">setList</span><span class="p">(</span> <span class="p">)</span>
        <span class="k">for</span> <span class="n">value</span> <span class="ow">in</span> <span class="bp">self</span><span class="p">:</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">value</span> <span class="ow">in</span> <span class="n">other</span><span class="p">:</span>
                <span class="n">new</span><span class="o">.</span><span class="n">append</span><span class="p">(</span> <span class="n">value</span> <span class="p">)</span>
        <span class="k">return</span><span class="p">(</span> <span class="n">new</span> <span class="p">)</span>

    <span class="k">def</span> <span class="nf">union</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span> <span class="p">):</span>
        <span class="n">new</span> <span class="o">=</span> <span class="n">setList</span><span class="p">(</span> <span class="p">)</span>
        <span class="n">new</span><span class="o">.</span><span class="n">update</span><span class="p">(</span> <span class="bp">self</span> <span class="p">)</span>
        <span class="n">new</span><span class="o">.</span><span class="n">update</span><span class="p">(</span> <span class="n">other</span> <span class="p">)</span>
        <span class="k">return</span><span class="p">(</span> <span class="n">new</span> <span class="p">)</span>

    <span class="k">def</span> <span class="nf">intersection</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span> <span class="p">):</span>
        <span class="n">new</span> <span class="o">=</span> <span class="n">setList</span><span class="p">(</span> <span class="p">)</span>
        <span class="k">for</span> <span class="n">value</span> <span class="ow">in</span> <span class="bp">self</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">value</span> <span class="ow">in</span> <span class="n">other</span><span class="p">:</span>
                <span class="n">new</span><span class="o">.</span><span class="n">append</span><span class="p">(</span> <span class="n">value</span> <span class="p">)</span>
        <span class="k">return</span><span class="p">(</span> <span class="n">new</span> <span class="p">)</span>

    <span class="k">def</span> <span class="nf">issubset</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span> <span class="p">):</span>
        <span class="k">for</span> <span class="n">value</span> <span class="ow">in</span> <span class="bp">self</span><span class="p">:</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">value</span> <span class="ow">in</span> <span class="n">other</span><span class="p">:</span>
                <span class="k">return</span><span class="p">(</span> <span class="kc">False</span> <span class="p">)</span>
        <span class="k">return</span><span class="p">(</span> <span class="kc">True</span> <span class="p">)</span>

    <span class="k">def</span> <span class="nf">issuperset</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span> <span class="p">):</span>
        <span class="k">for</span> <span class="n">value</span> <span class="ow">in</span> <span class="n">other</span><span class="p">:</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">value</span> <span class="ow">in</span> <span class="bp">self</span><span class="p">:</span>
                <span class="k">return</span><span class="p">(</span> <span class="kc">False</span> <span class="p">)</span>
        <span class="k">return</span><span class="p">(</span> <span class="kc">True</span> <span class="p">)</span>

    <span class="k">def</span> <span class="nf">symmetric_difference</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span> <span class="p">):</span>
        <span class="n">new</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">difference</span><span class="p">(</span> <span class="n">other</span> <span class="p">)</span>
        <span class="k">for</span> <span class="n">value</span> <span class="ow">in</span> <span class="n">other</span><span class="p">:</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">value</span> <span class="ow">in</span> <span class="bp">self</span><span class="p">:</span>
                <span class="n">new</span><span class="o">.</span><span class="n">append</span><span class="p">(</span> <span class="n">value</span> <span class="p">)</span>
        <span class="k">return</span><span class="p">(</span> <span class="n">new</span> <span class="p">)</span>

    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">_re_sort</span><span class="p">(</span> <span class="n">item</span> <span class="p">):</span>
        <span class="c1">## Exists so that it can be replaced by assignment on specific</span>
        <span class="c1">## instances.</span>
        <span class="k">return</span><span class="p">(</span> <span class="n">item</span> <span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">as_fsets</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&#39;&#39;&#39;set( ) of frozenset( )s of the items in each setList( ) member.  The</span>
<span class="sd">        use of frozenset( )s enables the set( ) to contain otherwise non-</span>
<span class="sd">        hashable objects.  Useful for order-insensitive equality testing.</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="n">ret</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span> <span class="p">)</span>
        <span class="k">for</span> <span class="n">item</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="p">:</span>
            <span class="n">ret</span><span class="o">.</span><span class="n">add</span><span class="p">(</span> <span class="nb">frozenset</span><span class="p">(</span> <span class="bp">self</span><span class="o">.</span><span class="n">_re_sort</span><span class="p">(</span> <span class="n">item</span> <span class="p">)</span> <span class="p">)</span> <span class="p">)</span>
        <span class="k">return</span><span class="p">(</span> <span class="n">ret</span> <span class="p">)</span></div>

<div class="viewcode-block" id="typedDict"><a class="viewcode-back" href="../ParallelRegression.html#ParallelRegression.typedDict">[docs]</a><span class="k">class</span> <span class="nc">typedDict</span><span class="p">(</span><span class="nb">dict</span><span class="p">):</span>
    <span class="sd">&#39;&#39;&#39;dict( ) that is restricted to entries consisting of values of a</span>
<span class="sd">    specified type.</span>

<span class="sd">    typedDict also supports default values whereby new entries are created by</span>
<span class="sd">    deepcopy( )ing an object as opposed to creating a new instance of a class,</span>
<span class="sd">    and supports a write-once mode in which keys that have a value associated</span>
<span class="sd">    with them cannot be changed, but values that are mutable objects may still</span>
<span class="sd">    mutate.</span>

<span class="sd">    Each item has an integer key, and may also have a string key associated</span>
<span class="sd">    with it, but a string key is not required.  I.e., there is a (zero-or-one)-</span>
<span class="sd">    to-one relationship between string keys and dictionary entries, as well as</span>
<span class="sd">    a one-to-one relationship between integer keys and dictionary entries.</span>

<span class="sd">    Integer keys are not preserved when typedDict( ) is copied.</span>
<span class="sd">    &#39;&#39;&#39;</span>

<div class="viewcode-block" id="typedDict.__init__"><a class="viewcode-back" href="../ParallelRegression.html#ParallelRegression.typedDict.__init__">[docs]</a>    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">typeRequirement</span><span class="p">,</span> <span class="n">writeOnce</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">default</span><span class="o">=</span><span class="kc">None</span> <span class="p">):</span>
        <span class="sd">&#39;&#39;&#39;Creates a typedDict( ) instance.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        typeRequirement : type</span>
<span class="sd">            Dictionary entries will only be accepted if they satisfy</span>
<span class="sd">            `isinstance( obj, typeRequirement )`.</span>
<span class="sd">        writeOnce : bool</span>
<span class="sd">            If True, then once a dictionary entry has been created for a key,</span>
<span class="sd">            the dictionary entry cannot be changed.  If the entry consists of a</span>
<span class="sd">            mutable object, the object may still mutate.</span>
<span class="sd">        default : object of type `typeRequirement`, optional</span>
<span class="sd">            If set, then attempting to access a dictionary entry that does not</span>
<span class="sd">            yet exist will result in a deepcopy of this object being used to</span>
<span class="sd">            create an entry for the requested key.</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">typeRequirement</span> <span class="o">=</span> <span class="n">typeRequirement</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">writeOnce</span> <span class="o">=</span> <span class="n">writeOnce</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">strKeys</span> <span class="o">=</span> <span class="n">OrderedDict</span><span class="p">(</span> <span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_intAvail</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">if</span> <span class="n">default</span> <span class="o">!=</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span> <span class="n">default</span><span class="p">,</span> <span class="n">typeRequirement</span> <span class="p">):</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">default</span> <span class="o">=</span> <span class="n">default</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span> <span class="s1">&#39;The default item must be of the required &#39;</span>
                                 <span class="s1">&#39;type.&#39;</span> <span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">pickle</span> <span class="o">=</span> <span class="kc">False</span></div>

    <span class="k">def</span> <span class="nf">__deepcopy__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">memo_dict</span> <span class="p">):</span>
        <span class="k">if</span> <span class="s1">&#39;default&#39;</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">__dir__</span><span class="p">(</span> <span class="p">):</span>
            <span class="n">d</span> <span class="o">=</span> <span class="n">deepcopy</span><span class="p">(</span> <span class="bp">self</span><span class="o">.</span><span class="n">default</span><span class="p">,</span> <span class="n">memo_dict</span> <span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">d</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="n">new</span> <span class="o">=</span> <span class="n">typedDict</span><span class="p">(</span> <span class="bp">self</span><span class="o">.</span><span class="n">typeRequirement</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">writeOnce</span><span class="p">,</span> <span class="n">d</span> <span class="p">)</span>
        <span class="n">new</span><span class="o">.</span><span class="n">union_update</span><span class="p">(</span> <span class="bp">self</span> <span class="p">)</span>
        <span class="k">return</span><span class="p">(</span> <span class="n">new</span> <span class="p">)</span>

    <span class="k">def</span> <span class="nf">__setitem__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">key</span><span class="p">,</span> <span class="n">val</span> <span class="p">):</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="s1">&#39;pickle&#39;</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">__dir__</span><span class="p">(</span> <span class="p">):</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span> <span class="n">key</span><span class="p">,</span> <span class="nb">int</span> <span class="p">):</span>
                <span class="nb">dict</span><span class="o">.</span><span class="n">__setitem__</span><span class="p">(</span> <span class="bp">self</span><span class="p">,</span> <span class="n">key</span><span class="p">,</span> <span class="n">val</span> <span class="p">)</span>
                <span class="k">return</span><span class="p">(</span> <span class="n">key</span> <span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">KeyError</span><span class="p">(</span> <span class="s1">&#39;Only integer keys are supported during &#39;</span>
                                <span class="s1">&#39;unpickling.&#39;</span> <span class="p">)</span>
        <span class="c1">## Translate string keys into integer keys.</span>
        <span class="k">if</span> <span class="n">key</span> <span class="ow">in</span> <span class="bp">self</span><span class="p">:</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">writeOnce</span> <span class="o">==</span> <span class="kc">True</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">KeyError</span><span class="p">(</span> <span class="s1">&#39;This typedDict( ) is write-once.  The key, &#39;</span>
                                <span class="s1">&#39;`</span><span class="si">%s</span><span class="s1">`, has already been set.&#39;</span> <span class="o">%</span> <span class="n">key</span> <span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">intKey</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_int_key</span><span class="p">(</span> <span class="n">key</span> <span class="p">)</span>
        <span class="c1">## For new string keys: find an available integer key.</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span> <span class="n">key</span><span class="p">,</span> <span class="nb">str</span> <span class="p">)</span> <span class="ow">and</span> \
             <span class="nb">isinstance</span><span class="p">(</span> <span class="n">val</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">typeRequirement</span> <span class="p">):</span>
            <span class="k">while</span> <span class="bp">self</span><span class="o">.</span><span class="n">_intAvail</span> <span class="ow">in</span> <span class="bp">self</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_intAvail</span> <span class="o">+=</span> <span class="mi">1</span>
            <span class="n">intKey</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_intAvail</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">strKeys</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="n">intKey</span>
        <span class="c1">## Having ascertained the appropriate integer key, set the item.</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span> <span class="n">key</span><span class="p">,</span> <span class="nb">int</span> <span class="p">):</span>
            <span class="n">intKey</span> <span class="o">=</span> <span class="n">key</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span> <span class="n">val</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">typeRequirement</span> <span class="p">):</span>
            <span class="nb">dict</span><span class="o">.</span><span class="n">__setitem__</span><span class="p">(</span> <span class="bp">self</span><span class="p">,</span> <span class="n">intKey</span><span class="p">,</span> <span class="n">val</span> <span class="p">)</span>
            <span class="k">return</span><span class="p">(</span> <span class="n">intKey</span> <span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span> <span class="s1">&#39;This typedDict( ) has been configured to only &#39;</span>
                           <span class="s1">&#39;accept list items of type </span><span class="si">%s</span><span class="s1">.  Cannot accept a </span><span class="si">%s</span><span class="s1">.&#39;</span>
                           <span class="o">%</span> <span class="p">(</span><span class="nb">str</span><span class="p">(</span> <span class="bp">self</span><span class="o">.</span><span class="n">typeRequirement</span> <span class="p">),</span>
                              <span class="nb">str</span><span class="p">(</span> <span class="nb">type</span><span class="p">(</span> <span class="n">val</span> <span class="p">)</span> <span class="p">))</span> <span class="p">)</span>

    <span class="k">def</span> <span class="nf">__getitem__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">key</span> <span class="p">):</span>
        <span class="n">ik</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_int_key</span><span class="p">(</span> <span class="n">key</span> <span class="p">)</span>
        <span class="k">if</span> <span class="n">ik</span> <span class="o">==</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">return</span><span class="p">(</span> <span class="bp">self</span><span class="o">.</span><span class="n">__missing__</span><span class="p">(</span> <span class="n">key</span> <span class="p">)</span> <span class="p">)</span>
        <span class="k">return</span><span class="p">(</span> <span class="nb">dict</span><span class="o">.</span><span class="n">__getitem__</span><span class="p">(</span> <span class="bp">self</span><span class="p">,</span> <span class="n">ik</span> <span class="p">)</span> <span class="p">)</span>

    <span class="k">def</span> <span class="nf">__contains__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">key</span> <span class="p">):</span>
        <span class="n">key</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_int_key</span><span class="p">(</span> <span class="n">key</span> <span class="p">)</span>
        <span class="k">return</span><span class="p">(</span> <span class="nb">dict</span><span class="o">.</span><span class="n">__contains__</span><span class="p">(</span> <span class="bp">self</span><span class="p">,</span> <span class="n">key</span> <span class="p">)</span> <span class="p">)</span>

    <span class="k">def</span> <span class="nf">__missing__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">key</span> <span class="p">):</span>
        <span class="k">if</span> <span class="s1">&#39;default&#39;</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">__dir__</span><span class="p">(</span> <span class="p">)</span> <span class="ow">and</span> \
           <span class="nb">isinstance</span><span class="p">(</span> <span class="bp">self</span><span class="o">.</span><span class="n">default</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">typeRequirement</span> <span class="p">):</span>
            <span class="n">newObj</span> <span class="o">=</span> <span class="n">deepcopy</span><span class="p">(</span> <span class="bp">self</span><span class="o">.</span><span class="n">default</span> <span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">newObj</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">typeRequirement</span><span class="p">(</span> <span class="p">)</span>
        <span class="n">typedDict</span><span class="o">.</span><span class="n">__setitem__</span><span class="p">(</span> <span class="bp">self</span><span class="p">,</span> <span class="n">key</span><span class="p">,</span> <span class="n">newObj</span> <span class="p">)</span>
        <span class="k">return</span><span class="p">(</span> <span class="bp">self</span><span class="o">.</span><span class="n">__getitem__</span><span class="p">(</span> <span class="n">key</span> <span class="p">)</span> <span class="p">)</span>

<div class="viewcode-block" id="typedDict.itemLength"><a class="viewcode-back" href="../ParallelRegression.html#ParallelRegression.typedDict.itemLength">[docs]</a>    <span class="k">def</span> <span class="nf">itemLength</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">key</span> <span class="p">):</span>
        <span class="sd">&#39;&#39;&#39;Only checks the length of an entry if the entry already exists,</span>
<span class="sd">        otherwise returns 0.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        key : int or string</span>
<span class="sd">            A key for a dictionary entry that need not exist.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        int</span>
<span class="sd">            If there already exists a dictionary entry with the requested key,</span>
<span class="sd">            the length of the entry is returned.  If there is no dictionary</span>
<span class="sd">            entry already existing with the requested key, then 0 will be</span>
<span class="sd">            returned without creating an entry for the key.</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="k">if</span> <span class="n">key</span> <span class="ow">in</span> <span class="bp">self</span><span class="p">:</span>
            <span class="n">key</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_int_key</span><span class="p">(</span> <span class="n">key</span> <span class="p">)</span>
            <span class="k">return</span><span class="p">(</span> <span class="nb">len</span><span class="p">(</span> <span class="bp">self</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="p">)</span> <span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span><span class="p">(</span> <span class="mi">0</span> <span class="p">)</span></div>

    <span class="k">def</span> <span class="nf">__getstate__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">tR</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">typeRequirement</span>
        <span class="n">wO</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">writeOnce</span>
        <span class="n">strK</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">strKeys</span>
        <span class="n">_intA</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_intAvail</span>
        <span class="k">if</span> <span class="s1">&#39;default&#39;</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">__dir__</span><span class="p">(</span> <span class="p">):</span>
            <span class="n">d</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">default</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">d</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="n">dataDict</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">items</span><span class="p">(</span> <span class="p">):</span>
            <span class="n">dataDict</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">=</span> <span class="n">v</span>
        <span class="n">attrDict</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span> <span class="p">)</span>
        <span class="k">for</span> <span class="n">key</span><span class="p">,</span> <span class="n">value</span> <span class="ow">in</span> <span class="nb">vars</span><span class="p">(</span> <span class="bp">self</span> <span class="p">)</span><span class="o">.</span><span class="n">items</span><span class="p">(</span> <span class="p">):</span>
            <span class="k">if</span> <span class="n">key</span><span class="o">.</span><span class="n">startswith</span><span class="p">(</span> <span class="s1">&#39;_s_&#39;</span> <span class="p">):</span>
                <span class="n">attrDict</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="n">value</span>
        <span class="n">tple</span> <span class="o">=</span> <span class="p">(</span><span class="n">tR</span><span class="p">,</span> <span class="n">wO</span><span class="p">,</span> <span class="n">strK</span><span class="p">,</span> <span class="n">_intA</span><span class="p">,</span> <span class="n">d</span><span class="p">,</span> <span class="n">dataDict</span><span class="p">,</span> <span class="n">attrDict</span><span class="p">)</span>
        <span class="k">return</span><span class="p">(</span> <span class="n">tple</span> <span class="p">)</span>

    <span class="k">def</span> <span class="nf">__setstate__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">state</span> <span class="p">):</span>
        <span class="n">tR</span><span class="p">,</span> <span class="n">wO</span><span class="p">,</span> <span class="n">strK</span><span class="p">,</span> <span class="n">_intA</span><span class="p">,</span> <span class="n">d</span><span class="p">,</span> <span class="n">dataDict</span><span class="p">,</span> <span class="n">attrDict</span> <span class="o">=</span> <span class="n">state</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">typeRequirement</span> <span class="o">=</span> <span class="n">tR</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">writeOnce</span> <span class="o">=</span> <span class="n">wO</span>
        <span class="k">if</span> <span class="n">d</span> <span class="o">!=</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">default</span> <span class="o">=</span> <span class="n">d</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_intAvail</span> <span class="o">=</span> <span class="n">_intA</span>
        <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">dataDict</span><span class="o">.</span><span class="n">items</span><span class="p">(</span> <span class="p">):</span>
            <span class="bp">self</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">=</span> <span class="n">v</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">strKeys</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span> <span class="p">)</span>
        <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">strK</span><span class="o">.</span><span class="n">items</span><span class="p">(</span> <span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">strKeys</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">=</span> <span class="n">v</span>
        <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">attrDict</span><span class="o">.</span><span class="n">items</span><span class="p">(</span> <span class="p">):</span>
            <span class="k">if</span> <span class="n">k</span><span class="o">.</span><span class="n">startswith</span><span class="p">(</span> <span class="s1">&#39;_s_&#39;</span> <span class="p">):</span>
                <span class="nb">setattr</span><span class="p">(</span> <span class="bp">self</span><span class="p">,</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span> <span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">pickle</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="k">return</span><span class="p">(</span> <span class="p">)</span>

    <span class="k">def</span> <span class="nf">_int_key</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">key</span> <span class="p">):</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span> <span class="n">key</span><span class="p">,</span> <span class="nb">int</span> <span class="p">):</span>
            <span class="k">return</span><span class="p">(</span> <span class="n">key</span> <span class="p">)</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span> <span class="n">key</span><span class="p">,</span> <span class="nb">str</span> <span class="p">):</span>
            <span class="k">if</span> <span class="n">key</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">strKeys</span><span class="p">:</span>
                <span class="k">return</span><span class="p">(</span> <span class="bp">self</span><span class="o">.</span><span class="n">strKeys</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">KeyError</span><span class="p">(</span> <span class="s1">&#39;typedDict( ) only supports string keys and their &#39;</span>
                            <span class="s1">&#39;integer indexes.&#39;</span> <span class="p">)</span>

<div class="viewcode-block" id="typedDict.keys"><a class="viewcode-back" href="../ParallelRegression.html#ParallelRegression.typedDict.keys">[docs]</a>    <span class="k">def</span> <span class="nf">keys</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">key_type</span><span class="o">=</span><span class="kc">None</span> <span class="p">):</span>
        <span class="sd">&#39;&#39;&#39;Returns a setList( ) of keys for which there currently exists an</span>
<span class="sd">        entry.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        key_type : {None, &#39;integer&#39;, &#39;string&#39;, &#39;union&#39;}, optional</span>
<span class="sd">            The type of keys to return.  If `key_type==None` and at least one</span>
<span class="sd">            entry has a string key, then only string keys will be returned.</span>
<span class="sd">            Otherwise if `key_type==None`, integer keys will be returned.  If</span>
<span class="sd">            `key_type==&#39;union&#39;`, then a setList( ) consisting of both integer</span>
<span class="sd">            and string keys will be returned.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        setList( )</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="k">if</span> <span class="n">key_type</span> <span class="o">==</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span> <span class="bp">self</span><span class="o">.</span><span class="n">strKeys</span><span class="o">.</span><span class="n">keys</span><span class="p">(</span> <span class="p">)</span> <span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">key_type</span> <span class="o">=</span> <span class="s1">&#39;integer&#39;</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">key_type</span> <span class="o">=</span> <span class="s1">&#39;string&#39;</span>
        <span class="k">if</span> <span class="n">key_type</span> <span class="o">==</span> <span class="s1">&#39;string&#39;</span><span class="p">:</span>
            <span class="k">return</span><span class="p">(</span> <span class="n">setList</span><span class="p">(</span> <span class="bp">self</span><span class="o">.</span><span class="n">strKeys</span><span class="o">.</span><span class="n">keys</span><span class="p">(</span> <span class="p">)</span> <span class="p">)</span> <span class="p">)</span>
        <span class="k">elif</span> <span class="n">key_type</span> <span class="o">==</span> <span class="s1">&#39;integer&#39;</span><span class="p">:</span>
            <span class="k">return</span><span class="p">(</span> <span class="n">setList</span><span class="p">(</span> <span class="nb">dict</span><span class="o">.</span><span class="n">keys</span><span class="p">(</span> <span class="bp">self</span> <span class="p">)</span> <span class="p">)</span> <span class="p">)</span>
        <span class="k">elif</span> <span class="n">key_type</span> <span class="o">==</span> <span class="s1">&#39;union&#39;</span><span class="p">:</span>
            <span class="k">return</span><span class="p">(</span> <span class="n">setList</span><span class="p">(</span> <span class="bp">self</span><span class="o">.</span><span class="n">strKeys</span><span class="o">.</span><span class="n">keys</span><span class="p">(</span> <span class="p">)</span>
                            <span class="p">)</span><span class="o">.</span><span class="n">union</span><span class="p">(</span> <span class="nb">dict</span><span class="o">.</span><span class="n">keys</span><span class="p">(</span> <span class="bp">self</span> <span class="p">)</span> <span class="p">)</span> <span class="p">)</span></div>

<div class="viewcode-block" id="typedDict.pop"><a class="viewcode-back" href="../ParallelRegression.html#ParallelRegression.typedDict.pop">[docs]</a>    <span class="k">def</span> <span class="nf">pop</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">key</span> <span class="p">):</span>
        <span class="sd">&#39;&#39;&#39;Returns and removes the entry associated with the specified key.</span>
<span class="sd">        Accepts both integer and string keys.</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="n">ik</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_int_key</span><span class="p">(</span> <span class="n">key</span> <span class="p">)</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span> <span class="n">key</span><span class="p">,</span> <span class="nb">str</span> <span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">strKeys</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span> <span class="n">key</span> <span class="p">)</span>
        <span class="k">return</span><span class="p">(</span> <span class="nb">dict</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span> <span class="bp">self</span><span class="p">,</span> <span class="n">ik</span> <span class="p">)</span> <span class="p">)</span></div>

<div class="viewcode-block" id="typedDict.update"><a class="viewcode-back" href="../ParallelRegression.html#ParallelRegression.typedDict.update">[docs]</a>    <span class="k">def</span> <span class="nf">update</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span> <span class="p">):</span>
        <span class="sd">&#39;&#39;&#39;Copies entries in `other` into this typedDict( ), replacing existing</span>
<span class="sd">        entries that use the same key.</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="k">for</span> <span class="n">key</span> <span class="ow">in</span> <span class="n">other</span><span class="o">.</span><span class="n">keys</span><span class="p">(</span> <span class="p">):</span>
            <span class="n">n</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">__setitem__</span><span class="p">(</span> <span class="n">key</span><span class="p">,</span> <span class="n">other</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="p">)</span></div>

<div class="viewcode-block" id="typedDict.union_update"><a class="viewcode-back" href="../ParallelRegression.html#ParallelRegression.typedDict.union_update">[docs]</a>    <span class="k">def</span> <span class="nf">union_update</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span> <span class="p">):</span>
        <span class="sd">&#39;&#39;&#39;Similar to dict( ).update( other ) except that for keys with which</span>
<span class="sd">        an entry is associated in both this typedDict( ) and `other`, the new</span>
<span class="sd">        entry will be this typedDict[key].union( other[key] ).</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="n">sk</span> <span class="o">=</span> <span class="n">setList</span><span class="p">(</span> <span class="bp">self</span><span class="o">.</span><span class="n">strKeys</span><span class="o">.</span><span class="n">keys</span><span class="p">(</span> <span class="p">)</span> <span class="p">)</span>
        <span class="n">ok</span> <span class="o">=</span> <span class="n">setList</span><span class="p">(</span> <span class="n">other</span><span class="o">.</span><span class="n">keys</span><span class="p">(</span> <span class="p">)</span> <span class="p">)</span>
        <span class="k">for</span> <span class="n">key</span> <span class="ow">in</span> <span class="n">sk</span><span class="o">.</span><span class="n">union</span><span class="p">(</span> <span class="n">ok</span> <span class="p">):</span>
            <span class="bp">self</span><span class="p">[</span><span class="n">key</span><span class="p">]</span><span class="o">.</span><span class="n">update</span><span class="p">(</span> <span class="n">other</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="p">)</span>
        <span class="k">for</span> <span class="n">key</span> <span class="ow">in</span> <span class="n">ok</span><span class="o">.</span><span class="n">difference</span><span class="p">(</span> <span class="n">sk</span> <span class="p">):</span>
            <span class="bp">self</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="n">deepcopy</span><span class="p">(</span> <span class="n">other</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="p">)</span></div></div>

<div class="viewcode-block" id="categorizedSetDict"><a class="viewcode-back" href="../ParallelRegression.html#ParallelRegression.categorizedSetDict">[docs]</a><span class="k">class</span> <span class="nc">categorizedSetDict</span><span class="p">(</span><span class="n">typedDict</span><span class="p">):</span>
    <span class="sd">&#39;&#39;&#39;Ordered sets stored in a dict( ) in which each set and each set member</span>
<span class="sd">    potentially belongs to one or more category.</span>

<span class="sd">    Sets and set members can be retrieved by category.  Categories designated</span>
<span class="sd">    as mutually exclusive restrict category membership to sets and set members</span>
<span class="sd">    without conflicting categories.</span>

<span class="sd">    Attributes</span>
<span class="sd">    ----------</span>
<span class="sd">    mutually_exclusive : set</span>
<span class="sd">        set( ) of frozenset( )s of categories, where each category in a</span>
<span class="sd">        frozenset( ) and all other categories in the same frozenset( ) are are</span>
<span class="sd">        considered mutually exclusive.</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    Categories are assumed to be identified by strings, so the code is only</span>
<span class="sd">    tested using string-identified categories.  However, this is not strictly</span>
<span class="sd">    enforced.</span>
<span class="sd">    &#39;&#39;&#39;</span>
    <span class="k">def</span> <span class="nf">__new__</span><span class="p">(</span> <span class="n">cls</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span> <span class="p">):</span>
        <span class="n">obj</span> <span class="o">=</span> <span class="nb">super</span><span class="p">(</span> <span class="n">categorizedSetDict</span><span class="p">,</span> <span class="n">cls</span> <span class="p">)</span><span class="o">.</span><span class="n">__new__</span><span class="p">(</span> <span class="n">cls</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span> <span class="p">)</span>
        <span class="n">obj</span><span class="o">.</span><span class="n">_s_ctg_keys</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span> <span class="p">)</span>
        <span class="n">obj</span><span class="o">.</span><span class="n">_s_ctg_values</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span> <span class="p">)</span>
        <span class="n">obj</span><span class="o">.</span><span class="n">mutually_exclusive</span> <span class="o">=</span> <span class="n">setList</span><span class="p">(</span> <span class="p">)</span>
        <span class="n">typedDict</span><span class="o">.</span><span class="n">__init__</span><span class="p">(</span> <span class="n">obj</span><span class="p">,</span> <span class="n">setList</span> <span class="p">)</span>
        <span class="k">return</span><span class="p">(</span> <span class="n">obj</span> <span class="p">)</span>

<div class="viewcode-block" id="categorizedSetDict.__init__"><a class="viewcode-back" href="../ParallelRegression.html#ParallelRegression.categorizedSetDict.__init__">[docs]</a>    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">singular_category</span><span class="o">=</span><span class="kc">None</span> <span class="p">):</span>
        <span class="sd">&#39;&#39;&#39;Creates a categorizedSetDict( ) instance.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        singular_category : string, optional</span>
<span class="sd">            When a set is instantiated with a single item (as opposed to a</span>
<span class="sd">            sequence of one member), this category is assigned to the set.</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">singular_category</span> <span class="o">=</span> <span class="n">singular_category</span></div>

<div class="viewcode-block" id="categorizedSetDict.__setitem__"><a class="viewcode-back" href="../ParallelRegression.html#ParallelRegression.categorizedSetDict.__setitem__">[docs]</a>    <span class="k">def</span> <span class="nf">__setitem__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">key</span><span class="p">,</span> <span class="n">value</span> <span class="p">):</span>
        <span class="sd">&#39;&#39;&#39;Sets dict( ) entries.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        key : str</span>
<span class="sd">            String identifying a set.</span>
<span class="sd">        value : str or tuple (list-like : set members[, list-like : set member</span>
<span class="sd">        categories][, set : whole-set categories )</span>
<span class="sd">            list( ), set( ), or setList( ) of set members associated with the</span>
<span class="sd">            key, alone or combined with categories that apply to individual set</span>
<span class="sd">            members and/or categories that apply to the whole set.</span>

<span class="sd">        Raises</span>
<span class="sd">        ------</span>
<span class="sd">        CategoryError</span>
<span class="sd">            If an attempt is made to associate a set or set member with a</span>
<span class="sd">            category that is already associated with a mutually-exclusive</span>
<span class="sd">            category.  In this scenario, the entire .__setitem__( ) operation</span>
<span class="sd">            will fail and the categorizedSetDict( ) will not be altered.</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        &gt;&gt;&gt; c = categorizedSetDict( )</span>
<span class="sd">        &gt;&gt;&gt; c[&#39;vocab&#39;] = [&#39;apple&#39;, &#39;bee&#39;, &#39;cabin&#39;]</span>
<span class="sd">        &gt;&gt;&gt; c[&#39;vocab&#39;]</span>
<span class="sd">        [&#39;apple&#39;, &#39;bee&#39;, &#39;cabin&#39;]</span>
<span class="sd">        &gt;&gt;&gt; c.get_categories( key=&#39;vocab&#39;, value=&#39;apple&#39; )</span>
<span class="sd">        {None}</span>

<span class="sd">        &gt;&gt;&gt; c[&#39;vocab&#39;] = ([&#39;apple&#39;, &#39;bee&#39;, &#39;cabin&#39;],</span>
<span class="sd">        &gt;&gt;&gt;               {&#39;words&#39;})</span>
<span class="sd">        &gt;&gt;&gt; c.get_categories( key=&#39;vocab&#39;, value=&#39;apple&#39; )</span>
<span class="sd">        {&#39;words&#39;}</span>

<span class="sd">        &gt;&gt;&gt; c[&#39;vocab&#39;] = ([&#39;apple&#39;, &#39;bee&#39;, &#39;cabin&#39;],</span>
<span class="sd">        &gt;&gt;&gt;               [{&#39;food&#39;}, {&#39;animal&#39;}, {&#39;building&#39;}])</span>
<span class="sd">        &gt;&gt;&gt; c.get_categories( key=&#39;vocab&#39;, value=&#39;apple&#39; )</span>
<span class="sd">        {&#39;food&#39;}</span>

<span class="sd">        &gt;&gt;&gt; c[&#39;vocab&#39;] = ([&#39;apple&#39;, &#39;bee&#39;, &#39;cabin&#39;],</span>
<span class="sd">        &gt;&gt;&gt;               [{&#39;food&#39;}, {&#39;animal&#39;}, {&#39;building&#39;}],</span>
<span class="sd">        &gt;&gt;&gt;               {&#39;words&#39;})</span>
<span class="sd">        &gt;&gt;&gt; c.get_categories( key=&#39;vocab&#39;, value=&#39;apple&#39; )</span>
<span class="sd">        {&#39;food&#39;, &#39;words&#39;}</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="c1">## Convert entries without category information and 2-tuples with</span>
        <span class="c1">## either whole-key categories or single-value categories into</span>
        <span class="c1">## 3-tuples.</span>
        <span class="k">if</span> <span class="n">value</span> <span class="o">==</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">key</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">keys</span><span class="p">(</span> <span class="p">):</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">__delitem__</span><span class="p">(</span> <span class="n">key</span> <span class="p">)</span>
            <span class="k">return</span><span class="p">(</span> <span class="p">)</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span> <span class="n">value</span><span class="p">,</span> <span class="p">(</span><span class="nb">list</span><span class="p">,</span> <span class="nb">set</span><span class="p">)</span> <span class="p">):</span>
            <span class="n">value</span> <span class="o">=</span> <span class="n">setList</span><span class="p">(</span> <span class="n">value</span> <span class="p">)</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span> <span class="n">value</span><span class="p">,</span> <span class="nb">str</span> <span class="p">):</span>
            <span class="n">value</span> <span class="o">=</span> <span class="p">(</span><span class="n">setList</span><span class="p">(</span> <span class="p">[</span><span class="n">value</span><span class="p">]</span> <span class="p">),</span> <span class="p">[],</span> <span class="p">{</span><span class="bp">self</span><span class="o">.</span><span class="n">singular_category</span><span class="p">})</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span> <span class="n">value</span><span class="p">,</span> <span class="n">setList</span> <span class="p">):</span>
            <span class="n">value</span> <span class="o">=</span> <span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="p">[],</span> <span class="p">{</span><span class="kc">None</span><span class="p">,})</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span> <span class="n">value</span><span class="p">,</span> <span class="p">(</span><span class="nb">tuple</span><span class="p">,</span> <span class="nb">list</span><span class="p">)</span> <span class="p">)</span> <span class="ow">and</span> <span class="nb">len</span><span class="p">(</span> <span class="n">value</span> <span class="p">)</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span> <span class="n">value</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">setList</span> <span class="p">):</span>
                <span class="n">value</span> <span class="o">=</span> <span class="p">(</span><span class="n">setList</span><span class="p">(</span> <span class="n">value</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="p">),</span> <span class="n">value</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span> <span class="n">value</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="nb">list</span> <span class="p">):</span>
                <span class="n">value</span> <span class="o">=</span> <span class="p">(</span><span class="n">value</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">value</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="nb">set</span><span class="p">(</span> <span class="p">))</span>
            <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span> <span class="n">value</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="nb">set</span> <span class="p">):</span>
                <span class="n">value</span> <span class="o">=</span> <span class="p">(</span><span class="n">value</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="p">[],</span> <span class="n">value</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
        <span class="c1">## Take 3-tuples, perform some validation, and then store the data.</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span> <span class="n">value</span><span class="p">,</span> <span class="nb">tuple</span> <span class="p">)</span> <span class="ow">and</span> <span class="nb">len</span><span class="p">(</span> <span class="n">value</span> <span class="p">)</span> <span class="o">==</span> <span class="mi">3</span><span class="p">:</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span> <span class="n">value</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="nb">list</span> <span class="p">):</span>
                <span class="n">value</span> <span class="o">=</span> <span class="p">(</span><span class="n">setList</span><span class="p">(</span> <span class="n">value</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="p">),</span> <span class="n">value</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">value</span><span class="p">[</span><span class="mi">2</span><span class="p">])</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span> <span class="n">value</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">setList</span> <span class="p">)</span> <span class="ow">and</span> \
               <span class="nb">isinstance</span><span class="p">(</span> <span class="n">value</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="nb">list</span> <span class="p">)</span> <span class="ow">and</span> \
               <span class="nb">isinstance</span><span class="p">(</span> <span class="n">value</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span> <span class="nb">set</span> <span class="p">):</span>
                <span class="c1">## Validate:</span>
                <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span> <span class="n">value</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="nb">list</span> <span class="p">)</span> <span class="ow">and</span> \
                   <span class="nb">len</span><span class="p">(</span> <span class="n">value</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="p">)</span> <span class="o">&gt;</span> <span class="nb">len</span><span class="p">(</span> <span class="n">value</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="p">):</span>
                    <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span> <span class="s1">&#39;Categories list has a length of </span><span class="si">%d</span><span class="s1">.  &#39;</span>
                          <span class="s1">&#39;It cannot be longer than the items list, which has &#39;</span>
                          <span class="s1">&#39;a length of </span><span class="si">%d</span><span class="s1">.&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="nb">len</span><span class="p">(</span> <span class="n">values</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="p">),</span>
                                               <span class="nb">len</span><span class="p">(</span> <span class="n">values</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="p">))</span> <span class="p">)</span>
                <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span> <span class="nb">len</span><span class="p">(</span> <span class="n">value</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="p">)</span> <span class="p">):</span>
                    <span class="k">if</span> <span class="n">value</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="n">i</span><span class="p">]</span> <span class="o">==</span> <span class="kc">None</span><span class="p">:</span>
                        <span class="n">value</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span> <span class="p">)</span>
                    <span class="k">elif</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span> <span class="n">value</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="n">i</span><span class="p">],</span> <span class="p">(</span><span class="nb">set</span><span class="p">,</span> <span class="n">setList</span><span class="p">)</span> <span class="p">):</span>
                        <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span> <span class="s1">&#39;Items in the value category sequence&#39;</span>
                              <span class="s1">&#39; must be sets, not </span><span class="si">%s</span><span class="s1">.&#39;</span> <span class="o">%</span> <span class="nb">type</span><span class="p">(</span> <span class="n">value</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="n">i</span><span class="p">]</span> <span class="p">)</span> <span class="p">)</span>
                <span class="c1">## Make backup of current values for key</span>
                <span class="n">B_itm</span> <span class="o">=</span> <span class="n">deepcopy</span><span class="p">(</span> <span class="bp">self</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="p">)</span>
                <span class="k">if</span> <span class="n">key</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_s_ctg_keys</span><span class="p">:</span>
                    <span class="n">B_key</span> <span class="o">=</span> <span class="n">deepcopy</span><span class="p">(</span> <span class="bp">self</span><span class="o">.</span><span class="n">_s_ctg_keys</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">B_key</span> <span class="o">=</span> <span class="kc">None</span>
                <span class="k">if</span> <span class="n">key</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_s_ctg_values</span><span class="p">:</span>
                    <span class="n">B_val</span> <span class="o">=</span> <span class="n">deepcopy</span><span class="p">(</span> <span class="bp">self</span><span class="o">.</span><span class="n">_s_ctg_values</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">B_val</span> <span class="o">=</span> <span class="kc">None</span>
                <span class="k">try</span><span class="p">:</span>
                    <span class="c1">## Attempt to store new data</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">__missing__</span><span class="p">(</span> <span class="n">key</span> <span class="p">)</span>
                    <span class="n">typedDict</span><span class="o">.</span><span class="n">__setitem__</span><span class="p">(</span> <span class="bp">self</span><span class="p">,</span> <span class="n">key</span><span class="p">,</span> <span class="n">value</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="p">)</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">set_categories</span><span class="p">(</span> <span class="o">*</span><span class="n">value</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span> <span class="n">key</span><span class="o">=</span><span class="n">key</span> <span class="p">)</span>
                    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span> <span class="nb">len</span><span class="p">(</span> <span class="n">value</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="p">)</span> <span class="p">):</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">set_categories</span><span class="p">(</span> <span class="o">*</span><span class="n">value</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="n">i</span><span class="p">],</span>
                                             <span class="n">key</span><span class="o">=</span><span class="n">key</span><span class="p">,</span>
                                             <span class="n">value</span><span class="o">=</span><span class="n">value</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="n">i</span><span class="p">]</span> <span class="p">)</span>
                <span class="k">except</span> <span class="n">CategoryError</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
                    <span class="c1">## Use backups to restore prior value if attempt was</span>
                    <span class="c1">## unsuccesful.</span>
                    <span class="n">typedDict</span><span class="o">.</span><span class="n">__setitem__</span><span class="p">(</span> <span class="bp">self</span><span class="p">,</span> <span class="n">key</span><span class="p">,</span> <span class="n">B_itm</span> <span class="p">)</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">_s_ctg_keys</span><span class="p">[</span><span class="n">key</span><span class="p">]</span>   <span class="o">=</span> <span class="n">B_key</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">_s_ctg_values</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="n">B_val</span>
                    <span class="k">raise</span> <span class="n">e</span>
                <span class="k">return</span><span class="p">(</span> <span class="p">)</span>
        <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span> <span class="s1">&#39;Value is not a supported type.  &#39;</span>
                         <span class="s1">&#39;Type: </span><span class="si">%s</span><span class="s1">, length: </span><span class="si">%d</span><span class="s1">.&#39;</span>
                         <span class="o">%</span> <span class="p">(</span><span class="nb">type</span><span class="p">(</span> <span class="n">value</span> <span class="p">),</span> <span class="nb">getattr</span><span class="p">(</span> <span class="n">value</span><span class="p">,</span> <span class="s1">&#39;__len__&#39;</span><span class="p">,</span> <span class="mi">0</span> <span class="p">))</span> <span class="p">)</span></div>

<div class="viewcode-block" id="categorizedSetDict.get_categories"><a class="viewcode-back" href="../ParallelRegression.html#ParallelRegression.categorizedSetDict.get_categories">[docs]</a>    <span class="k">def</span> <span class="nf">get_categories</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">key</span><span class="p">,</span> <span class="n">value</span><span class="o">=</span><span class="kc">None</span> <span class="p">):</span>
        <span class="sd">&#39;&#39;&#39;Returns the set of categories associated with the whole set or a</span>
<span class="sd">        particular member thereof.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        key : str</span>
<span class="sd">            The key associated with the set about which the inquiry is being</span>
<span class="sd">            made.</span>
<span class="sd">        value, optional</span>
<span class="sd">            If specified, the categories specifically associated with the</span>
<span class="sd">            specified set member are returned along with the categories</span>
<span class="sd">            associated with the whole set.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        categories : set</span>
<span class="sd">            The set of all categories associated with the specified key or with</span>
<span class="sd">            the specified key/value pair.  If there is a set identified by the</span>
<span class="sd">            key `key`, then the set of categories associated with it will be</span>
<span class="sd">            returned regardless of whether or not `value` is in the set `key`.</span>
<span class="sd">        None</span>
<span class="sd">            If there is no entry with `key`&#39;s value as its key.</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="k">if</span> <span class="n">key</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="p">:</span>
            <span class="k">return</span><span class="p">(</span> <span class="kc">None</span> <span class="p">)</span>
        <span class="k">if</span> <span class="n">value</span> <span class="o">==</span> <span class="kc">None</span> <span class="ow">or</span> <span class="n">value</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="ow">or</span> \
           <span class="bp">self</span><span class="p">[</span><span class="n">key</span><span class="p">]</span><span class="o">.</span><span class="n">index</span><span class="p">(</span> <span class="n">value</span> <span class="p">)</span> <span class="o">&gt;=</span> <span class="nb">len</span><span class="p">(</span> <span class="bp">self</span><span class="o">.</span><span class="n">_s_ctg_values</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="p">):</span>
            <span class="k">return</span><span class="p">(</span> <span class="bp">self</span><span class="o">.</span><span class="n">_s_ctg_keys</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span><span class="p">(</span> <span class="bp">self</span><span class="o">.</span><span class="n">_s_ctg_keys</span><span class="p">[</span><span class="n">key</span><span class="p">]</span><span class="o">.</span><span class="n">union</span><span class="p">(</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_s_ctg_values</span><span class="p">[</span><span class="n">key</span><span class="p">][</span><span class="bp">self</span><span class="p">[</span><span class="n">key</span><span class="p">]</span><span class="o">.</span><span class="n">index</span><span class="p">(</span> <span class="n">value</span> <span class="p">)]</span> <span class="p">)</span> <span class="p">)</span></div>

<div class="viewcode-block" id="categorizedSetDict.is_a"><a class="viewcode-back" href="../ParallelRegression.html#ParallelRegression.categorizedSetDict.is_a">[docs]</a>    <span class="k">def</span> <span class="nf">is_a</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">category</span><span class="p">,</span> <span class="n">key</span><span class="p">,</span> <span class="n">value</span><span class="o">=</span><span class="kc">None</span> <span class="p">):</span>
        <span class="sd">&#39;&#39;&#39;Returns True if the specified key or key/value pair is associated</span>
<span class="sd">        with `category`, or False otherwise, so long as there is an entry with</span>
<span class="sd">        `key`&#39;s value as its key.  If not, None is returned.  The set</span>
<span class="sd">        identified by `key` need not contain `value`.</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="n">categories</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_categories</span><span class="p">(</span> <span class="n">key</span><span class="p">,</span> <span class="n">value</span> <span class="p">)</span>
        <span class="k">if</span> <span class="n">categories</span> <span class="o">==</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">return</span><span class="p">(</span> <span class="kc">None</span> <span class="p">)</span>
        <span class="k">return</span><span class="p">(</span> <span class="n">category</span> <span class="ow">in</span> <span class="n">categories</span> <span class="p">)</span></div>

<div class="viewcode-block" id="categorizedSetDict.is_None"><a class="viewcode-back" href="../ParallelRegression.html#ParallelRegression.categorizedSetDict.is_None">[docs]</a>    <span class="k">def</span> <span class="nf">is_None</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">key</span><span class="p">,</span> <span class="n">value</span><span class="o">=</span><span class="kc">None</span> <span class="p">):</span>
        <span class="sd">&#39;&#39;&#39;Returns True if the specified key or key/value pair is not</span>
<span class="sd">        associated with any category, or False otherwise.  See .is_a( ) for</span>
<span class="sd">        handling of non-existant values.</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="n">categories</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_categories</span><span class="p">(</span> <span class="n">key</span><span class="o">=</span><span class="n">key</span><span class="p">,</span> <span class="n">value</span><span class="o">=</span><span class="n">value</span> <span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">categories</span> <span class="o">==</span> <span class="nb">set</span><span class="p">(</span> <span class="p">)</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">categories</span> <span class="o">==</span> <span class="nb">set</span><span class="p">(</span> <span class="p">[</span><span class="kc">None</span><span class="p">]</span> <span class="p">):</span>
            <span class="k">return</span><span class="p">(</span> <span class="kc">False</span> <span class="p">)</span>
        <span class="k">return</span><span class="p">(</span> <span class="kc">True</span> <span class="p">)</span></div>

<div class="viewcode-block" id="categorizedSetDict.set_category"><a class="viewcode-back" href="../ParallelRegression.html#ParallelRegression.categorizedSetDict.set_category">[docs]</a>    <span class="k">def</span> <span class="nf">set_category</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">category</span><span class="p">,</span> <span class="o">*</span><span class="p">,</span> <span class="n">key</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">value</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                                        <span class="n">keys</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                                        <span class="n">items</span><span class="o">=</span><span class="kc">None</span> <span class="p">):</span>
        <span class="sd">&#39;&#39;&#39;Associates key(s) and/or key/value pairs with the specified</span>
<span class="sd">        category.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        category : string</span>
<span class="sd">            The category to associate with the key(s) and/or key/value pairs.</span>
<span class="sd">        key : str, optional</span>
<span class="sd">            If key but not value is specified, then this key will be associated</span>
<span class="sd">            with the specified category.</span>
<span class="sd">        value, optional</span>
<span class="sd">            If key and value are both specified, then this key/value pair will</span>
<span class="sd">            be associated with the specified category.</span>
<span class="sd">        keys : Sequence</span>
<span class="sd">            The keys in this sequence will be associated with the specified</span>
<span class="sd">            category.</span>
<span class="sd">        items : dict</span>
<span class="sd">            The key/value pairs in this dict( ) will be associated with the</span>
<span class="sd">            specified category.  Each value in this dict( ) can be either a</span>
<span class="sd">            single set member or a sequence of set members to associate with</span>
<span class="sd">            the specified category.</span>

<span class="sd">        Raises</span>
<span class="sd">        ------</span>
<span class="sd">        CategoryError</span>
<span class="sd">            If the category specified and one or more categories already</span>
<span class="sd">            associated with one or more of the specified key(s) or key/value</span>
<span class="sd">            pairs are considered mutually exclusive.</span>
<span class="sd">        KeyError</span>
<span class="sd">            If a specified key/value pair does not identify an existing set</span>
<span class="sd">            member.  Note that assigning a category to a key for which there is</span>
<span class="sd">            no pre-existing entry results in the creation of a default entry</span>
<span class="sd">            instead of of a KeyError.</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="k">def</span> <span class="nf">set_key</span><span class="p">(</span> <span class="n">key</span><span class="p">,</span> <span class="n">category</span> <span class="p">):</span>
            <span class="c1">## Validates and sets a single category for a single key.</span>
            <span class="k">if</span> <span class="n">key</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">keys</span><span class="p">(</span> <span class="p">):</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">__missing__</span><span class="p">(</span> <span class="n">key</span> <span class="p">)</span>
            <span class="k">for</span> <span class="n">ctgset</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">mutually_exclusive</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">category</span> <span class="ow">in</span> <span class="n">ctgset</span><span class="p">:</span>
                    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span> <span class="n">ctgset</span><span class="o">.</span><span class="n">intersection</span><span class="p">(</span> <span class="bp">self</span><span class="o">.</span><span class="n">_s_ctg_keys</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="p">)</span>\
                                  <span class="o">.</span><span class="n">difference</span><span class="p">(</span> <span class="nb">set</span><span class="p">(</span> <span class="p">[</span><span class="n">category</span><span class="p">]</span> <span class="p">)</span> <span class="p">)</span> <span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                        <span class="k">raise</span> <span class="n">CategoryError</span><span class="p">(</span> <span class="s2">&quot;Cannot add category &#39;</span><span class="si">%s</span><span class="s2">&#39; to &quot;</span>
                              <span class="s2">&quot;[&#39;</span><span class="si">%s</span><span class="s2">&#39;] because it already has a mutually &quot;</span>
                              <span class="s2">&quot;exclusive category.&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="n">category</span><span class="p">,</span> <span class="n">key</span><span class="p">)</span> <span class="p">)</span>
                    <span class="k">for</span> <span class="n">val</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_s_ctg_values</span><span class="p">[</span><span class="n">key</span><span class="p">]:</span>
                        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span> <span class="n">ctgset</span><span class="o">.</span><span class="n">intersection</span><span class="p">(</span> <span class="n">val</span> <span class="p">)</span>\
                                      <span class="o">.</span><span class="n">difference</span><span class="p">(</span> <span class="nb">set</span><span class="p">(</span> <span class="p">[</span><span class="n">category</span><span class="p">]</span> <span class="p">)</span> <span class="p">)</span> <span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                            <span class="k">raise</span> <span class="n">CategoryError</span><span class="p">(</span> <span class="s2">&quot;Cannot add category &#39;</span><span class="si">%s</span><span class="s2">&#39; to &quot;</span>
                                  <span class="s2">&quot;[&#39;</span><span class="si">%s</span><span class="s2">&#39;] because one or more values already &quot;</span>
                                  <span class="s2">&quot;has a mutually exclusive category.&quot;</span>
                                  <span class="o">%</span> <span class="p">(</span><span class="n">category</span><span class="p">,</span> <span class="n">key</span><span class="p">),</span> <span class="n">ctgset</span> <span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_s_ctg_keys</span><span class="p">[</span><span class="n">key</span><span class="p">]</span><span class="o">.</span><span class="n">add</span><span class="p">(</span> <span class="n">category</span> <span class="p">)</span>
        <span class="k">def</span> <span class="nf">set_val</span><span class="p">(</span> <span class="n">key</span><span class="p">,</span> <span class="n">val</span><span class="p">,</span> <span class="n">category</span> <span class="p">):</span>
            <span class="c1">## Validates &amp; sets a single category for a single key/value pair.</span>
            <span class="k">if</span> <span class="n">val</span> <span class="ow">in</span> <span class="n">typedDict</span><span class="o">.</span><span class="n">__getitem__</span><span class="p">(</span> <span class="bp">self</span><span class="p">,</span> <span class="n">key</span> <span class="p">):</span>
                <span class="n">index</span> <span class="o">=</span> <span class="n">typedDict</span><span class="o">.</span><span class="n">__getitem__</span><span class="p">(</span> <span class="bp">self</span><span class="p">,</span> <span class="n">key</span> <span class="p">)</span><span class="o">.</span><span class="n">index</span><span class="p">(</span> <span class="n">val</span> <span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">KeyError</span><span class="p">(</span> <span class="s2">&quot;Set identified by key &#39;</span><span class="si">%s</span><span class="s2">&#39; has no value &#39;</span><span class="si">%s</span><span class="s2">&#39;.&quot;</span>
                      <span class="s2">&quot;  It has: </span><span class="si">%s</span><span class="s2">.&quot;</span>
                      <span class="o">%</span> <span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="n">val</span><span class="p">,</span> <span class="n">typedDict</span><span class="o">.</span><span class="n">__getitem__</span><span class="p">(</span> <span class="bp">self</span><span class="p">,</span> <span class="n">key</span> <span class="p">))</span> <span class="p">)</span>
            <span class="k">while</span> <span class="nb">len</span><span class="p">(</span> <span class="bp">self</span><span class="o">.</span><span class="n">_s_ctg_values</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="p">)</span> <span class="o">&lt;=</span> <span class="n">index</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_s_ctg_values</span><span class="p">[</span><span class="n">key</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span> <span class="nb">set</span><span class="p">(</span> <span class="p">)</span> <span class="p">)</span>
            <span class="k">for</span> <span class="n">ctgset</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">mutually_exclusive</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">category</span> <span class="ow">in</span> <span class="n">ctgset</span><span class="p">:</span>
                    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span> <span class="n">ctgset</span><span class="o">.</span><span class="n">intersection</span><span class="p">(</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_categories</span><span class="p">(</span> <span class="n">key</span><span class="o">=</span><span class="n">key</span><span class="p">,</span>
                                                                 <span class="n">value</span><span class="o">=</span><span class="n">val</span> <span class="p">)</span> <span class="p">)</span>\
                                  <span class="o">.</span><span class="n">difference</span><span class="p">(</span> <span class="nb">set</span><span class="p">(</span> <span class="p">[</span><span class="n">category</span><span class="p">]</span> <span class="p">)</span> <span class="p">)</span> <span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                        <span class="k">raise</span> <span class="n">CategoryError</span><span class="p">(</span> <span class="s2">&quot;Cannot add category &#39;</span><span class="si">%s</span><span class="s2">&#39; to &quot;</span>
                              <span class="s2">&quot;[&#39;</span><span class="si">%s</span><span class="s2">&#39;]&#39;</span><span class="si">%s</span><span class="s2">&#39; because it and an existing category &quot;</span>
                              <span class="s2">&quot;are mutually exclusive.&quot;</span>
                              <span class="o">%</span> <span class="p">(</span><span class="n">category</span><span class="p">,</span> <span class="n">key</span><span class="p">,</span> <span class="n">val</span><span class="p">),</span> <span class="n">ctgset</span> <span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_s_ctg_values</span><span class="p">[</span><span class="n">key</span><span class="p">][</span><span class="n">index</span><span class="p">]</span><span class="o">.</span><span class="n">add</span><span class="p">(</span> <span class="n">category</span> <span class="p">)</span>
        <span class="c1">#######################################################################</span>
        <span class="c1">## Body of method starts here:</span>
        <span class="k">if</span> <span class="n">key</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">value</span><span class="p">:</span>
                <span class="n">set_val</span><span class="p">(</span> <span class="n">key</span><span class="p">,</span> <span class="n">value</span><span class="p">,</span> <span class="n">category</span> <span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">set_key</span><span class="p">(</span> <span class="n">key</span><span class="p">,</span> <span class="n">category</span> <span class="p">)</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span> <span class="n">keys</span><span class="p">,</span> <span class="n">Sequence</span> <span class="p">)</span> <span class="ow">and</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span> <span class="n">keys</span><span class="p">,</span> <span class="nb">str</span> <span class="p">):</span>
            <span class="k">for</span> <span class="n">key</span> <span class="ow">in</span> <span class="n">keys</span><span class="p">:</span>
                <span class="n">set_key</span><span class="p">(</span> <span class="n">key</span><span class="p">,</span> <span class="n">category</span> <span class="p">)</span>
        <span class="k">elif</span> <span class="n">keys</span> <span class="o">!=</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">KeyError</span><span class="p">(</span> <span class="s1">&#39;`keys` must be a non-string Sequence.  Use the &#39;</span>
                            <span class="s1">&#39;singular `key` to set the category for one key.&#39;</span> <span class="p">)</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span> <span class="n">items</span><span class="p">,</span> <span class="nb">dict</span> <span class="p">):</span>
            <span class="k">for</span> <span class="n">key</span><span class="p">,</span> <span class="n">values</span> <span class="ow">in</span> <span class="n">items</span><span class="o">.</span><span class="n">items</span><span class="p">(</span> <span class="p">):</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span> <span class="n">values</span><span class="p">,</span> <span class="n">Sequence</span> <span class="p">)</span> <span class="ow">or</span> \
                   <span class="nb">isinstance</span><span class="p">(</span> <span class="n">values</span><span class="p">,</span> <span class="nb">str</span> <span class="p">):</span>
                    <span class="n">values</span> <span class="o">=</span> <span class="p">[</span><span class="n">values</span><span class="p">]</span>
                <span class="k">for</span> <span class="n">value</span> <span class="ow">in</span> <span class="n">values</span><span class="p">:</span>
                    <span class="n">set_val</span><span class="p">(</span> <span class="n">key</span><span class="p">,</span> <span class="n">value</span><span class="p">,</span> <span class="n">category</span> <span class="p">)</span>
        <span class="k">elif</span> <span class="n">items</span> <span class="o">!=</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">KeyError</span><span class="p">(</span> <span class="s1">&#39;`items` must be a dict( ).&#39;</span> <span class="p">)</span></div>

<div class="viewcode-block" id="categorizedSetDict.set_categories"><a class="viewcode-back" href="../ParallelRegression.html#ParallelRegression.categorizedSetDict.set_categories">[docs]</a>    <span class="k">def</span> <span class="nf">set_categories</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">categories</span><span class="p">,</span> <span class="n">key</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">value</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                                          <span class="n">keys</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                                          <span class="n">items</span><span class="o">=</span><span class="kc">None</span> <span class="p">):</span>
        <span class="sd">&#39;&#39;&#39;Associates key(s) and/or key/value pairs with each of the specified</span>
<span class="sd">        categories.</span>

<span class="sd">        .set_categories( ) makes a separate call to .set_category( ) for each</span>
<span class="sd">        category.  As such, calls to .set_categories( ) are not atomic.  For</span>
<span class="sd">        atomic behavior, use .__setitem__( ) instead of .set_categories( ).</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        positional arguments</span>
<span class="sd">            Categories to associate with the key(s) and/or key/value pairs.</span>
<span class="sd">        key : str, optional</span>
<span class="sd">            If key but not value is specified, then this key will be associated</span>
<span class="sd">            with the specified category.</span>
<span class="sd">        value, optional</span>
<span class="sd">            If key and value are both specified, then this key/value pair will</span>
<span class="sd">            be associated with the specified category.</span>
<span class="sd">        keys : Sequence</span>
<span class="sd">            The keys in this sequence will be associated with the specified</span>
<span class="sd">            category.</span>
<span class="sd">        items : dict</span>
<span class="sd">            The key/value pairs in this dict( ) will be associated with the</span>
<span class="sd">            specified category.  Each value in this dict( ) can be either a</span>
<span class="sd">            single set member or a sequence of set members to associate with</span>
<span class="sd">            the specified category.</span>

<span class="sd">        Raises</span>
<span class="sd">        ------</span>
<span class="sd">        CategoryError</span>
<span class="sd">            If the category specified and one or more categories already</span>
<span class="sd">            associated with one or more of the specified key(s) or key/value</span>
<span class="sd">            pairs are considered mutually exclusive.</span>
<span class="sd">        KeyError</span>
<span class="sd">            If a specified key/value pair does not identify an existing set</span>
<span class="sd">            member.  Note that assigning a category to a key for which there is</span>
<span class="sd">            no pre-existing entry results in the creation of a default entry</span>
<span class="sd">            instead of of a KeyError.</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="n">categories</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">set_category</span><span class="p">(</span> <span class="n">c</span><span class="p">,</span> <span class="n">key</span><span class="o">=</span><span class="n">key</span><span class="p">,</span> <span class="n">value</span><span class="o">=</span><span class="n">value</span><span class="p">,</span>
                                  <span class="n">keys</span><span class="o">=</span><span class="n">keys</span><span class="p">,</span>
                                  <span class="n">items</span><span class="o">=</span><span class="n">items</span> <span class="p">)</span></div>

<div class="viewcode-block" id="categorizedSetDict.del_category"><a class="viewcode-back" href="../ParallelRegression.html#ParallelRegression.categorizedSetDict.del_category">[docs]</a>    <span class="k">def</span> <span class="nf">del_category</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">category</span><span class="p">,</span> <span class="o">*</span><span class="p">,</span> <span class="n">key</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">value</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                                        <span class="n">keys</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                                        <span class="n">items</span><span class="o">=</span><span class="kc">None</span> <span class="p">):</span>
        <span class="sd">&#39;&#39;&#39;Disassociates the specified category from the specified key(s) and/</span>
<span class="sd">        or key/value pairs.  See .set_category( ) documentation for usage.</span>

<span class="sd">        If there is no existing association between `category` and a specified</span>
<span class="sd">        key and/or key/value pair, no Exception is raised.</span>

<span class="sd">        Raises</span>
<span class="sd">        ------</span>
<span class="sd">        CategoryError</span>
<span class="sd">            If an attempt is made to disassociate an individual set member with</span>
<span class="sd">            a category that is associated with the whole set.</span>
<span class="sd">        KeyError</span>
<span class="sd">            If a specified key/value pair does not identify an existing set</span>
<span class="sd">            member.</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="k">def</span> <span class="nf">del_key</span><span class="p">(</span> <span class="n">key</span><span class="p">,</span> <span class="n">category</span> <span class="p">):</span>
            <span class="c1">## Disassociates a single key from a single category.</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_s_ctg_keys</span><span class="p">[</span><span class="n">key</span><span class="p">]</span><span class="o">.</span><span class="n">discard</span><span class="p">(</span> <span class="n">category</span> <span class="p">)</span>
        <span class="k">def</span> <span class="nf">del_val</span><span class="p">(</span> <span class="n">key</span><span class="p">,</span> <span class="n">val</span><span class="p">,</span> <span class="n">category</span> <span class="p">):</span>
            <span class="c1">## Disassociates a single key/value pair from a single category.</span>
            <span class="k">if</span> <span class="n">val</span> <span class="ow">in</span> <span class="n">typedDict</span><span class="o">.</span><span class="n">__getitem__</span><span class="p">(</span> <span class="bp">self</span><span class="p">,</span> <span class="n">key</span> <span class="p">):</span>
                <span class="n">index</span> <span class="o">=</span> <span class="n">typedDict</span><span class="o">.</span><span class="n">__getitem__</span><span class="p">(</span> <span class="bp">self</span><span class="p">,</span> <span class="n">key</span> <span class="p">)</span><span class="o">.</span><span class="n">index</span><span class="p">(</span> <span class="n">val</span> <span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">KeyError</span><span class="p">(</span> <span class="s2">&quot;Set identified by key &#39;</span><span class="si">%s</span><span class="s2">&#39; has no value &#39;</span><span class="si">%s</span><span class="s2">&#39;.&quot;</span>
                                <span class="s2">&quot;  It has: </span><span class="si">%s</span><span class="s2">.&quot;</span>
                                <span class="o">%</span> <span class="p">(</span><span class="n">key</span><span class="p">,</span>
                                   <span class="n">val</span><span class="p">,</span>
                                   <span class="n">typedDict</span><span class="o">.</span><span class="n">__getitem__</span><span class="p">(</span> <span class="bp">self</span><span class="p">,</span> <span class="n">key</span> <span class="p">))</span> <span class="p">)</span>
            <span class="k">while</span> <span class="nb">len</span><span class="p">(</span> <span class="bp">self</span><span class="o">.</span><span class="n">_s_ctg_values</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="p">)</span> <span class="o">&lt;=</span> <span class="n">index</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_s_ctg_values</span><span class="p">[</span><span class="n">key</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span> <span class="nb">set</span><span class="p">(</span> <span class="p">)</span> <span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_s_ctg_values</span><span class="p">[</span><span class="n">key</span><span class="p">][</span><span class="n">index</span><span class="p">]</span><span class="o">.</span><span class="n">discard</span><span class="p">(</span> <span class="n">category</span> <span class="p">)</span>
        <span class="c1">#######################################################################</span>
        <span class="c1">## Body of method starts here:</span>
        <span class="k">if</span> <span class="n">key</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">value</span><span class="p">:</span>
                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_a</span><span class="p">(</span> <span class="n">category</span><span class="p">,</span> <span class="n">key</span><span class="o">=</span><span class="n">key</span> <span class="p">):</span>
                    <span class="k">raise</span> <span class="n">CategoryError</span><span class="p">(</span> <span class="s2">&quot;Attempted disassociation of [&#39;</span><span class="si">%s</span><span class="s2">&#39;]</span><span class="si">%s</span><span class="s2">&quot;</span>
                          <span class="s2">&quot; and category &#39;</span><span class="si">%s</span><span class="s2">&#39; when said category is associated&quot;</span>
                          <span class="s2">&quot; with the whole set [&#39;</span><span class="si">%s</span><span class="s2">&#39;].&quot;</span>
                          <span class="o">%</span> <span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="n">value</span><span class="p">,</span> <span class="n">category</span><span class="p">,</span> <span class="n">key</span><span class="p">)</span> <span class="p">)</span>
                <span class="n">del_val</span><span class="p">(</span> <span class="n">key</span><span class="p">,</span> <span class="n">value</span><span class="p">,</span> <span class="n">category</span> <span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">del_key</span><span class="p">(</span> <span class="n">key</span><span class="p">,</span> <span class="n">category</span> <span class="p">)</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span> <span class="n">keys</span><span class="p">,</span> <span class="n">Sequence</span> <span class="p">)</span> <span class="ow">and</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span> <span class="n">keys</span><span class="p">,</span> <span class="nb">str</span> <span class="p">):</span>
            <span class="k">for</span> <span class="n">key</span> <span class="ow">in</span> <span class="n">keys</span><span class="p">:</span>
                <span class="n">del_key</span><span class="p">(</span> <span class="n">key</span><span class="p">,</span> <span class="n">category</span> <span class="p">)</span>
        <span class="k">elif</span> <span class="n">keys</span> <span class="o">!=</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">KeyError</span><span class="p">(</span> <span class="s1">&#39;`keys` must be a non-string Sequence.  Use the &#39;</span>
                  <span class="s1">&#39;singular `key` to disassociate the category for one key.&#39;</span> <span class="p">)</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span> <span class="n">items</span><span class="p">,</span> <span class="nb">dict</span> <span class="p">):</span>
            <span class="k">for</span> <span class="n">key</span><span class="p">,</span> <span class="n">value</span> <span class="ow">in</span> <span class="n">items</span><span class="o">.</span><span class="n">items</span><span class="p">(</span> <span class="p">):</span>
                <span class="n">del_val</span><span class="p">(</span> <span class="n">key</span><span class="p">,</span> <span class="n">value</span><span class="p">,</span> <span class="n">category</span> <span class="p">)</span>
        <span class="k">elif</span> <span class="n">items</span> <span class="o">!=</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">KeyError</span><span class="p">(</span> <span class="s1">&#39;`items` must be a dict( ).&#39;</span> <span class="p">)</span></div>

<div class="viewcode-block" id="categorizedSetDict.keys_categorized"><a class="viewcode-back" href="../ParallelRegression.html#ParallelRegression.categorizedSetDict.keys_categorized">[docs]</a>    <span class="k">def</span> <span class="nf">keys_categorized</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">category</span> <span class="p">):</span>
        <span class="sd">&#39;&#39;&#39;Returns the keys that are associated with the specified category.&#39;&#39;&#39;</span>
        <span class="k">if</span> <span class="n">category</span> <span class="o">==</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">return</span><span class="p">(</span> <span class="bp">self</span><span class="o">.</span><span class="n">_keys_categorized_none</span><span class="p">(</span> <span class="p">)</span> <span class="p">)</span>
        <span class="n">ret</span> <span class="o">=</span> <span class="n">setList</span><span class="p">(</span> <span class="p">)</span>
        <span class="k">for</span> <span class="n">key</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">keys</span><span class="p">(</span> <span class="p">):</span>
            <span class="k">if</span> <span class="n">category</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_s_ctg_keys</span><span class="p">[</span><span class="n">key</span><span class="p">]:</span>
                <span class="n">ret</span><span class="o">.</span><span class="n">append</span><span class="p">(</span> <span class="n">key</span> <span class="p">)</span>
        <span class="k">return</span><span class="p">(</span> <span class="n">ret</span> <span class="p">)</span></div>

<div class="viewcode-block" id="categorizedSetDict.items_categorized"><a class="viewcode-back" href="../ParallelRegression.html#ParallelRegression.categorizedSetDict.items_categorized">[docs]</a>    <span class="k">def</span> <span class="nf">items_categorized</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">category</span> <span class="p">):</span>
        <span class="sd">&#39;&#39;&#39;Returns the key/value pairs consisting of keys associated with the</span>
<span class="sd">        specified category with all of their set members, as well as set</span>
<span class="sd">        members that are individually associated with the specified category</span>
<span class="sd">        (along with their keys).&#39;&#39;&#39;</span>
        <span class="k">if</span> <span class="n">category</span> <span class="o">==</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">return</span><span class="p">(</span> <span class="bp">self</span><span class="o">.</span><span class="n">_items_categorized_none</span><span class="p">(</span> <span class="p">)</span> <span class="p">)</span>
        <span class="n">ret</span> <span class="o">=</span> <span class="n">typedDict</span><span class="p">(</span> <span class="n">setList</span> <span class="p">)</span>
        <span class="k">for</span> <span class="n">key</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">keys</span><span class="p">(</span> <span class="p">):</span>
            <span class="k">if</span> <span class="n">key</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_s_ctg_keys</span><span class="o">.</span><span class="n">keys</span><span class="p">(</span> <span class="p">):</span>
                <span class="k">if</span> <span class="n">category</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_s_ctg_keys</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="ow">or</span> <span class="n">category</span> <span class="o">==</span> <span class="p">(</span><span class="s1">&#39;ALL&#39;</span><span class="p">,):</span>
                    <span class="n">ret</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="n">typedDict</span><span class="o">.</span><span class="n">__getitem__</span><span class="p">(</span> <span class="bp">self</span><span class="p">,</span> <span class="n">key</span> <span class="p">)</span>
                <span class="k">if</span> <span class="n">key</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_s_ctg_values</span><span class="o">.</span><span class="n">keys</span><span class="p">(</span> <span class="p">):</span>
                    <span class="k">if</span> <span class="n">key</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">ret</span><span class="o">.</span><span class="n">keys</span><span class="p">(</span> <span class="p">):</span>
                        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span> <span class="nb">len</span><span class="p">(</span> <span class="bp">self</span><span class="o">.</span><span class="n">_s_ctg_values</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="p">)</span> <span class="p">):</span>
                            <span class="k">if</span> <span class="n">category</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_s_ctg_values</span><span class="p">[</span><span class="n">key</span><span class="p">][</span><span class="n">i</span><span class="p">]:</span>
                                <span class="n">ret</span><span class="p">[</span><span class="n">key</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span> <span class="n">typedDict</span><span class="o">.</span><span class="n">__getitem__</span><span class="p">(</span> <span class="bp">self</span><span class="p">,</span>
                                                                     <span class="n">key</span> <span class="p">)[</span><span class="n">i</span><span class="p">]</span> <span class="p">)</span>
        <span class="k">return</span><span class="p">(</span> <span class="n">ret</span> <span class="p">)</span></div>

<div class="viewcode-block" id="categorizedSetDict.values_categorized"><a class="viewcode-back" href="../ParallelRegression.html#ParallelRegression.categorizedSetDict.values_categorized">[docs]</a>    <span class="k">def</span> <span class="nf">values_categorized</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">category</span> <span class="p">):</span>
        <span class="sd">&#39;&#39;&#39;Returns set members from all sets where either the set member or the</span>
<span class="sd">        set is associated with the specified category.&#39;&#39;&#39;</span>
        <span class="n">items</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">items_categorized</span><span class="p">(</span> <span class="n">category</span> <span class="p">)</span>
        <span class="n">ret</span> <span class="o">=</span> <span class="n">setList</span><span class="p">(</span> <span class="p">)</span>
        <span class="k">for</span> <span class="n">value</span> <span class="ow">in</span> <span class="n">items</span><span class="o">.</span><span class="n">values</span><span class="p">(</span> <span class="p">):</span>
            <span class="n">ret</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span> <span class="n">value</span> <span class="p">)</span>
        <span class="k">return</span><span class="p">(</span> <span class="n">ret</span> <span class="p">)</span></div>

<div class="viewcode-block" id="categorizedSetDict.make_mutually_exclusive"><a class="viewcode-back" href="../ParallelRegression.html#ParallelRegression.categorizedSetDict.make_mutually_exclusive">[docs]</a>    <span class="k">def</span> <span class="nf">make_mutually_exclusive</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">categories</span> <span class="p">):</span>
        <span class="sd">&#39;&#39;&#39;Designates the specified set of categories as mutually exclusive.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        categories : set or Sequence</span>
<span class="sd">            The set of categories to be considered mutually exclusive.  If this</span>
<span class="sd">            is a superset of an existing set of mutually exclusive categories,</span>
<span class="sd">            it will replace the existing subset.  If an existing set is a</span>
<span class="sd">            superset of this one, then no action is taken.</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="n">categories</span> <span class="o">=</span> <span class="nb">frozenset</span><span class="p">(</span> <span class="n">categories</span> <span class="p">)</span>
        <span class="k">for</span> <span class="n">ctgset</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">mutually_exclusive</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">categories</span><span class="o">.</span><span class="n">issuperset</span><span class="p">(</span> <span class="n">ctgset</span> <span class="p">):</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">mutually_exclusive</span><span class="o">.</span><span class="n">remove</span><span class="p">(</span> <span class="n">ctgset</span> <span class="p">)</span>
            <span class="k">elif</span> <span class="n">ctgset</span><span class="o">.</span><span class="n">issuperset</span><span class="p">(</span> <span class="n">categories</span> <span class="p">):</span>
                <span class="k">return</span><span class="p">(</span> <span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">mutually_exclusive</span><span class="o">.</span><span class="n">add</span><span class="p">(</span> <span class="n">categories</span> <span class="p">)</span></div>

    <span class="k">def</span> <span class="nf">_keys_categorized_none</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">items_none</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_items_categorized_none</span><span class="p">(</span> <span class="p">)</span>
        <span class="k">return</span><span class="p">(</span> <span class="n">items_none</span><span class="o">.</span><span class="n">keys</span><span class="p">(</span> <span class="p">)</span> <span class="p">)</span>

    <span class="k">def</span> <span class="nf">_values_categorized_none</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">ret</span> <span class="o">=</span> <span class="n">setList</span><span class="p">(</span> <span class="p">)</span>
        <span class="k">for</span> <span class="n">key</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">keys</span><span class="p">(</span> <span class="p">):</span>
            <span class="k">if</span> <span class="n">key</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_s_ctg_keys</span><span class="o">.</span><span class="n">keys</span><span class="p">(</span> <span class="p">)</span> <span class="ow">or</span> \
               <span class="bp">self</span><span class="o">.</span><span class="n">_s_ctg_keys</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="o">==</span> <span class="kc">None</span> <span class="ow">or</span> \
               <span class="nb">len</span><span class="p">(</span> <span class="bp">self</span><span class="o">.</span><span class="n">_s_ctg_keys</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span> <span class="nb">len</span><span class="p">(</span> <span class="n">typedDict</span><span class="o">.</span><span class="n">__getitem__</span><span class="p">(</span> <span class="bp">self</span><span class="p">,</span> <span class="n">key</span> <span class="p">)</span> <span class="p">)</span> <span class="p">):</span>
                    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span> <span class="bp">self</span><span class="o">.</span><span class="n">_s_ctg_values</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="p">)</span> <span class="o">&lt;=</span> <span class="n">i</span> <span class="ow">or</span> \
                       <span class="bp">self</span><span class="o">.</span><span class="n">_s_ctg_values</span><span class="p">[</span><span class="n">key</span><span class="p">][</span><span class="n">i</span><span class="p">]</span> <span class="o">==</span> <span class="kc">None</span> <span class="ow">or</span> \
                       <span class="nb">len</span><span class="p">(</span> <span class="bp">self</span><span class="o">.</span><span class="n">_s_ctg_values</span><span class="p">[</span><span class="n">key</span><span class="p">][</span><span class="n">i</span><span class="p">]</span> <span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                        <span class="n">ret</span><span class="o">.</span><span class="n">append</span><span class="p">(</span> <span class="n">typedDict</span><span class="o">.</span><span class="n">__getitem__</span><span class="p">(</span> <span class="bp">self</span><span class="p">,</span> <span class="n">key</span> <span class="p">)[</span><span class="n">i</span><span class="p">]</span> <span class="p">)</span>
        <span class="k">return</span><span class="p">(</span> <span class="n">ret</span> <span class="p">)</span>

    <span class="k">def</span> <span class="nf">_items_categorized_none</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">ret</span> <span class="o">=</span> <span class="n">typedDict</span><span class="p">(</span> <span class="n">setList</span> <span class="p">)</span>
        <span class="k">for</span> <span class="n">key</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">keys</span><span class="p">(</span> <span class="p">):</span>
            <span class="k">if</span> <span class="n">key</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_s_ctg_keys</span><span class="o">.</span><span class="n">keys</span><span class="p">(</span> <span class="p">)</span> <span class="ow">or</span> \
               <span class="bp">self</span><span class="o">.</span><span class="n">_s_ctg_keys</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="o">==</span> <span class="p">{</span><span class="kc">None</span><span class="p">,}</span> <span class="ow">or</span> \
               <span class="nb">len</span><span class="p">(</span> <span class="bp">self</span><span class="o">.</span><span class="n">_s_ctg_keys</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span> <span class="nb">len</span><span class="p">(</span> <span class="n">typedDict</span><span class="o">.</span><span class="n">__getitem__</span><span class="p">(</span> <span class="bp">self</span><span class="p">,</span> <span class="n">key</span> <span class="p">)</span> <span class="p">)</span> <span class="p">):</span>
                    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span> <span class="bp">self</span><span class="o">.</span><span class="n">_s_ctg_values</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="p">)</span> <span class="o">&lt;=</span> <span class="n">i</span> <span class="ow">or</span> \
                       <span class="bp">self</span><span class="o">.</span><span class="n">_s_ctg_values</span><span class="p">[</span><span class="n">key</span><span class="p">][</span><span class="n">i</span><span class="p">]</span> <span class="o">==</span> <span class="kc">None</span> <span class="ow">or</span> \
                       <span class="nb">len</span><span class="p">(</span> <span class="bp">self</span><span class="o">.</span><span class="n">_s_ctg_values</span><span class="p">[</span><span class="n">key</span><span class="p">][</span><span class="n">i</span><span class="p">]</span> <span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                        <span class="n">ret</span><span class="p">[</span><span class="n">key</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span> <span class="n">typedDict</span><span class="o">.</span><span class="n">__getitem__</span><span class="p">(</span> <span class="bp">self</span><span class="p">,</span>
                                                                <span class="n">key</span> <span class="p">)[</span><span class="n">i</span><span class="p">]</span> <span class="p">)</span>
        <span class="k">return</span><span class="p">(</span> <span class="n">ret</span> <span class="p">)</span>

<div class="viewcode-block" id="categorizedSetDict.pop"><a class="viewcode-back" href="../ParallelRegression.html#ParallelRegression.categorizedSetDict.pop">[docs]</a>    <span class="k">def</span> <span class="nf">pop</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">key</span> <span class="p">):</span>
        <span class="sd">&#39;&#39;&#39;Removes and returns the setList( ) associated with the provided key</span>
<span class="sd">        and deletes category information.</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="k">if</span> <span class="n">key</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">KeyError</span><span class="p">(</span> <span class="s1">&#39;Invalid key: `</span><span class="si">%s</span><span class="s1">`.&#39;</span> <span class="o">%</span> <span class="n">key</span> <span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_s_ctg_keys</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span> <span class="n">key</span> <span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_s_ctg_values</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span> <span class="n">key</span> <span class="p">)</span>
        <span class="k">return</span><span class="p">(</span> <span class="n">typedDict</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span> <span class="bp">self</span><span class="p">,</span> <span class="n">key</span> <span class="p">)</span> <span class="p">)</span></div>

    <span class="k">def</span> <span class="nf">__delitem__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">key</span> <span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span> <span class="n">key</span> <span class="p">)</span>

    <span class="k">def</span> <span class="nf">__missing__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">key</span> <span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_s_ctg_keys</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span> <span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_s_ctg_values</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span> <span class="p">)</span>
        <span class="k">return</span><span class="p">(</span> <span class="n">typedDict</span><span class="o">.</span><span class="n">__missing__</span><span class="p">(</span> <span class="bp">self</span><span class="p">,</span> <span class="n">key</span> <span class="p">)</span> <span class="p">)</span>

    <span class="k">def</span> <span class="nf">keys</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span><span class="p">(</span> <span class="n">setList</span><span class="p">(</span> <span class="n">values</span><span class="o">=</span><span class="n">typedDict</span><span class="o">.</span><span class="n">keys</span><span class="p">(</span> <span class="bp">self</span> <span class="p">)</span> <span class="p">)</span> <span class="p">)</span></div>

<span class="k">def</span> <span class="nf">get_term_vars</span><span class="p">(</span> <span class="n">formula</span> <span class="p">):</span>
    <span class="sd">&#39;&#39;&#39;Returns a flat setList( ) containing all valid Python variable names in</span>
<span class="sd">    the provided string.</span>
<span class="sd">    &#39;&#39;&#39;</span>
    <span class="n">INTERNAL_NOTE</span> <span class="o">=</span> <span class="s1">&#39;&#39;&#39;Originally written for termSet( )&#39;s initializing from a</span>
<span class="s1">    set of formulas, and moved out of termSet( ) so that it could also be used</span>
<span class="s1">    by laggedAccessor.rewrite( ).</span>
<span class="s1">    &#39;&#39;&#39;</span>
    <span class="n">patsySet</span> <span class="o">=</span> <span class="n">_patsy_terms</span><span class="p">(</span> <span class="n">formula</span><span class="p">,</span> <span class="n">reduce_to_vars</span><span class="o">=</span><span class="kc">True</span> <span class="p">)</span>
    <span class="n">ret</span> <span class="o">=</span> <span class="n">setList</span><span class="p">(</span> <span class="p">)</span>
    <span class="k">for</span> <span class="n">patsyTerm</span> <span class="ow">in</span> <span class="n">patsySet</span><span class="p">:</span>
        <span class="k">for</span> <span class="n">var</span> <span class="ow">in</span> <span class="n">patsyTerm</span><span class="p">:</span>
            <span class="n">ret</span><span class="o">.</span><span class="n">add</span><span class="p">(</span> <span class="n">var</span> <span class="p">)</span>
    <span class="k">return</span><span class="p">(</span> <span class="n">ret</span> <span class="p">)</span>

<div class="viewcode-block" id="termSet"><a class="viewcode-back" href="../ParallelRegression.html#ParallelRegression.termSet">[docs]</a><span class="k">class</span> <span class="nc">termSet</span><span class="p">(</span><span class="n">categorizedSetDict</span><span class="p">):</span>
    <span class="sd">&#39;&#39;&#39;Manages a set of terms, each of which might have multiple</span>
<span class="sd">    representations.</span>

<span class="sd">    Categories</span>
<span class="sd">    ----------</span>
<span class="sd">    dummy</span>
<span class="sd">        &quot;Dummy&quot; terms or representations of terms in which there are only two</span>
<span class="sd">        values.</span>
<span class="sd">    Y</span>
<span class="sd">        Terms that are used on the LHS of formulas instead of the RHS.  Terms</span>
<span class="sd">        that are sometimes used on the LHS and sometimes used on the RHS are</span>
<span class="sd">        not supported.  (However, there is no need to make use of the &#39;Y&#39;</span>
<span class="sd">        category in order to make full use of mathDict( ).)</span>
<span class="sd">    required_X</span>
<span class="sd">        Terms that must be included on the RHS of all formulas derived from</span>
<span class="sd">        this termSet( ).</span>
<span class="sd">    T</span>
<span class="sd">        RHS term(s) representing time/trend.</span>
<span class="sd">    &#39;&#39;&#39;</span>
<div class="viewcode-block" id="termSet.__init__"><a class="viewcode-back" href="../ParallelRegression.html#ParallelRegression.termSet.__init__">[docs]</a>    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="n">interactions</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">expand</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span> <span class="p">):</span>
        <span class="sd">&#39;&#39;&#39;Creates a termSet( ) instance.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        formulas : Iterable of formula strings</span>
<span class="sd">            Iterable of a formula strings from which to extract the terms and</span>
<span class="sd">            their forms.  Ex: [&#39;y ~ x**2 + x&#39;, &#39;ln(y) ~ ln(x)&#39;].</span>
<span class="sd">        *or*</span>
<span class="sd">        terms : dict</span>
<span class="sd">            Dictionary in which each term is represented by a key for which the</span>
<span class="sd">            value is a sequence of forms in which the term might occur.  Ex:</span>
<span class="sd">            {&#39;X&#39;: [&#39;X&#39;, &#39;ln(X)&#39;]}.  Entries for which the value is a single</span>
<span class="sd">            string, e.g. {&#39;d&#39;: &#39;d&#39;},  will be treated as dummy terms.  To avoid</span>
<span class="sd">            this when a term has only one form, enclose the string in a list,</span>
<span class="sd">            e.g. {&#39;X&#39;: [&#39;X&#39;]}.</span>
<span class="sd">        T : string, optional</span>
<span class="sd">            String identifying a single term that represents time/trend.</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="n">categorizedSetDict</span><span class="o">.</span><span class="n">__init__</span><span class="p">(</span> <span class="bp">self</span><span class="p">,</span> <span class="n">singular_category</span><span class="o">=</span><span class="s1">&#39;dummy&#39;</span> <span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">make_mutually_exclusive</span><span class="p">(</span> <span class="p">[</span><span class="s1">&#39;Y&#39;</span><span class="p">,</span> <span class="s1">&#39;required_X&#39;</span><span class="p">]</span> <span class="p">)</span>
        <span class="k">if</span> <span class="s1">&#39;terms&#39;</span> <span class="ow">in</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">keys</span><span class="p">(</span> <span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_init_from_terms</span><span class="p">(</span> <span class="o">**</span><span class="n">kwargs</span> <span class="p">)</span>
        <span class="k">elif</span> <span class="s1">&#39;formulas&#39;</span> <span class="ow">in</span> <span class="n">kwargs</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_init_from_formulas</span><span class="p">(</span> <span class="o">**</span><span class="n">kwargs</span> <span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_init_from_terms</span><span class="p">(</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span> <span class="p">)</span></div>

    <span class="k">def</span> <span class="nf">_init_from_formulas</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">formulas</span> <span class="p">):</span>
        <span class="k">def</span> <span class="nf">get_term_reps</span><span class="p">(</span> <span class="n">formula</span> <span class="p">):</span>
            <span class="n">patsySet</span> <span class="o">=</span> <span class="n">_patsy_terms</span><span class="p">(</span> <span class="n">formula</span> <span class="p">)</span>
            <span class="n">ret</span> <span class="o">=</span> <span class="n">typedDict</span><span class="p">(</span> <span class="n">setList</span> <span class="p">)</span>
            <span class="k">for</span> <span class="n">patsyTerm</span> <span class="ow">in</span> <span class="n">patsySet</span><span class="p">:</span>
                <span class="k">for</span> <span class="n">factor</span> <span class="ow">in</span> <span class="n">patsyTerm</span><span class="p">:</span>
                    <span class="k">for</span> <span class="n">var</span> <span class="ow">in</span> <span class="n">_vars_in_factor</span><span class="p">(</span> <span class="n">factor</span> <span class="p">):</span>
                        <span class="n">ret</span><span class="p">[</span><span class="n">var</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span> <span class="n">factor</span> <span class="p">)</span>
            <span class="k">return</span><span class="p">(</span> <span class="n">ret</span> <span class="p">)</span>
        <span class="c1">#######################################################################</span>
        <span class="c1">## Body of method starts here:</span>
        <span class="n">Y</span> <span class="o">=</span> <span class="n">setList</span><span class="p">(</span> <span class="p">)</span>
        <span class="k">for</span> <span class="n">formula</span> <span class="ow">in</span> <span class="n">formulas</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">union_update</span><span class="p">(</span> <span class="n">get_term_reps</span><span class="p">(</span> <span class="n">formula</span> <span class="p">)</span> <span class="p">)</span>
            <span class="n">sides</span> <span class="o">=</span> <span class="n">formula</span><span class="o">.</span><span class="n">split</span><span class="p">(</span> <span class="s1">&#39;~&#39;</span> <span class="p">)</span>
            <span class="n">Y</span> <span class="o">=</span> <span class="n">Y</span><span class="o">.</span><span class="n">union</span><span class="p">(</span> <span class="n">get_term_vars</span><span class="p">(</span> <span class="n">sides</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="p">)</span> <span class="p">)</span>
        <span class="k">for</span> <span class="n">y</span> <span class="ow">in</span> <span class="n">Y</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">set_category</span><span class="p">(</span> <span class="s1">&#39;Y&#39;</span><span class="p">,</span> <span class="n">key</span><span class="o">=</span><span class="n">y</span> <span class="p">)</span>

    <span class="k">def</span> <span class="nf">_init_from_terms</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">terms</span><span class="p">,</span> <span class="n">dterms</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">T</span><span class="o">=</span><span class="kc">None</span> <span class="p">):</span>
        <span class="n">DEPRECATED_PARAMETERS</span> <span class="o">=</span> <span class="s1">&#39;&#39;&#39;</span>
<span class="s1">        dterms : Iterable, optional</span>
<span class="s1">            Iterable of dummy terms that only occur in one form.  Dummy terms</span>
<span class="s1">            listed in `dterms` need not also be listed in `terms`.</span>
<span class="s1">        T : string, optional</span>
<span class="s1">            Same story as dterms, except for the &#39;T&#39; category and only one term</span>
<span class="s1">            can be specified in this manner.</span>

<span class="s1">        The `dterms` parameter is deprecated as of the first release of</span>
<span class="s1">        Parallel Regression.  It exists to support code that predates</span>
<span class="s1">        categorizedSetDict( ) and will be removed in a subsequent release.  Use</span>
<span class="s1">        entries in the `terms` dict( ) for which the value is a single string</span>
<span class="s1">        to identify single-form dummy terms at initialization time.</span>
<span class="s1">        &#39;&#39;&#39;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span> <span class="n">terms</span><span class="p">,</span> <span class="nb">dict</span> <span class="p">):</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span> <span class="s1">&#39;The set of real terms must be a dictionary.&#39;</span> <span class="p">)</span>
        <span class="k">if</span> <span class="n">dterms</span> <span class="o">!=</span> <span class="kc">None</span> <span class="ow">and</span> \
           <span class="p">((</span><span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span> <span class="n">dterms</span><span class="p">,</span> <span class="n">abc</span><span class="o">.</span><span class="n">Iterable</span> <span class="p">))</span> <span class="ow">or</span> \
            <span class="nb">isinstance</span><span class="p">(</span> <span class="n">dterms</span><span class="p">,</span> <span class="nb">str</span> <span class="p">)):</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span> <span class="s1">&#39;The set of dummy variables must be a non-string&#39;</span>
                             <span class="s1">&#39; iterable.&#39;</span> <span class="p">)</span>
        <span class="k">if</span> <span class="p">(</span><span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span> <span class="n">T</span><span class="p">,</span> <span class="nb">str</span> <span class="p">))</span> <span class="ow">and</span> <span class="n">T</span> <span class="o">!=</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span> <span class="s1">&#39;The time index term must be identified by a &#39;</span>
                  <span class="s1">&#39;string not in the set of dummy terms and not used as a key &#39;</span>
                  <span class="s1">&#39;in the dictionary of real terms.&#39;</span> <span class="p">)</span>
        <span class="k">for</span> <span class="n">term</span> <span class="ow">in</span> <span class="n">dterms</span><span class="p">:</span>
            <span class="bp">self</span><span class="p">[</span><span class="n">term</span><span class="p">]</span> <span class="o">=</span> <span class="n">term</span>
        <span class="k">if</span> <span class="n">T</span><span class="p">:</span>
            <span class="bp">self</span><span class="p">[</span><span class="n">T</span><span class="p">]</span> <span class="o">=</span> <span class="p">([</span><span class="n">T</span><span class="p">],</span> <span class="p">{</span><span class="s1">&#39;T&#39;</span><span class="p">,})</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">update</span><span class="p">(</span> <span class="n">terms</span> <span class="p">)</span>

<div class="viewcode-block" id="termSet.changeT"><a class="viewcode-back" href="../ParallelRegression.html#ParallelRegression.termSet.changeT">[docs]</a>    <span class="k">def</span> <span class="nf">changeT</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">T</span> <span class="p">):</span>
        <span class="sd">&#39;&#39;&#39;Disassociates any term(s) currently associated with the category &#39;T&#39;</span>
<span class="sd">        and associates `T` with the category &#39;T&#39;.</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="n">old_T</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">keys_categorized</span><span class="p">(</span> <span class="s1">&#39;T&#39;</span> <span class="p">)</span>
        <span class="k">for</span> <span class="n">key</span> <span class="ow">in</span> <span class="n">old_T</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">del_category</span><span class="p">(</span> <span class="s1">&#39;T&#39;</span><span class="p">,</span> <span class="n">key</span><span class="o">=</span><span class="n">key</span> <span class="p">)</span>
        <span class="k">if</span> <span class="n">T</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">T</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">keys</span><span class="p">(</span> <span class="p">):</span>
                <span class="bp">self</span><span class="p">[</span><span class="n">T</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">T</span><span class="p">,</span> <span class="p">{</span><span class="s1">&#39;T&#39;</span><span class="p">,})</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">set_category</span><span class="p">(</span> <span class="s1">&#39;T&#39;</span><span class="p">,</span> <span class="n">key</span><span class="o">=</span><span class="n">T</span> <span class="p">)</span></div>

<div class="viewcode-block" id="termSet.require"><a class="viewcode-back" href="../ParallelRegression.html#ParallelRegression.termSet.require">[docs]</a>    <span class="k">def</span> <span class="nf">require</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="n">make</span><span class="o">=</span><span class="kc">True</span> <span class="p">):</span>
        <span class="sd">&#39;&#39;&#39;Associates keys listed in *args with the category &#39;required_x&#39; if</span>
<span class="sd">        `make` is True, or disassociates them if `make` is False.</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span> <span class="n">args</span><span class="p">,</span> <span class="nb">str</span> <span class="p">):</span>
                <span class="k">if</span> <span class="n">make</span><span class="p">:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">set_category</span><span class="p">(</span> <span class="s1">&#39;required_X&#39;</span><span class="p">,</span> <span class="n">key</span><span class="o">=</span><span class="n">args</span> <span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">del_category</span><span class="p">(</span> <span class="s1">&#39;required_X&#39;</span><span class="p">,</span> <span class="n">key</span><span class="o">=</span><span class="n">args</span> <span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">for</span> <span class="n">key</span> <span class="ow">in</span> <span class="n">args</span><span class="p">:</span>
                    <span class="k">if</span> <span class="n">make</span><span class="p">:</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">set_category</span><span class="p">(</span> <span class="s1">&#39;required_X&#39;</span><span class="p">,</span> <span class="n">key</span><span class="o">=</span><span class="n">key</span> <span class="p">)</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">del_category</span><span class="p">(</span> <span class="s1">&#39;required_X&#39;</span><span class="p">,</span> <span class="n">key</span><span class="o">=</span><span class="n">key</span> <span class="p">)</span>
        <span class="k">except</span> <span class="n">CategoryError</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">KeyError</span><span class="p">(</span> <span class="s1">&#39;That key is already in Y.  It cannot be used on &#39;</span>
                            <span class="s1">&#39;the LHS and required on the RHS.&#39;</span> <span class="p">)</span></div>

<div class="viewcode-block" id="termSet.Y"><a class="viewcode-back" href="../ParallelRegression.html#ParallelRegression.termSet.Y">[docs]</a>    <span class="k">def</span> <span class="nf">Y</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">key</span><span class="p">,</span> <span class="n">value</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">make</span><span class="o">=</span><span class="kc">True</span> <span class="p">):</span>
        <span class="sd">&#39;&#39;&#39; Associates the specified term with the category &#39;Y&#39; if `make` is</span>
<span class="sd">        True, or disassociates it if `make` is False.</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="k">if</span> <span class="n">key</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">keys</span><span class="p">(</span> <span class="p">):</span>
            <span class="bp">self</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="n">key</span><span class="p">]</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">make</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">set_category</span><span class="p">(</span> <span class="s1">&#39;Y&#39;</span><span class="p">,</span> <span class="n">key</span><span class="o">=</span><span class="n">key</span><span class="p">,</span> <span class="n">value</span><span class="o">=</span><span class="n">value</span> <span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">del_category</span><span class="p">(</span> <span class="s1">&#39;Y&#39;</span><span class="p">,</span> <span class="n">key</span><span class="o">=</span><span class="n">key</span><span class="p">,</span> <span class="n">value</span><span class="o">=</span><span class="n">value</span> <span class="p">)</span>
        <span class="k">except</span> <span class="n">CategoryError</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">KeyError</span><span class="p">(</span> <span class="s1">&#39;That key is already required on the RHS.  It &#39;</span>
                 <span class="s1">&#39;cannot be used on the LHS while it is required on the RHS.&#39;</span> <span class="p">)</span></div>

<div class="viewcode-block" id="termSet.dummy"><a class="viewcode-back" href="../ParallelRegression.html#ParallelRegression.termSet.dummy">[docs]</a>    <span class="k">def</span> <span class="nf">dummy</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">key</span><span class="p">,</span> <span class="n">value</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">make</span><span class="o">=</span><span class="kc">True</span> <span class="p">):</span>
        <span class="sd">&#39;&#39;&#39; Associates the specified term with the category &#39;dummy&#39; if `make`</span>
<span class="sd">        is True, or disassociates it if `make` is False.</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="k">if</span> <span class="n">make</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">set_category</span><span class="p">(</span> <span class="s1">&#39;dummy&#39;</span><span class="p">,</span> <span class="n">key</span><span class="o">=</span><span class="n">key</span><span class="p">,</span> <span class="n">value</span><span class="o">=</span><span class="n">value</span> <span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">del_category</span><span class="p">(</span> <span class="s1">&#39;dummy&#39;</span><span class="p">,</span> <span class="n">key</span><span class="o">=</span><span class="n">key</span><span class="p">,</span> <span class="n">value</span><span class="o">=</span><span class="n">value</span> <span class="p">)</span></div>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">W_term_set</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span><span class="p">(</span> <span class="bp">self</span><span class="o">.</span><span class="n">keys</span><span class="p">(</span> <span class="p">)</span> <span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">W_termRep_set</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">ret</span> <span class="o">=</span> <span class="n">setList</span><span class="p">(</span> <span class="p">)</span>
        <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">keys</span><span class="p">(</span> <span class="p">):</span>
            <span class="n">ret</span><span class="o">.</span><span class="n">update</span><span class="p">(</span> <span class="bp">self</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="p">)</span>
        <span class="k">return</span><span class="p">(</span> <span class="n">ret</span> <span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">Y_term_set</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span><span class="p">(</span> <span class="bp">self</span><span class="o">.</span><span class="n">keys_categorized</span><span class="p">(</span> <span class="s1">&#39;Y&#39;</span> <span class="p">)</span> <span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">X_required_set</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span><span class="p">(</span> <span class="bp">self</span><span class="o">.</span><span class="n">keys_categorized</span><span class="p">(</span> <span class="s1">&#39;required_X&#39;</span> <span class="p">)</span> <span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">all_X_terms_set</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span><span class="p">(</span> <span class="bp">self</span><span class="o">.</span><span class="n">keys</span><span class="p">(</span> <span class="p">)</span><span class="o">.</span><span class="n">difference</span><span class="p">(</span> <span class="bp">self</span><span class="o">.</span><span class="n">keys_categorized</span><span class="p">(</span> <span class="s1">&#39;Y&#39;</span> <span class="p">)</span> <span class="p">)</span> <span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">dummy_term_set</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span><span class="p">(</span> <span class="bp">self</span><span class="o">.</span><span class="n">keys_categorized</span><span class="p">(</span> <span class="s1">&#39;dummy&#39;</span> <span class="p">)</span> <span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">dummy_termRep_set</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span><span class="p">(</span> <span class="bp">self</span><span class="o">.</span><span class="n">values_categorized</span><span class="p">(</span> <span class="s1">&#39;dummy&#39;</span> <span class="p">)</span> <span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">real_term_set</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span><span class="p">(</span> <span class="bp">self</span><span class="o">.</span><span class="n">keys</span><span class="p">(</span> <span class="p">)</span><span class="o">.</span><span class="n">difference</span><span class="p">(</span> <span class="bp">self</span><span class="o">.</span><span class="n">keys_categorized</span><span class="p">(</span> <span class="s1">&#39;dummy&#39;</span>
                                        <span class="p">)</span><span class="o">.</span><span class="n">union</span><span class="p">(</span> <span class="bp">self</span><span class="o">.</span><span class="n">keys_categorized</span><span class="p">(</span> <span class="s1">&#39;T&#39;</span> <span class="p">)</span> <span class="p">)</span>
                                        <span class="p">)</span> <span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">real_termRep_set</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span><span class="p">(</span> <span class="bp">self</span><span class="o">.</span><span class="n">values_categorized</span><span class="p">(</span> <span class="p">(</span><span class="s1">&#39;ALL&#39;</span><span class="p">,)</span> <span class="p">)</span><span class="o">.</span><span class="n">difference</span><span class="p">(</span>
                                      <span class="bp">self</span><span class="o">.</span><span class="n">values_categorized</span><span class="p">(</span> <span class="s1">&#39;dummy&#39;</span> <span class="p">)</span><span class="o">.</span><span class="n">union</span><span class="p">(</span>
                                           <span class="bp">self</span><span class="o">.</span><span class="n">values_categorized</span><span class="p">(</span> <span class="s1">&#39;T&#39;</span> <span class="p">)</span> <span class="p">)</span> <span class="p">)</span> <span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">other_terms</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span><span class="p">(</span> <span class="bp">self</span><span class="o">.</span><span class="n">keys</span><span class="p">(</span> <span class="p">)</span><span class="o">.</span><span class="n">difference</span><span class="p">(</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">keys_categorized</span><span class="p">(</span> <span class="s1">&#39;Y&#39;</span> <span class="p">)</span><span class="o">.</span><span class="n">union</span><span class="p">(</span> <span class="bp">self</span><span class="o">.</span><span class="n">keys_categorized</span><span class="p">(</span> <span class="s1">&#39;required_X&#39;</span>
                                                                        <span class="p">)</span> <span class="p">)</span> <span class="p">)</span> <span class="p">)</span></div>

<span class="n">PR_BYTESIZE</span> <span class="o">=</span> <span class="mi">8</span>
<span class="n">PR_NP_INT</span>   <span class="o">=</span> <span class="s1">&#39;i8&#39;</span>
<span class="n">PR_PY_INT</span>   <span class="o">=</span> <span class="s1">&#39;q&#39;</span>
<span class="n">PR_NP_FLT</span>   <span class="o">=</span> <span class="s1">&#39;f8&#39;</span>
<span class="n">PR_PY_FLT</span>   <span class="o">=</span> <span class="s1">&#39;d&#39;</span>

<span class="n">NoneSet</span> <span class="o">=</span> <span class="p">{</span><span class="kc">None</span><span class="p">,</span> <span class="s1">&#39;&#39;</span><span class="p">}</span>
<div class="viewcode-block" id="laggedAccessor"><a class="viewcode-back" href="../ParallelRegression.html#ParallelRegression.laggedAccessor">[docs]</a><span class="k">class</span> <span class="nc">laggedAccessor</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="sd">&#39;&#39;&#39;Allows lagged values to be retrieved from a dict( ) or</span>
<span class="sd">    pandas.dataframe( ) object using the same `L#@column_name` notation used by</span>
<span class="sd">    other mathDict classes.</span>
<span class="sd">    &#39;&#39;&#39;</span>
<div class="viewcode-block" id="laggedAccessor.__init__"><a class="viewcode-back" href="../ParallelRegression.html#ParallelRegression.laggedAccessor.__init__">[docs]</a>    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">data</span><span class="p">,</span> <span class="n">max_lag</span><span class="o">=</span><span class="kc">None</span> <span class="p">):</span>
        <span class="sd">&#39;&#39;&#39;Initializes the laggedAccessor( ).</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        data : dict( ) or pandas.dataframe( )</span>
<span class="sd">            The collection of columns from which values are to be retrieved.</span>
<span class="sd">        max_lag : int, optional</span>
<span class="sd">            The maximum number of lags to be provided.  The first `max_lag`</span>
<span class="sd">            number of rows will be hidden from each column retrieved through</span>
<span class="sd">            the laggedAccessor so that retrieving `column` and retrieving</span>
<span class="sd">            `L1@column` results in columns of the same length.  This number</span>
<span class="sd">            must either be set explicitly or by using one of the .findMaxLag( )</span>
<span class="sd">            or .rewrite( ) methods.</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">data</span> <span class="o">=</span> <span class="n">data</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">max_lag</span> <span class="o">=</span> <span class="n">max_lag</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">key_map</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">dict_columns</span> <span class="o">=</span> <span class="p">[]</span></div>

<div class="viewcode-block" id="laggedAccessor.__getitem__"><a class="viewcode-back" href="../ParallelRegression.html#ParallelRegression.laggedAccessor.__getitem__">[docs]</a>    <span class="k">def</span> <span class="nf">__getitem__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">index</span> <span class="p">):</span>
        <span class="sd">&#39;&#39;&#39;Returns a row, column, or slice of a column from the linked</span>
<span class="sd">        collection of columns.</span>

<span class="sd">        Data is always retrieved via a call to .get_column( ), so &quot;row&quot; has the</span>
<span class="sd">        meaning it has to that method.</span>

<span class="sd">        **Supported Notation**</span>

<span class="sd">        ------------------</span>
<span class="sd">        int -&gt; returns a dict( ) of columns values for one row</span>

<span class="sd">        str -&gt; returns the requested column</span>

<span class="sd">        (int or slice, str) tuple -&gt; returns the specified row(s) from the</span>
<span class="sd">        requested column</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span> <span class="n">index</span><span class="p">,</span> <span class="nb">int</span> <span class="p">):</span>
            <span class="n">ret</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span> <span class="p">)</span>
            <span class="k">for</span> <span class="n">column</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">dict_columns</span><span class="p">:</span>
                <span class="k">try</span><span class="p">:</span>
                    <span class="n">ret</span><span class="p">[</span><span class="n">column</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_column</span><span class="p">(</span> <span class="n">column</span><span class="p">,</span> <span class="n">row</span><span class="o">=</span><span class="n">index</span> <span class="p">)</span>
                <span class="k">except</span> <span class="ne">KeyError</span><span class="p">:</span>
                    <span class="k">pass</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">key_map</span><span class="p">:</span>
                <span class="k">for</span> <span class="n">column</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">key_map</span><span class="p">:</span>
                    <span class="n">ret</span><span class="p">[</span><span class="n">column</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="p">[</span><span class="n">index</span><span class="p">,</span> <span class="n">column</span><span class="p">]</span>
            <span class="k">return</span><span class="p">(</span> <span class="n">ret</span> <span class="p">)</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span> <span class="n">index</span><span class="p">,</span> <span class="nb">tuple</span> <span class="p">)</span> <span class="ow">and</span> \
           <span class="nb">isinstance</span><span class="p">(</span> <span class="n">index</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="p">(</span><span class="nb">int</span><span class="p">,</span> <span class="nb">slice</span><span class="p">)</span> <span class="p">)</span> <span class="ow">and</span> \
           <span class="nb">len</span><span class="p">(</span> <span class="n">index</span> <span class="p">)</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
            <span class="n">row</span> <span class="o">=</span> <span class="n">index</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
            <span class="n">index</span> <span class="o">=</span> <span class="n">index</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">row</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span> <span class="n">index</span><span class="p">,</span> <span class="nb">str</span> <span class="p">):</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">key_map</span> <span class="ow">and</span> <span class="n">index</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">key_map</span><span class="p">:</span>
                <span class="n">mobj_dict</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">key_map</span><span class="p">[</span><span class="n">index</span><span class="p">]</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">mobj_dict</span> <span class="o">=</span> <span class="n">masked_dict</span><span class="p">(</span> <span class="n">index</span><span class="p">,</span>
                                         <span class="n">prefixed_pat</span><span class="o">.</span><span class="n">fullmatch</span><span class="p">(</span>
                                                     <span class="n">mask_brackets</span><span class="p">(</span> <span class="n">index</span> <span class="p">)</span> <span class="p">)</span> <span class="p">)</span>
            <span class="k">if</span> <span class="n">mobj_dict</span> <span class="o">==</span> <span class="kc">None</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">KeyError</span><span class="p">(</span> <span class="s1">&#39;`</span><span class="si">%s</span><span class="s1">` is not a valid access pattern.&#39;</span> <span class="o">%</span> <span class="n">index</span> <span class="p">)</span>
            <span class="k">elif</span> <span class="n">mobj_dict</span><span class="p">[</span><span class="s1">&#39;lag&#39;</span><span class="p">]</span> <span class="ow">in</span> <span class="n">NoneSet</span><span class="p">:</span>
                <span class="n">mobj_dict</span><span class="p">[</span><span class="s1">&#39;lag&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">mobj_dict</span><span class="p">[</span><span class="s1">&#39;lag&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span> <span class="n">mobj_dict</span><span class="p">[</span><span class="s1">&#39;lag&#39;</span><span class="p">]</span> <span class="p">)</span>
            <span class="k">return</span><span class="p">(</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_column</span><span class="p">(</span> <span class="n">row</span><span class="o">=</span><span class="n">row</span><span class="p">,</span> <span class="o">**</span><span class="n">mobj_dict</span> <span class="p">)</span> <span class="p">)</span></div>

<div class="viewcode-block" id="laggedAccessor.get_column"><a class="viewcode-back" href="../ParallelRegression.html#ParallelRegression.laggedAccessor.get_column">[docs]</a>    <span class="k">def</span> <span class="nf">get_column</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">column_name</span><span class="p">,</span> <span class="n">lag</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">row</span><span class="o">=</span><span class="kc">None</span> <span class="p">):</span>
        <span class="sd">&#39;&#39;&#39;Returns the requested column or slice thereof.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        column_name : string</span>
<span class="sd">            The name of the column in the linked collection of columns from</span>
<span class="sd">            which to retrieve data.</span>
<span class="sd">        lag : int, optional</span>
<span class="sd">            The column representing this many lags of `column_name` will be</span>
<span class="sd">            returned.  A `lag` of zero refers to the column that is the subset</span>
<span class="sd">            of rows of `column_name` in the linked collection starting at the</span>
<span class="sd">            index location equal to the `max_lag` value that this</span>
<span class="sd">            laggedAccessor( ) is configured to support.</span>
<span class="sd">        row : int or slice, optional</span>
<span class="sd">           The row or slice to be retrieved.  This refers to row numbers in the</span>
<span class="sd">           column identified by the combination of the `column_name` and `lag`</span>
<span class="sd">           parameters and the configured `max_lag` value.</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span> <span class="n">row</span><span class="p">,</span> <span class="nb">int</span> <span class="p">)</span> <span class="ow">and</span> <span class="n">row</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span> <span class="s1">&#39;Negative row indexes such as the requested row,&#39;</span>
                              <span class="s1">&#39; </span><span class="si">%d</span><span class="s1">, are not supported.&#39;</span> <span class="o">%</span> <span class="n">row</span> <span class="p">)</span>
        <span class="k">if</span> <span class="n">lag</span> <span class="o">&gt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">max_lag</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">KeyError</span><span class="p">(</span> <span class="s1">&#39;</span><span class="si">%d</span><span class="s1"> exceeds the maximum lag of </span><span class="si">%d</span><span class="s1">.&#39;</span>
                            <span class="o">%</span> <span class="p">(</span><span class="n">lag</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">max_lag</span><span class="p">)</span> <span class="p">)</span>
        <span class="n">a</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">max_lag</span> <span class="o">-</span> <span class="n">lag</span>
        <span class="n">t</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span> <span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="p">[</span><span class="n">column_name</span><span class="p">]</span> <span class="p">)</span> <span class="o">-</span> <span class="n">lag</span>
        <span class="k">if</span> <span class="n">row</span> <span class="o">!=</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">ret</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="p">[</span><span class="n">column_name</span><span class="p">][</span><span class="n">a</span><span class="p">:</span><span class="n">t</span><span class="p">]</span>
            <span class="k">if</span> <span class="s1">&#39;values&#39;</span> <span class="ow">in</span> <span class="n">ret</span><span class="o">.</span><span class="n">__dir__</span><span class="p">(</span> <span class="p">):</span>
                <span class="n">ret</span> <span class="o">=</span> <span class="n">ret</span><span class="o">.</span><span class="n">values</span>
            <span class="k">return</span><span class="p">(</span> <span class="n">ret</span><span class="p">[</span><span class="n">row</span><span class="p">]</span> <span class="p">)</span>
        <span class="k">return</span><span class="p">(</span> <span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="p">[</span><span class="n">column_name</span><span class="p">][</span><span class="n">a</span><span class="p">:</span><span class="n">t</span><span class="p">]</span> <span class="p">)</span></div>

<div class="viewcode-block" id="laggedAccessor.findMaxLag"><a class="viewcode-back" href="../ParallelRegression.html#ParallelRegression.laggedAccessor.findMaxLag">[docs]</a>    <span class="k">def</span> <span class="nf">findMaxLag</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">formula_string</span><span class="p">,</span> <span class="n">in_place</span><span class="o">=</span><span class="kc">False</span> <span class="p">):</span>
        <span class="sd">&#39;&#39;&#39;Determines the maximum lag requested for any column in the provided</span>
<span class="sd">        formula string(s).</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        formula_string : string or Sequence</span>
<span class="sd">            The formula(s) to be searched for lags.</span>
<span class="sd">        in_place : bool, optional</span>
<span class="sd">            If True, then the max_lag attribute of this laggedAccessor( ) will</span>
<span class="sd">            be updated based on the maximum lag in the provided formula(s).</span>
<span class="sd">            Otherwise, a new laggedAccessor( ) instance linked to the same data</span>
<span class="sd">            object will be created, and its max_lag attribute will be set.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        laggedAccessor( )</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span> <span class="n">formula_string</span><span class="p">,</span> <span class="n">Sequence</span> <span class="p">)</span> <span class="ow">and</span> \
           <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span> <span class="n">formula_string</span><span class="p">,</span> <span class="nb">str</span> <span class="p">):</span>
            <span class="k">if</span> <span class="n">in_place</span><span class="p">:</span>
                <span class="k">for</span> <span class="n">formula</span> <span class="ow">in</span> <span class="n">formula_string</span><span class="p">:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">findMaxLag</span><span class="p">(</span> <span class="n">formula</span><span class="p">,</span> <span class="n">in_place</span><span class="o">=</span><span class="kc">True</span> <span class="p">)</span>
                <span class="k">return</span><span class="p">(</span> <span class="bp">self</span> <span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">la_find</span> <span class="o">=</span> <span class="n">deepcopy</span><span class="p">(</span> <span class="bp">self</span> <span class="p">)</span>
                <span class="k">for</span> <span class="n">formula</span> <span class="ow">in</span> <span class="n">formula_string</span><span class="p">:</span>
                    <span class="n">la_find</span> <span class="o">=</span> <span class="n">la_find</span><span class="o">.</span><span class="n">findMaxLag</span><span class="p">(</span> <span class="n">formula</span><span class="p">,</span> <span class="n">in_place</span><span class="o">=</span><span class="kc">True</span> <span class="p">)</span>
                <span class="k">return</span><span class="p">(</span> <span class="n">la_find</span> <span class="p">)</span>
        <span class="n">max_lag</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="n">mobj</span> <span class="o">=</span> <span class="n">prefixed_pat</span><span class="o">.</span><span class="n">search</span><span class="p">(</span> <span class="n">formula_string</span> <span class="p">)</span>
        <span class="k">while</span> <span class="n">mobj</span> <span class="o">!=</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">lag</span> <span class="o">=</span> <span class="n">mobj</span><span class="o">.</span><span class="n">groupdict</span><span class="p">(</span> <span class="p">)[</span><span class="s1">&#39;lag&#39;</span><span class="p">]</span>
            <span class="k">if</span> <span class="n">lag</span> <span class="ow">in</span> <span class="n">NoneSet</span><span class="p">:</span>
                <span class="n">lag</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">lag</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span> <span class="n">lag</span> <span class="p">)</span>
            <span class="n">max_lag</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span> <span class="n">max_lag</span><span class="p">,</span> <span class="n">lag</span> <span class="p">)</span>
            <span class="n">mobj</span> <span class="o">=</span> <span class="n">prefixed_pat</span><span class="o">.</span><span class="n">search</span><span class="p">(</span> <span class="n">formula_string</span><span class="p">,</span> <span class="n">mobj</span><span class="o">.</span><span class="n">start</span><span class="p">(</span> <span class="p">)</span> <span class="o">+</span> <span class="mi">1</span> <span class="p">)</span>
        <span class="n">max_lag</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span> <span class="n">max_lag</span><span class="p">,</span> <span class="n">val_if_present</span><span class="p">(</span> <span class="bp">self</span><span class="p">,</span> <span class="s1">&#39;max_lag&#39;</span><span class="p">,</span> <span class="mi">0</span> <span class="p">)</span> <span class="p">)</span>
        <span class="k">if</span> <span class="n">in_place</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">max_lag</span> <span class="o">=</span> <span class="n">max_lag</span>
            <span class="k">return</span><span class="p">(</span> <span class="bp">self</span> <span class="p">)</span>
        <span class="k">return</span><span class="p">(</span> <span class="n">laggedAccessor</span><span class="p">(</span> <span class="n">data</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="p">,</span> <span class="n">max_lag</span><span class="o">=</span><span class="n">max_lag</span> <span class="p">)</span> <span class="p">)</span></div>

    <span class="k">def</span> <span class="nf">_find_available_name</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">column_name</span><span class="p">,</span> <span class="n">lag</span> <span class="p">):</span>
        <span class="sd">&#39;&#39;&#39;(for internal use): used by .rewrite( ) to find a name for lagged</span>
<span class="sd">        columns that doesn&#39;t conflict with a column in the linked data object</span>
<span class="sd">        or any other lagged column.</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="k">def</span> <span class="nf">valid_name</span><span class="p">(</span> <span class="n">check</span> <span class="p">):</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">check</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">key_map</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">check</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">keys</span><span class="p">(</span> <span class="p">):</span>
                <span class="k">return</span><span class="p">(</span> <span class="kc">True</span> <span class="p">)</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">key_map</span> <span class="ow">and</span> \
               <span class="bp">self</span><span class="o">.</span><span class="n">key_map</span><span class="p">[</span><span class="n">check</span><span class="p">]</span> <span class="o">==</span> <span class="p">{</span><span class="s1">&#39;lag&#39;</span><span class="p">:</span> <span class="n">lag</span><span class="p">,</span>
                                       <span class="s1">&#39;column_name&#39;</span><span class="p">:</span> <span class="n">column_name</span><span class="p">}:</span>
                <span class="k">return</span><span class="p">(</span> <span class="kc">True</span> <span class="p">)</span>
            <span class="k">return</span><span class="p">(</span> <span class="kc">False</span> <span class="p">)</span>
        <span class="n">check</span> <span class="o">=</span> <span class="s1">&#39;L</span><span class="si">%d</span><span class="s1">_</span><span class="si">%s</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="n">lag</span><span class="p">,</span> <span class="n">column_name</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">valid_name</span><span class="p">(</span> <span class="n">check</span> <span class="p">):</span>
            <span class="k">return</span><span class="p">(</span> <span class="n">check</span> <span class="p">)</span>
        <span class="k">for</span> <span class="n">l</span> <span class="ow">in</span> <span class="p">[</span><span class="s1">&#39;0&#39;</span><span class="p">,</span> <span class="s1">&#39;1&#39;</span><span class="p">,</span> <span class="s1">&#39;2&#39;</span><span class="p">,</span> <span class="s1">&#39;3&#39;</span><span class="p">,</span> <span class="s1">&#39;4&#39;</span><span class="p">,</span> <span class="s1">&#39;5&#39;</span><span class="p">,</span> <span class="s1">&#39;6&#39;</span><span class="p">,</span> <span class="s1">&#39;7&#39;</span><span class="p">,</span> <span class="s1">&#39;8&#39;</span><span class="p">,</span> <span class="s1">&#39;9&#39;</span><span class="p">,</span> <span class="s1">&#39;a&#39;</span><span class="p">,</span> <span class="s1">&#39;b&#39;</span><span class="p">,</span>
                  <span class="s1">&#39;c&#39;</span><span class="p">,</span> <span class="s1">&#39;d&#39;</span><span class="p">,</span> <span class="s1">&#39;e&#39;</span><span class="p">,</span> <span class="s1">&#39;f&#39;</span><span class="p">,</span> <span class="s1">&#39;g&#39;</span><span class="p">,</span> <span class="s1">&#39;h&#39;</span><span class="p">,</span> <span class="s1">&#39;i&#39;</span><span class="p">,</span> <span class="s1">&#39;j&#39;</span><span class="p">,</span> <span class="s1">&#39;k&#39;</span><span class="p">,</span> <span class="s1">&#39;l&#39;</span><span class="p">,</span> <span class="s1">&#39;m&#39;</span><span class="p">,</span> <span class="s1">&#39;n&#39;</span><span class="p">,</span>
                  <span class="s1">&#39;o&#39;</span><span class="p">,</span> <span class="s1">&#39;p&#39;</span><span class="p">,</span> <span class="s1">&#39;q&#39;</span><span class="p">,</span> <span class="s1">&#39;r&#39;</span><span class="p">,</span> <span class="s1">&#39;s&#39;</span><span class="p">,</span> <span class="s1">&#39;t&#39;</span><span class="p">,</span> <span class="s1">&#39;u&#39;</span><span class="p">,</span> <span class="s1">&#39;v&#39;</span><span class="p">,</span> <span class="s1">&#39;w&#39;</span><span class="p">,</span> <span class="s1">&#39;x&#39;</span><span class="p">,</span> <span class="s1">&#39;y&#39;</span><span class="p">,</span> <span class="s1">&#39;z&#39;</span><span class="p">]:</span>
            <span class="n">check</span> <span class="o">=</span> <span class="s1">&#39;L</span><span class="si">%d</span><span class="s1">_</span><span class="si">%s</span><span class="s1">_</span><span class="si">%s</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="n">lag</span><span class="p">,</span> <span class="n">l</span><span class="p">,</span> <span class="n">column_name</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">valid_name</span><span class="p">(</span> <span class="n">check</span> <span class="p">):</span>
                <span class="k">return</span><span class="p">(</span> <span class="n">check</span> <span class="p">)</span>
        <span class="k">raise</span> <span class="ne">KeyError</span><span class="p">(</span> <span class="s1">&#39;Could not find an availabe column name for L</span><span class="si">%d</span><span class="s1">@</span><span class="si">%s</span><span class="s1">.&#39;</span>
                        <span class="o">%</span> <span class="p">(</span><span class="n">lag</span><span class="p">,</span> <span class="n">column_name</span><span class="p">)</span> <span class="p">)</span>

<div class="viewcode-block" id="laggedAccessor.rewrite"><a class="viewcode-back" href="../ParallelRegression.html#ParallelRegression.laggedAccessor.rewrite">[docs]</a>    <span class="k">def</span> <span class="nf">rewrite</span><span class="p">(</span> <span class="bp">self</span><span class="p">,</span> <span class="n">formula_string</span> <span class="p">):</span>
        <span class="sd">&#39;&#39;&#39;Rewrites as formula string that uses mathDict&#39;s lag notation to</span>
<span class="sd">        instead use Python variable name aliases for the lagged columns, so</span>
<span class="sd">        that the rewritten formula string can be processed by, e.g., patsy.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        (formula_string, laggedAccessor( )) tuple</span>
<span class="sd">           The rewritten formula string followed by a new laggedAccessor( )</span>
<span class="sd">           instance linked to the same data object containing the lagged column</span>
<span class="sd">           aliases.  The new laggedAccessor( ) instance&#39;s max_lag attribute is</span>
<span class="sd">           the greater of this laggedAccessor&#39;s max_lag and the maximum lag</span>
<span class="sd">           used in the formula_string.</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="n">la_rewritten</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">findMaxLag</span><span class="p">(</span> <span class="n">formula_string</span> <span class="p">)</span>
        <span class="n">la_rewritten</span><span class="o">.</span><span class="n">key_map</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span> <span class="p">)</span>
        <span class="n">mobj</span> <span class="o">=</span> <span class="n">has_prefix_pat</span><span class="o">.</span><span class="n">search</span><span class="p">(</span> <span class="n">formula_string</span> <span class="p">)</span>
        <span class="k">while</span> <span class="n">mobj</span> <span class="o">!=</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">mobj_dict</span> <span class="o">=</span> <span class="n">mobj</span><span class="o">.</span><span class="n">groupdict</span><span class="p">(</span> <span class="p">)</span>
            <span class="k">if</span> <span class="n">mobj_dict</span><span class="p">[</span><span class="s1">&#39;lag&#39;</span><span class="p">]</span> <span class="ow">in</span> <span class="n">NoneSet</span><span class="p">:</span>
                <span class="n">mobj_dict</span><span class="p">[</span><span class="s1">&#39;lag&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">mobj_dict</span><span class="p">[</span><span class="s1">&#39;lag&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span> <span class="n">mobj_dict</span><span class="p">[</span><span class="s1">&#39;lag&#39;</span><span class="p">]</span> <span class="p">)</span>
            <span class="n">new_name</span> <span class="o">=</span> <span class="n">la_rewritten</span><span class="o">.</span><span class="n">_find_available_name</span><span class="p">(</span> <span class="o">**</span><span class="n">mobj_dict</span> <span class="p">)</span>
            <span class="n">la_rewritten</span><span class="o">.</span><span class="n">key_map</span><span class="p">[</span><span class="n">new_name</span><span class="p">]</span> <span class="o">=</span> <span class="n">mobj_dict</span>
            <span class="n">formula_string</span> <span class="o">=</span> <span class="n">formula_string</span><span class="p">[:</span><span class="n">mobj</span><span class="o">.</span><span class="n">start</span><span class="p">(</span> <span class="p">)]</span> \
                             <span class="o">+</span> <span class="n">new_name</span> <span class="o">+</span> <span class="n">formula_string</span><span class="p">[</span><span class="n">mobj</span><span class="o">.</span><span class="n">end</span><span class="p">(</span> <span class="p">):]</span>
            <span class="n">mobj</span> <span class="o">=</span> <span class="n">has_prefix_pat</span><span class="o">.</span><span class="n">search</span><span class="p">(</span> <span class="n">formula_string</span><span class="p">,</span> <span class="n">mobj</span><span class="o">.</span><span class="n">start</span><span class="p">(</span> <span class="p">)</span> <span class="o">+</span> <span class="mi">1</span> <span class="p">)</span>
        <span class="n">la_rewritten</span><span class="o">.</span><span class="n">max_lag</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span> <span class="n">val_if_present</span><span class="p">(</span> <span class="n">la_rewritten</span><span class="p">,</span>
                                                    <span class="s1">&#39;max_lag&#39;</span><span class="p">,</span>
                                                    <span class="mi">0</span> <span class="p">),</span>
                                    <span class="n">val_if_present</span><span class="p">(</span> <span class="bp">self</span><span class="p">,</span>
                                                    <span class="s1">&#39;max_lag&#39;</span><span class="p">,</span>
                                                    <span class="mi">0</span> <span class="p">)</span> <span class="p">)</span>
        <span class="n">la_rewritten</span><span class="o">.</span><span class="n">dict_columns</span> <span class="o">=</span> <span class="n">get_term_vars</span><span class="p">(</span> <span class="n">formula_string</span> <span class="p">)</span>
        <span class="k">return</span><span class="p">(</span> <span class="n">formula_string</span><span class="p">,</span> <span class="n">la_rewritten</span> <span class="p">)</span></div></div>

<div class="viewcode-block" id="mathDataStore"><a class="viewcode-back" href="../ParallelRegression.html#ParallelRegression.mathDataStore">[docs]</a><span class="k">class</span> <span class="nc">mathDataStore</span><span class="p">(</span><span class="nb">dict</span><span class="p">):</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">mathDict</span><span class="o">=</span><span class="kc">None</span> <span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">mathDict</span> <span class="o">=</span> <span class="n">mathDict</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">padding</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span> <span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">key_list</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&#39;&#39;&#39;Returns the list of columns currently in this data store in sorted</span>
<span class="sd">        list form.</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="n">l</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span> <span class="bp">self</span><span class="o">.</span><span class="n">keys</span><span class="p">(</span> <span class="p">)</span> <span class="p">)</span>
        <span class="n">l</span><span class="o">.</span><span class="n">sort</span><span class="p">(</span> <span class="p">)</span>
        <span class="k">return</span><span class="p">(</span> <span class="n">l</span> <span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">padding_list</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&#39;&#39;&#39;Lists the amount of padding associated with each column in the same</span>
<span class="sd">        order as the columns are listed in mathDataStore( ).key_list.</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="n">ret</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span> <span class="p">)</span>
        <span class="k">for</span> <span class="n">key</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">key_list</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">key</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">padding</span><span class="o">.</span><span class="n">keys</span><span class="p">(</span> <span class="p">):</span>
                <span class="n">ret</span><span class="o">.</span><span class="n">append</span><span class="p">(</span> <span class="bp">self</span><span class="o">.</span><span class="n">padding</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">ret</span><span class="o">.</span><span class="n">append</span><span class="p">(</span> <span class="mi">0</span> <span class="p">)</span>
        <span class="k">return</span><span class="p">(</span> <span class="n">ret</span> <span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">rows</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&#39;&#39;&#39;Returns the number of rows that the matrix of original columns has</span>
<span class="sd">        or will have, as determined by the first column provided to</span>
<span class="sd">        mathDictMaker( ).  All subsequent columns must have the same number of</span>
<span class="sd">        rows.  Returns None before the first column is stored.</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">mathDict</span><span class="p">:</span>
            <span class="k">return</span><span class="p">(</span> <span class="bp">self</span><span class="o">.</span><span class="n">mathDict</span><span class="o">.</span><span class="n">rows</span> <span class="p">)</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span> <span class="bp">self</span> <span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">return</span><span class="p">(</span> <span class="kc">None</span> <span class="p">)</span>
        <span class="k">return</span><span class="p">(</span> <span class="nb">len</span><span class="p">(</span> <span class="bp">self</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">key_list</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span> <span class="p">)</span> <span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">max_lag</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">mathDict</span><span class="p">:</span>
            <span class="n">max_lag</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">mathDict</span><span class="o">.</span><span class="n">max_lag</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">max_lag</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">padding</span><span class="o">.</span><span class="n">items</span><span class="p">(</span> <span class="p">):</span>
            <span class="k">if</span> <span class="n">k</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">keys</span><span class="p">(</span> <span class="p">):</span>
                <span class="n">max_lag</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span> <span class="n">max_lag</span><span class="p">,</span> <span class="n">v</span> <span class="p">)</span>
        <span class="k">return</span><span class="p">(</span> <span class="n">max_lag</span> <span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">itemsize</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&#39;&#39;&#39;Returns the bytes-per-cell.  Currently hard-coded at eight bytes.&#39;&#39;&#39;</span>
        <span class="k">return</span><span class="p">(</span> <span class="n">PR_BYTESIZE</span> <span class="p">)</span>

    <span class="k">def</span> <span class="nf">__setitem__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">key</span><span class="p">,</span> <span class="n">value</span> <span class="p">):</span>
        <span class="sd">&#39;&#39;&#39;See mathDictMaker( ) documentation.&#39;&#39;&#39;</span>
        <span class="k">if</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">mathDict</span> <span class="ow">and</span> <span class="n">key</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">mathDict</span><span class="o">.</span><span class="n">_column_names</span><span class="p">)</span> <span class="ow">or</span> \
           <span class="n">key</span> <span class="o">==</span> <span class="s1">&#39;Intercept&#39;</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">KeyError</span><span class="p">(</span> <span class="s1">&#39;The shared data array already has a column named &#39;</span>
                            <span class="s1">&#39;</span><span class="si">%s</span><span class="s1">.  The shared data array cannot be modified.&#39;</span>
                            <span class="o">%</span> <span class="n">key</span> <span class="p">)</span>
        <span class="k">if</span> <span class="n">value</span> <span class="o">==</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">return</span><span class="p">(</span> <span class="bp">self</span><span class="o">.</span><span class="n">__delitem__</span><span class="p">(</span> <span class="n">key</span> <span class="p">)</span> <span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span> <span class="n">key</span><span class="p">,</span> <span class="nb">str</span> <span class="p">):</span>
            <span class="k">raise</span> <span class="ne">KeyError</span><span class="p">(</span> <span class="s1">&#39;Keys must be strings because they will be used as&#39;</span>
                            <span class="s1">&#39; column names.&#39;</span> <span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span> <span class="n">value</span><span class="p">,</span> <span class="p">(</span><span class="n">Sequence</span><span class="p">,</span> <span class="n">array</span><span class="o">.</span><span class="n">array</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">)</span> <span class="p">)</span> <span class="ow">or</span> \
           <span class="nb">isinstance</span><span class="p">(</span> <span class="n">value</span><span class="p">,</span> <span class="nb">str</span> <span class="p">):</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span> <span class="s1">&#39;All values must be non-string sequences of the &#39;</span>
                             <span class="s1">&#39;same length.&#39;</span><span class="p">,</span> <span class="nb">type</span><span class="p">(</span> <span class="n">value</span> <span class="p">)</span> <span class="p">)</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span> <span class="n">value</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="p">(</span><span class="nb">float</span><span class="p">)</span> <span class="p">):</span>
            <span class="k">for</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">value</span><span class="p">:</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span> <span class="n">v</span><span class="p">,</span> <span class="p">(</span><span class="nb">int</span><span class="p">,</span> <span class="nb">float</span><span class="p">)</span> <span class="p">):</span>
                    <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span> <span class="s1">&#39;One or more values in column </span><span class="si">%s</span><span class="s1"> is &#39;</span>
                                     <span class="s1">&#39;neither an integer nor a float.&#39;</span> <span class="o">%</span> <span class="n">key</span> <span class="p">)</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span> <span class="n">value</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="nb">int</span> <span class="p">):</span>
            <span class="k">for</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">value</span><span class="p">:</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span> <span class="n">v</span><span class="p">,</span> <span class="nb">int</span> <span class="p">):</span>
                    <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span> <span class="s1">&#39;One or more values in column </span><span class="si">%s</span><span class="s1"> is not &#39;</span>
                                     <span class="s1">&#39;an integer.&#39;</span> <span class="o">%</span> <span class="n">key</span> <span class="p">)</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span> <span class="n">value</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span> <span class="p">):</span>
            <span class="k">pass</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span> <span class="s2">&quot;All values must be ndarrays, sequences of ints, &quot;</span>
                             <span class="s2">&quot;or sequences of numbers that start with a float.&quot;</span>
                             <span class="s2">&quot;  </span><span class="si">%s</span><span class="s2"> starts with neither an int nor a float.  &quot;</span>
                             <span class="s2">&quot;&#39;</span><span class="si">%s</span><span class="s2">&#39; is a </span><span class="si">%s</span><span class="s2">.&quot;</span>
                             <span class="o">%</span> <span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="nb">str</span><span class="p">(</span> <span class="n">value</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="p">),</span> <span class="nb">type</span><span class="p">(</span> <span class="n">value</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="p">))</span> <span class="p">)</span>
        <span class="n">mobj</span> <span class="o">=</span> <span class="n">varpattern</span><span class="o">.</span><span class="n">fullmatch</span><span class="p">(</span> <span class="n">mask_brackets</span><span class="p">(</span> <span class="n">key</span> <span class="p">)</span> <span class="p">)</span>
        <span class="k">if</span> <span class="n">mobj</span> <span class="o">==</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">KeyError</span><span class="p">(</span> <span class="s2">&quot;Keys must be valid Python variable names, alone &quot;</span>
                            <span class="s2">&quot;or immediately followed by brackets.  &quot;</span>
                            <span class="s2">&quot;&#39;</span><span class="si">%s</span><span class="s2">&#39; is not.&quot;</span> <span class="o">%</span> <span class="n">key</span> <span class="p">)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">rows</span> <span class="o">==</span> <span class="kc">None</span> <span class="ow">or</span> <span class="nb">len</span><span class="p">(</span> <span class="n">value</span> <span class="p">)</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">rows</span><span class="p">:</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">mathDict</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">mathDict</span><span class="o">.</span><span class="n">_last_columns</span> <span class="o">=</span> <span class="kc">None</span>
            <span class="nb">dict</span><span class="o">.</span><span class="n">__setitem__</span><span class="p">(</span> <span class="bp">self</span><span class="p">,</span> <span class="n">key</span><span class="p">,</span> <span class="n">value</span> <span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span> <span class="s1">&#39;The sequence you are trying to add has a &#39;</span>
                              <span class="s1">&#39;different length, </span><span class="si">%d</span><span class="s1">, than existing sequence(s)&#39;</span>
                              <span class="s1">&#39;, </span><span class="si">%d</span><span class="s1">.&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="nb">len</span><span class="p">(</span> <span class="n">value</span> <span class="p">),</span> <span class="bp">self</span><span class="o">.</span><span class="n">rows</span><span class="p">),</span> <span class="n">key</span> <span class="p">)</span>

<div class="viewcode-block" id="mathDataStore.savePaddedColumn"><a class="viewcode-back" href="../ParallelRegression.html#ParallelRegression.mathDataStore.savePaddedColumn">[docs]</a>    <span class="k">def</span> <span class="nf">savePaddedColumn</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">key</span><span class="p">,</span> <span class="n">value</span><span class="p">,</span> <span class="n">padding</span><span class="o">=</span><span class="kc">None</span> <span class="p">):</span>
        <span class="sd">&#39;&#39;&#39;Stores a column that is shorter than the number of rows of other</span>
<span class="sd">        columns in this mathDataStore( ).</span>

<span class="sd">        Zeros are prepended to the column before it is store so that it is the</span>
<span class="sd">        same length as the other columns.  The number of prepended zeros is</span>
<span class="sd">        stored in self.padding so that those zeros can be treated as NAs when</span>
<span class="sd">        the column is retrieved, and yet new columns can be calculated by</span>
<span class="sd">        multiplying padded and full-length columns together without special</span>
<span class="sd">        handling of the padding zeros.</span>

<span class="sd">        Padding zeros are replaced with None when a specific row is retrieved</span>
<span class="sd">        via the mathDataStore( ).__getitem__( ) method.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        key : string</span>
<span class="sd">            Name of the column to store.</span>
<span class="sd">        value</span>
<span class="sd">            The column data.</span>
<span class="sd">        padding : int, optional</span>
<span class="sd">            If specified, then this method will skip calculating the</span>
<span class="sd">            appropriate amount of padding and pad the column by this many</span>
<span class="sd">            zeros.  mathDataStore.__setitem__( ) will raise a ValueError if the</span>
<span class="sd">            resulting padded column is not the correct length.</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="c1">## Determine length of padding</span>
        <span class="k">if</span> <span class="n">padding</span> <span class="o">==</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">padding</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">rows</span> <span class="o">-</span> <span class="nb">len</span><span class="p">(</span> <span class="n">value</span> <span class="p">)</span>
        <span class="c1">## Prepend zero-padding based on type of value</span>
        <span class="n">padded</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span> <span class="n">padding</span> <span class="p">)]</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span> <span class="n">value</span><span class="p">,</span> <span class="p">(</span><span class="nb">list</span><span class="p">,</span> <span class="n">UserList</span><span class="p">,</span> <span class="n">array</span><span class="o">.</span><span class="n">array</span><span class="p">)</span> <span class="p">):</span>
            <span class="n">padded</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span> <span class="n">value</span> <span class="p">)</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span> <span class="n">value</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span> <span class="p">):</span>
            <span class="n">padded</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span> <span class="n">padded</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">value</span><span class="o">.</span><span class="n">dtype</span> <span class="p">)</span>
            <span class="n">padded</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">(</span> <span class="p">(</span><span class="n">padded</span><span class="p">,</span> <span class="n">value</span><span class="p">)</span> <span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span> <span class="s1">&#39;Cannot add column of type </span><span class="si">%s</span><span class="s1">.&#39;</span> <span class="o">%</span> <span class="nb">type</span><span class="p">(</span> <span class="n">value</span> <span class="p">)</span> <span class="p">)</span>
        <span class="c1">## Store padded column and information on the amount of padding</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">__setitem__</span><span class="p">(</span> <span class="n">key</span><span class="p">,</span> <span class="n">padded</span> <span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">padding</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="n">padding</span></div>

    <span class="k">def</span> <span class="nf">__delitem__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">key</span> <span class="p">):</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">mathDict</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">mathDict</span><span class="o">.</span><span class="n">local_mask</span><span class="o">.</span><span class="n">discard</span><span class="p">(</span> <span class="n">key</span> <span class="p">)</span>
        <span class="k">if</span> <span class="n">key</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">padding</span><span class="p">:</span>
            <span class="k">del</span> <span class="bp">self</span><span class="o">.</span><span class="n">padding</span><span class="p">[</span><span class="n">key</span><span class="p">]</span>
        <span class="k">return</span><span class="p">(</span> <span class="nb">dict</span><span class="o">.</span><span class="n">__delitem__</span><span class="p">(</span> <span class="bp">self</span><span class="p">,</span> <span class="n">key</span> <span class="p">)</span> <span class="p">)</span>

    <span class="k">def</span> <span class="nf">__getitem__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">key</span> <span class="p">):</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span> <span class="n">key</span><span class="p">,</span> <span class="nb">str</span> <span class="p">):</span>
            <span class="k">return</span><span class="p">(</span> <span class="nb">dict</span><span class="o">.</span><span class="n">__getitem__</span><span class="p">(</span> <span class="bp">self</span><span class="p">,</span> <span class="n">key</span> <span class="p">)</span> <span class="p">)</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span> <span class="n">key</span><span class="p">,</span> <span class="nb">int</span> <span class="p">)</span> <span class="ow">and</span> <span class="n">key</span> <span class="o">&lt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">rows</span><span class="p">:</span>
            <span class="n">ret</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span> <span class="p">)</span>
            <span class="k">for</span> <span class="n">column</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">keys</span><span class="p">(</span> <span class="p">):</span>
                <span class="n">ret</span><span class="p">[</span><span class="n">column</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="p">[</span><span class="n">column</span><span class="p">][</span><span class="n">key</span><span class="p">]</span>
            <span class="k">return</span><span class="p">(</span> <span class="n">ret</span> <span class="p">)</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span> <span class="n">key</span><span class="p">,</span> <span class="nb">int</span> <span class="p">):</span>
            <span class="k">raise</span> <span class="ne">IndexError</span><span class="p">(</span> <span class="s1">&#39;Row index </span><span class="si">%d</span><span class="s1"> is out of bounds for mathDataStore&#39;</span>
                              <span class="s1">&#39;( ) with </span><span class="si">%d</span><span class="s1"> rows.&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">rows</span><span class="p">)</span> <span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span> <span class="s1">&#39;mathDataStore( ) supports string indexes &#39;</span>
                             <span class="s1">&#39;referring to column names, and integer indexes &#39;</span>
                             <span class="s1">&#39;referring to row numbers.  It does not support &#39;</span>
                             <span class="s1">&#39;</span><span class="si">%s</span><span class="s1">.&#39;</span> <span class="o">%</span> <span class="nb">type</span><span class="p">(</span> <span class="n">key</span> <span class="p">)</span> <span class="p">)</span>

    <span class="k">def</span> <span class="nf">_toNDArray</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">key</span><span class="p">,</span> <span class="n">lag</span><span class="o">=</span><span class="s1">&#39;cheat&#39;</span> <span class="p">):</span>
        <span class="c1">## currently only used in mathDataStore( ).get_column( ).</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span> <span class="bp">self</span><span class="p">[</span><span class="n">key</span><span class="p">][</span><span class="mi">0</span><span class="p">],</span> <span class="nb">int</span> <span class="p">):</span>
            <span class="n">column_datatype</span> <span class="o">=</span> <span class="n">PR_NP_INT</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">column_datatype</span> <span class="o">=</span> <span class="n">PR_NP_FLT</span>
        <span class="n">ret</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span> <span class="bp">self</span><span class="p">[</span><span class="n">key</span><span class="p">],</span> <span class="n">column_datatype</span> <span class="p">)</span>
        <span class="k">return</span><span class="p">(</span> <span class="n">ret</span> <span class="p">)</span>

    <span class="k">def</span> <span class="nf">_toBytes</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">key</span><span class="p">,</span> <span class="n">lag</span><span class="o">=</span><span class="s1">&#39;cheat&#39;</span> <span class="p">):</span>
        <span class="c1">## currently only used in mathDict( )._vec( )</span>
        <span class="c1">## and once in mathDictMaker.make( ).</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span> <span class="bp">self</span><span class="p">[</span><span class="n">key</span><span class="p">][</span><span class="mi">0</span><span class="p">],</span> <span class="nb">int</span> <span class="p">):</span>
            <span class="n">column_datatype</span> <span class="o">=</span> <span class="n">PR_PY_INT</span>
            <span class="n">np_datatype</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">dtype</span><span class="p">(</span> <span class="n">PR_NP_INT</span> <span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">column_datatype</span> <span class="o">=</span> <span class="n">PR_PY_FLT</span>
            <span class="n">np_datatype</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">dtype</span><span class="p">(</span> <span class="n">PR_NP_FLT</span> <span class="p">)</span>
        <span class="n">ret</span> <span class="o">=</span> <span class="n">array</span><span class="o">.</span><span class="n">array</span><span class="p">(</span> <span class="n">column_datatype</span><span class="p">,</span> <span class="bp">self</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="p">)</span><span class="o">.</span><span class="n">tobytes</span><span class="p">(</span> <span class="p">)</span>
        <span class="k">if</span> <span class="n">lag</span> <span class="o">!=</span> <span class="s1">&#39;cheat&#39;</span><span class="p">:</span>
            <span class="n">ret</span> <span class="o">=</span> <span class="n">ret</span><span class="p">[(</span><span class="bp">self</span><span class="o">.</span><span class="n">max_lag</span> <span class="o">-</span> <span class="n">lag</span><span class="p">)</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">itemsize</span>
                      <span class="p">:</span><span class="nb">len</span><span class="p">(</span> <span class="n">ret</span> <span class="p">)</span> <span class="o">-</span> <span class="n">lag</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">itemsize</span><span class="p">]</span>
        <span class="k">return</span><span class="p">(</span> <span class="n">ret</span><span class="p">,</span> <span class="n">np_datatype</span> <span class="p">)</span>

    <span class="k">def</span> <span class="nf">get_column</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">column_name</span><span class="p">,</span> <span class="n">lag</span><span class="o">=</span><span class="mi">0</span> <span class="p">):</span>
        <span class="c1"># Currently only used in mathDataStore( )&#39;s interaction matrix methods</span>
        <span class="c1"># to retrieve an NDArray without knowing if the column is local or not.</span>
        <span class="k">if</span> <span class="n">column_name</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">keys</span><span class="p">(</span> <span class="p">):</span>
            <span class="n">ret</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_toNDArray</span><span class="p">(</span> <span class="n">column_name</span> <span class="p">)</span>
            <span class="k">if</span> <span class="n">lag</span> <span class="o">!=</span> <span class="s1">&#39;cheat&#39;</span><span class="p">:</span>
                <span class="n">ret</span> <span class="o">=</span> <span class="n">ret</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">max_lag</span> <span class="o">-</span> <span class="n">lag</span><span class="p">:</span><span class="nb">len</span><span class="p">(</span> <span class="n">ret</span> <span class="p">)</span> <span class="o">-</span> <span class="n">lag</span><span class="p">]</span>
            <span class="k">return</span><span class="p">(</span> <span class="n">ret</span> <span class="p">)</span>
        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">mathDict</span> <span class="o">!=</span> <span class="kc">None</span> <span class="ow">and</span> \
             <span class="n">column_name</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">mathDict</span><span class="o">.</span><span class="n">_column_names</span><span class="p">:</span>
            <span class="k">return</span><span class="p">(</span> <span class="bp">self</span><span class="o">.</span><span class="n">mathDict</span><span class="o">.</span><span class="n">get_column</span><span class="p">(</span> <span class="n">column_name</span><span class="p">,</span>
                                              <span class="n">lag</span><span class="p">,</span>
                                              <span class="n">vector</span><span class="o">=</span><span class="s1">&#39;row&#39;</span> <span class="p">)</span> <span class="p">)</span>
        <span class="k">raise</span> <span class="n">mathDictKeyError</span><span class="p">(</span> <span class="s1">&#39;</span><span class="si">%s</span><span class="s1"> is not a valid column name.&#39;</span>
                                <span class="o">%</span> <span class="n">column_name</span> <span class="p">)</span>

    <span class="k">def</span> <span class="nf">_bins</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">column_names</span> <span class="p">):</span>
        <span class="sd">&#39;&#39;&#39;(for internal use): used exclusively by .interactions_matrix( ) to</span>
<span class="sd">        convert dummy term columns with any two arbitrary values into a column</span>
<span class="sd">        of integer values 0 and 1.</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="n">ret</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span> <span class="p">)</span>
        <span class="k">for</span> <span class="n">col</span> <span class="ow">in</span> <span class="n">column_names</span><span class="p">:</span>
            <span class="n">bn</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_column</span><span class="p">(</span> <span class="n">col</span><span class="p">,</span> <span class="n">lag</span><span class="o">=</span><span class="s1">&#39;cheat&#39;</span> <span class="p">)</span>
            <span class="n">values</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span> <span class="n">bn</span> <span class="p">)</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span> <span class="n">values</span> <span class="p">)</span> <span class="o">!=</span> <span class="mi">2</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span> <span class="s1">&#39;Cannot treat </span><span class="si">%s</span><span class="s1"> as a binary column.  It &#39;</span>
                                <span class="s1">&#39;does not contain exactly two unique values.&#39;</span> <span class="p">)</span>
            <span class="n">one</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span> <span class="n">values</span> <span class="p">)</span>
            <span class="n">bnList</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span> <span class="p">)</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">bn</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">i</span> <span class="o">==</span> <span class="n">one</span><span class="p">:</span>
                    <span class="n">bnList</span><span class="o">.</span><span class="n">append</span><span class="p">(</span> <span class="mi">1</span> <span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">bnList</span><span class="o">.</span><span class="n">append</span><span class="p">(</span> <span class="mi">0</span> <span class="p">)</span>
            <span class="n">bn</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span> <span class="n">bnList</span><span class="p">,</span> <span class="n">PR_NP_INT</span> <span class="p">)</span>
            <span class="n">ret</span><span class="o">.</span><span class="n">append</span><span class="p">(</span> <span class="n">bn</span> <span class="p">)</span>
        <span class="n">ret</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">stack</span><span class="p">(</span> <span class="n">ret</span><span class="p">,</span> <span class="mi">1</span> <span class="p">)</span>
        <span class="k">return</span><span class="p">(</span> <span class="n">ret</span> <span class="p">)</span>

<div class="viewcode-block" id="mathDataStore.interactions_matrix"><a class="viewcode-back" href="../ParallelRegression.html#ParallelRegression.mathDataStore.interactions_matrix">[docs]</a>    <span class="k">def</span> <span class="nf">interactions_matrix</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">binary_columns</span><span class="p">,</span> <span class="n">interact_with</span><span class="o">=</span><span class="kc">None</span> <span class="p">):</span>
        <span class="sd">&#39;&#39;&#39;(for internal use): calculates the columns representing the</span>
<span class="sd">        interactions between one-or-more dummy terms, alone or with one non-</span>
<span class="sd">        dummy term.</span>

<span class="sd">        This method returns nothing.  The results are stored as columns in the</span>
<span class="sd">        data store.  If this mathDataStore( ) is linked to a mathDict( ), then</span>
<span class="sd">        it informs the mathDict( ) that the interaction matrix for this set of</span>
<span class="sd">        columns has been calculated and stored locally by appending the colon-</span>
<span class="sd">        separated list of terms as a single string to</span>
<span class="sd">        mathDict( ).local_calculated.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        binary_columns : sequence of strings</span>
<span class="sd">            Strings identifying the columns to be used as dummy terms.</span>
<span class="sd">        interact_with : string</span>
<span class="sd">            String identifying the column for the dummy terms to interact with.</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="n">binary_columns</span><span class="o">.</span><span class="n">sort</span><span class="p">(</span> <span class="p">)</span>                <span class="c1"># Obtains binary_columns as</span>
        <span class="n">bins</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_bins</span><span class="p">(</span> <span class="n">binary_columns</span> <span class="p">)</span>   <span class="c1"># columns of integers 0 and 1.</span>
        <span class="k">if</span> <span class="n">interact_with</span> <span class="o">!=</span> <span class="kc">None</span><span class="p">:</span>             <span class="c1"># Obtains the non-dummy term</span>
            <span class="k">if</span> <span class="n">interact_with</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">keys</span><span class="p">(</span> <span class="p">):</span> <span class="c1"># whether local or shared.</span>
                <span class="n">intr</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_column</span><span class="p">(</span> <span class="n">interact_with</span><span class="p">,</span> <span class="n">lag</span><span class="o">=</span><span class="s1">&#39;cheat&#39;</span> <span class="p">)</span>
            <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">mathDict</span> <span class="o">!=</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">intr</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">mathDict</span><span class="o">.</span><span class="n">__getitem__</span><span class="p">(</span> <span class="n">interact_with</span><span class="p">,</span>
                                                  <span class="n">lag</span><span class="o">=</span><span class="s1">&#39;cheat&#39;</span><span class="p">,</span>
                                                  <span class="n">vector</span><span class="o">=</span><span class="s1">&#39;row&#39;</span> <span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">mathDictKeyError</span><span class="p">(</span> <span class="s1">&#39;</span><span class="si">%s</span><span class="s1"> is not a valid column string for use in &#39;</span>
                                  <span class="s1">&#39;an interactions matrix.&#39;</span> <span class="o">%</span> <span class="n">interact_with</span> <span class="p">)</span>
            <span class="n">intr</span> <span class="o">=</span> <span class="n">intr</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span> <span class="bp">self</span><span class="o">.</span><span class="n">rows</span> <span class="p">)</span>
            <span class="n">dt</span> <span class="o">=</span> <span class="n">intr</span><span class="o">.</span><span class="n">dtype</span>
        <span class="k">else</span><span class="p">:</span>                                 <span class="c1"># Creates a column of integer 1s</span>
            <span class="n">dt</span> <span class="o">=</span> <span class="n">PR_NP_INT</span>                    <span class="c1"># to use in place of the non-</span>
            <span class="n">intr</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span> <span class="bp">self</span><span class="o">.</span><span class="n">rows</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">dt</span> <span class="p">)</span> <span class="c1"># dummy term if there isn&#39;t a</span>
                                              <span class="c1"># non-dummy term.</span>
        <span class="n">r</span><span class="p">,</span> <span class="n">c</span> <span class="o">=</span> <span class="n">bins</span><span class="o">.</span><span class="n">shape</span>
        <span class="n">binInts</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span> <span class="n">r</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">PR_NP_INT</span> <span class="p">)</span>  <span class="c1"># Turns each row into an int</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span> <span class="n">r</span> <span class="p">):</span>                  <span class="c1"># representing the unique combi-</span>
            <span class="n">s</span> <span class="o">=</span> <span class="p">[</span><span class="nb">str</span><span class="p">(</span> <span class="n">j</span> <span class="p">)</span> <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="n">bins</span><span class="p">[</span><span class="n">i</span><span class="p">,:]]</span> <span class="c1"># nation of dummy categories by</span>
            <span class="n">s</span> <span class="o">=</span> <span class="nb">str</span><span class="p">(</span> <span class="s1">&#39;&#39;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span> <span class="n">s</span> <span class="p">)</span> <span class="p">)</span>           <span class="c1"># reading the 0 &amp; 1 values as a</span>
            <span class="n">binInts</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span> <span class="n">s</span><span class="p">,</span> <span class="mi">2</span> <span class="p">)</span>          <span class="c1"># single base 2 number.</span>
        <span class="n">c2</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span> <span class="n">binInts</span> <span class="p">)</span>
        <span class="n">col_names</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span> <span class="p">)</span>                   <span class="c1"># Generate the list of strings</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span> <span class="mi">1</span><span class="p">,</span> <span class="n">c2</span> <span class="o">+</span> <span class="mi">1</span> <span class="p">):</span>          <span class="c1"># identifying the columns in this</span>
            <span class="n">bn</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span> <span class="n">binary_columns</span> <span class="p">)</span>        <span class="c1"># interactions matrix.</span>
            <span class="n">bn</span> <span class="o">=</span> <span class="s1">&#39;{0:0&#39;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span> <span class="n">bn</span> <span class="p">)</span> <span class="o">+</span> <span class="s1">&#39;b}&#39;</span>
            <span class="n">bn</span> <span class="o">=</span> <span class="n">bn</span><span class="o">.</span><span class="n">format</span><span class="p">(</span> <span class="n">i</span> <span class="p">)</span>
            <span class="n">col_name</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span> <span class="p">)</span>
            <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span> <span class="n">c</span> <span class="p">):</span>
                <span class="n">col_name</span><span class="o">.</span><span class="n">append</span><span class="p">(</span> <span class="s1">&#39;</span><span class="si">%s</span><span class="s1">=</span><span class="si">%s</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="n">binary_columns</span><span class="p">[</span><span class="n">j</span><span class="p">],</span> <span class="n">bn</span><span class="p">[</span><span class="n">j</span><span class="p">])</span> <span class="p">)</span>
            <span class="k">if</span> <span class="n">interact_with</span><span class="p">:</span>
                <span class="n">col_name</span><span class="o">.</span><span class="n">append</span><span class="p">(</span> <span class="n">interact_with</span> <span class="p">)</span>
            <span class="n">col_names</span><span class="o">.</span><span class="n">append</span><span class="p">(</span> <span class="s1">&#39;(&#39;</span> <span class="o">+</span> <span class="s1">&#39;:&#39;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span> <span class="n">col_name</span> <span class="p">)</span> <span class="o">+</span> <span class="s1">&#39;)&#39;</span> <span class="p">)</span>
        <span class="c1">#######################################################################</span>
        <span class="c1">## Each column is created as a numpy array of zeros in the list of    #</span>
        <span class="c1">## columns named `ret`.  The first for loop flips only the one column #</span>
        <span class="c1">## representing the combination of dummy categories matching that row #</span>
        <span class="c1">## from 0 to 1.  Then each column numpy array is multiplied by the    #</span>
        <span class="c1">## interact_with column.                                              #</span>
        <span class="n">ret</span> <span class="o">=</span> <span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span> <span class="n">r</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">dt</span> <span class="p">)</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span> <span class="n">c2</span> <span class="p">)]</span>                 <span class="c1">##</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span> <span class="n">r</span> <span class="p">):</span>                                                 <span class="c1">##</span>
            <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span> <span class="n">c2</span> <span class="p">):</span>                                            <span class="c1">##</span>
                <span class="k">if</span> <span class="n">binInts</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">==</span> <span class="p">(</span> <span class="n">j</span> <span class="o">+</span> <span class="mi">1</span> <span class="p">):</span>                                  <span class="c1">##</span>
                    <span class="n">ret</span><span class="p">[</span><span class="n">j</span><span class="p">][</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>                                            <span class="c1">##</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span> <span class="nb">len</span><span class="p">(</span> <span class="n">ret</span> <span class="p">)</span> <span class="p">):</span>          <span class="c1"># Always multiplying by intr  ##</span>
            <span class="bp">self</span><span class="p">[</span><span class="n">col_names</span><span class="p">[</span><span class="n">i</span><span class="p">]]</span> <span class="o">=</span> <span class="n">ret</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">*</span> <span class="n">intr</span> <span class="c1"># Keeps the code simple.      ##</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">mathDict</span> <span class="o">!=</span> <span class="kc">None</span><span class="p">:</span> <span class="c1">#................. mathDict( ) needs to know</span>
            <span class="n">calculated</span> <span class="o">=</span> <span class="n">binary_columns</span><span class="p">[:]</span>         <span class="c1"># so that these locally-</span>
            <span class="k">if</span> <span class="n">interact_with</span> <span class="o">!=</span> <span class="kc">None</span><span class="p">:</span>              <span class="c1"># stored calculated columns</span>
                <span class="n">calculated</span><span class="o">.</span><span class="n">append</span><span class="p">(</span> <span class="n">interact_with</span> <span class="p">)</span> <span class="c1"># can be rebuilt if the</span>
            <span class="n">calculated</span> <span class="o">=</span> <span class="s1">&#39;:&#39;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span> <span class="n">calculated</span> <span class="p">)</span>    <span class="c1"># mathDict( ) is rebuilt.</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">mathDict</span><span class="o">.</span><span class="n">local_calculated</span><span class="o">.</span><span class="n">append</span><span class="p">(</span> <span class="n">calculated</span> <span class="p">)</span></div>

    <span class="k">def</span> <span class="nf">_inter_col_terms</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">index</span><span class="p">,</span> <span class="n">masked_index</span> <span class="p">):</span>
        <span class="sd">&#39;&#39;&#39;(for internal use): reads a masked, colon-separated list of values</span>
<span class="sd">        as terms and determines which one value is not a dummy term.</span>

<span class="sd">        Takes the original and masked strings as inputs because it is only used</span>
<span class="sd">        in situations where the masked string has already been generated.</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">mathDict</span> <span class="o">!=</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">tSet</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">mathDict</span><span class="o">.</span><span class="n">terms</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">tSet</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">terms</span>
        <span class="n">terms</span> <span class="o">=</span> <span class="n">masked_split</span><span class="p">(</span> <span class="n">index</span><span class="p">,</span> <span class="n">masked_index</span><span class="p">,</span> <span class="s1">&#39;:&#39;</span> <span class="p">)</span>
        <span class="n">real_term</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="n">wSet</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span> <span class="n">tSet</span><span class="o">.</span><span class="n">W_termRep_set</span> <span class="p">)</span>          <span class="c1"># Retrieving and converting</span>
        <span class="n">dSet</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span> <span class="n">tSet</span><span class="o">.</span><span class="n">dummy_termRep_set</span> <span class="p">)</span>      <span class="c1"># these to sets before the</span>
        <span class="k">for</span> <span class="n">t</span> <span class="ow">in</span> <span class="n">terms</span><span class="p">:</span>                           <span class="c1"># loop substantially improves</span>
            <span class="k">if</span> <span class="n">t</span> <span class="ow">in</span> <span class="n">wSet</span><span class="p">:</span>                         <span class="c1"># performance.</span>
                <span class="n">d</span> <span class="o">=</span> <span class="n">t</span> <span class="ow">in</span> <span class="n">dSet</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">t</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">keys</span><span class="p">(</span> <span class="p">):</span>
                    <span class="n">bn</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_column</span><span class="p">(</span> <span class="n">t</span> <span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">bn</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">mathDict</span><span class="o">.</span><span class="n">get_column</span><span class="p">(</span> <span class="n">t</span><span class="p">,</span> <span class="n">vector</span><span class="o">=</span><span class="s1">&#39;row&#39;</span> <span class="p">)</span>
                <span class="n">values</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span> <span class="n">bn</span> <span class="p">)</span>
                <span class="n">d</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span> <span class="n">values</span> <span class="p">)</span> <span class="o">==</span> <span class="mi">2</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">d</span> <span class="ow">and</span> <span class="n">real_term</span> <span class="o">==</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">real_term</span> <span class="o">=</span> <span class="n">t</span>
                <span class="n">terms</span><span class="o">.</span><span class="n">remove</span><span class="p">(</span> <span class="n">t</span> <span class="p">)</span>
            <span class="k">elif</span> <span class="ow">not</span> <span class="n">d</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span> <span class="s1">&#39;`</span><span class="si">%s</span><span class="s1">` contains more than one non-dummy term.&#39;</span>
                                  <span class="s1">&#39;  This is not currently supported.&#39;</span> <span class="o">%</span> <span class="n">item</span> <span class="p">)</span>
        <span class="n">terms</span><span class="o">.</span><span class="n">sort</span><span class="p">(</span> <span class="p">)</span>
        <span class="k">return</span><span class="p">(</span> <span class="n">terms</span><span class="p">,</span> <span class="n">real_term</span> <span class="p">)</span></div>

<div class="viewcode-block" id="mathDictMaker"><a class="viewcode-back" href="../ParallelRegression.html#ParallelRegression.mathDictMaker">[docs]</a><span class="k">class</span> <span class="nc">mathDictMaker</span><span class="p">(</span><span class="n">mathDataStore</span><span class="p">):</span>
    <span class="sd">&#39;&#39;&#39;To provide a column for inclusion in the matrix of original columns,</span>
<span class="sd">    simply add it as if adding to a dict( ).</span>

<span class="sd">    The following describes setting a column via `mathDictMaker[key] = value`.</span>

<span class="sd">    Error checking is relatively thorough because this is intended for use</span>
<span class="sd">    while setting up a large batch of calculations that might take a long time</span>
<span class="sd">    to perform, and mistakes might not otherwise be caught until after-the-</span>
<span class="sd">    fact.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    key : str</span>
<span class="sd">        The key is used as the column name, and must either be a valid Python</span>
<span class="sd">        variable name, or be a valid Python variable name immediately followed</span>
<span class="sd">        by brackets.  The string enclosed in the brackets is not restricted.</span>
<span class="sd">    value : sequence of numerical values</span>
<span class="sd">        The sequence represents the column cells.  The data type for the column</span>
<span class="sd">        is determined by the first value in the sequence, so if the first value</span>
<span class="sd">        is a float then all values will be treated as floats.  If the first</span>
<span class="sd">        value is an integer, than all values must be integers.</span>

<span class="sd">    Raises</span>
<span class="sd">    ------</span>
<span class="sd">    TypeError</span>
<span class="sd">        If the value is not a sequence, or if the value is a string.</span>
<span class="sd">        If the first item in the sequence is an integer but one or more</span>
<span class="sd">        subsequent values is not.</span>
<span class="sd">        If the first item in the sequence is a float but one or more subsequent</span>
<span class="sd">        values is neither an integer nor a float.</span>
<span class="sd">        If the first item in the sequence is neither a float nor an integer.</span>
<span class="sd">    KeyError</span>
<span class="sd">        If the key is not a string.</span>
<span class="sd">        If the key is a string but is not a valid Python variable name.</span>
<span class="sd">    ValueError</span>
<span class="sd">        If the length of the sequence does not match the length of the existing</span>
<span class="sd">        column(s).</span>
<span class="sd">    &#39;&#39;&#39;</span>
    <span class="k">def</span> <span class="nf">_crossproducts</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&#39;&#39;&#39;(for internal use): Pre-calculates the crossproducts of all columns.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        RA_length : int</span>
<span class="sd">            Length of space, in bytes, needed in the shared data array to store</span>
<span class="sd">            the pre-calculated crossproducts.</span>
<span class="sd">        RA : multiprocessing.sharedctypes.RawArray of bytes</span>
<span class="sd">            Sequence of bytes consisting of the pre-calculated crossproduct</span>
<span class="sd">            columns to be stored in the shared data array.</span>
<span class="sd">        cp_dtypes : list of numpy dtype strings</span>
<span class="sd">            Data types of the pre-calculated crossproduct columns.</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="n">cp_count</span> <span class="o">=</span> <span class="n">math</span><span class="o">.</span><span class="n">factorial</span><span class="p">(</span> <span class="nb">len</span><span class="p">(</span> <span class="bp">self</span> <span class="p">)</span> <span class="p">)</span> \
                   <span class="o">//</span> <span class="mi">2</span> \
                   <span class="o">//</span> <span class="n">math</span><span class="o">.</span><span class="n">factorial</span><span class="p">(</span> <span class="nb">len</span><span class="p">(</span> <span class="bp">self</span> <span class="p">)</span> <span class="o">-</span> <span class="mi">2</span> <span class="p">)</span>
        <span class="n">indices</span> <span class="o">=</span> <span class="p">[</span><span class="n">i</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span> <span class="nb">len</span><span class="p">(</span> <span class="bp">self</span> <span class="p">)</span> <span class="p">)]</span>
        <span class="n">indices</span> <span class="o">=</span> <span class="p">[</span><span class="n">i</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">itertools</span><span class="o">.</span><span class="n">combinations</span><span class="p">(</span> <span class="n">indices</span><span class="p">,</span> <span class="mi">2</span> <span class="p">)]</span>
        <span class="n">RA_length</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">rows</span><span class="o">*</span><span class="n">cp_count</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">itemsize</span>
        <span class="n">RA</span> <span class="o">=</span> <span class="n">sharedctypes</span><span class="o">.</span><span class="n">RawArray</span><span class="p">(</span> <span class="s1">&#39;b&#39;</span><span class="p">,</span> <span class="n">RA_length</span> <span class="p">)</span>
        <span class="n">cp_dtypes</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span> <span class="p">)</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span> <span class="n">cp_count</span> <span class="p">):</span>
            <span class="n">a</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">rows</span><span class="o">*</span><span class="n">i</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">itemsize</span>
            <span class="n">t</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">rows</span><span class="o">*</span><span class="p">(</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">itemsize</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span> <span class="bp">self</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">key_list</span><span class="p">[</span><span class="n">indices</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">0</span><span class="p">]]][</span><span class="mi">0</span><span class="p">],</span> <span class="nb">float</span> <span class="p">)</span> <span class="ow">or</span> \
               <span class="nb">isinstance</span><span class="p">(</span> <span class="bp">self</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">key_list</span><span class="p">[</span><span class="n">indices</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">1</span><span class="p">]]][</span><span class="mi">0</span><span class="p">],</span> <span class="nb">float</span> <span class="p">):</span>
                <span class="n">dt</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">dtype</span><span class="p">(</span> <span class="n">PR_NP_FLT</span> <span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">dt</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">dtype</span><span class="p">(</span> <span class="n">PR_NP_INT</span> <span class="p">)</span>
            <span class="n">arr</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span> <span class="bp">self</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">key_list</span><span class="p">[</span><span class="n">indices</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">0</span><span class="p">]]],</span> <span class="n">dtype</span><span class="o">=</span><span class="n">dt</span> <span class="p">)</span> \
                <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span> <span class="bp">self</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">key_list</span><span class="p">[</span><span class="n">indices</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">1</span><span class="p">]]],</span> <span class="n">dtype</span><span class="o">=</span><span class="n">dt</span> <span class="p">)</span>
            <span class="n">RA</span><span class="p">[</span><span class="n">a</span><span class="p">:</span><span class="n">t</span><span class="p">]</span> <span class="o">=</span> <span class="n">arr</span><span class="o">.</span><span class="n">tobytes</span><span class="p">(</span> <span class="p">)</span>
            <span class="n">cp_dtypes</span><span class="o">.</span><span class="n">append</span><span class="p">(</span> <span class="n">dt</span> <span class="p">)</span>
        <span class="k">return</span><span class="p">(</span> <span class="n">RA_length</span><span class="p">,</span> <span class="n">RA</span><span class="p">,</span> <span class="n">cp_dtypes</span> <span class="p">)</span>

    <span class="k">def</span> <span class="nf">_powers</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">powers</span> <span class="p">):</span>
        <span class="sd">&#39;&#39;&#39;(for internal use): Pre-calculates powers two through `powers` of</span>
<span class="sd">        all columns.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        RA_length : int</span>
<span class="sd">            Length of space, in bytes, needed in the shared data array to store</span>
<span class="sd">            the pre-calculated column powers.</span>
<span class="sd">        RA : multiprocessing.sharedctypes.RawArray of bytes</span>
<span class="sd">            Sequence of bytes consisting of the pre-calculated column powers to</span>
<span class="sd">            be stored in the shared data array.</span>
<span class="sd">        pwr_dtypes : list of numpy dtype strings</span>
<span class="sd">            Data types of the columns of pre-calculated columns.</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="n">RA_length</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">rows</span><span class="o">*</span><span class="nb">len</span><span class="p">(</span> <span class="bp">self</span> <span class="p">)</span><span class="o">*</span><span class="p">(</span> <span class="n">powers</span> <span class="o">-</span> <span class="mi">1</span> <span class="p">)</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">itemsize</span>
        <span class="n">RA</span> <span class="o">=</span> <span class="n">sharedctypes</span><span class="o">.</span><span class="n">RawArray</span><span class="p">(</span> <span class="s1">&#39;b&#39;</span><span class="p">,</span> <span class="n">RA_length</span> <span class="p">)</span>
        <span class="n">pwr_dtypes</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span> <span class="p">)</span>
        <span class="k">for</span> <span class="n">pwr</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span> <span class="n">powers</span> <span class="o">-</span> <span class="mi">1</span> <span class="p">):</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span> <span class="nb">len</span><span class="p">(</span> <span class="bp">self</span> <span class="p">)</span> <span class="p">):</span>
                <span class="n">a</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">rows</span><span class="o">*</span><span class="n">pwr</span><span class="o">*</span><span class="nb">len</span><span class="p">(</span> <span class="bp">self</span><span class="o">.</span><span class="n">key_list</span> <span class="p">)</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">itemsize</span>
                <span class="n">a</span> <span class="o">+=</span> <span class="bp">self</span><span class="o">.</span><span class="n">rows</span><span class="o">*</span><span class="n">i</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">itemsize</span>
                <span class="n">t</span> <span class="o">=</span> <span class="n">a</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">rows</span><span class="o">*</span><span class="mi">1</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">itemsize</span>
                <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span> <span class="bp">self</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">key_list</span><span class="p">[</span><span class="n">i</span><span class="p">]][</span><span class="mi">0</span><span class="p">],</span> <span class="nb">float</span> <span class="p">):</span>
                    <span class="n">dt</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">dtype</span><span class="p">(</span> <span class="n">PR_NP_FLT</span> <span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">dt</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">dtype</span><span class="p">(</span> <span class="n">PR_NP_INT</span> <span class="p">)</span>
                <span class="n">arr</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span> <span class="bp">self</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">key_list</span><span class="p">[</span><span class="n">i</span><span class="p">]],</span> <span class="n">dtype</span><span class="o">=</span><span class="n">dt</span> <span class="p">)</span> \
                      <span class="o">**</span> <span class="p">(</span><span class="n">pwr</span> <span class="o">+</span> <span class="mi">2</span><span class="p">)</span>
                <span class="n">RA</span><span class="p">[</span><span class="n">a</span><span class="p">:</span><span class="n">t</span><span class="p">]</span> <span class="o">=</span> <span class="n">arr</span><span class="o">.</span><span class="n">tobytes</span><span class="p">(</span> <span class="p">)</span>
                <span class="n">pwr_dtypes</span><span class="o">.</span><span class="n">append</span><span class="p">(</span> <span class="n">dt</span> <span class="p">)</span>
        <span class="k">return</span><span class="p">(</span> <span class="n">RA_length</span><span class="p">,</span> <span class="n">RA</span><span class="p">,</span> <span class="n">pwr_dtypes</span> <span class="p">)</span>

<div class="viewcode-block" id="mathDictMaker.make"><a class="viewcode-back" href="../ParallelRegression.html#ParallelRegression.mathDictMaker.make">[docs]</a>    <span class="k">def</span> <span class="nf">make</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">cache_crossproducts</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">cache_powers</span><span class="o">=</span><span class="mi">1</span> <span class="p">):</span>
        <span class="sd">&#39;&#39;&#39;Assembles the shared data array and mathDict( ) matrix</span>
<span class="sd">        representation.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        cache_crossproducts : boolean, optional</span>
<span class="sd">            If True, then the crossproducts of all combinations of columns</span>
<span class="sd">            (without replacement) will be pre-calculated and stored along with</span>
<span class="sd">            the matrix of original columns.  To pre-calculate the product of a</span>
<span class="sd">            column and itself, set cache_powers to a number greater than or</span>
<span class="sd">            equal to two.</span>
<span class="sd">        cache_powers : int, optional</span>
<span class="sd">            If an integer greater than one, then powers of all columns from two</span>
<span class="sd">            to this number will be pre-calculated and stored with the matrix of</span>
<span class="sd">            original columns.  Numbers less than or equal to one will be</span>
<span class="sd">            ignored.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        RA : multiprocessing.sharedctypes.RawArray</span>
<span class="sd">            The shared data array in which the matrix of original columns and</span>
<span class="sd">            any pre-calculated columns will be stored.</span>
<span class="sd">        MD : mathDict( )</span>
<span class="sd">            The mathDict( ) representation of a matrix initially consisting of</span>
<span class="sd">            the same columns as the matrix of original columns.  The</span>
<span class="sd">            mathDict( ) object can then be used to mask some columns and/or</span>
<span class="sd">            append calculated columns to the matrix represented by the</span>
<span class="sd">            mathDict( ).  Local columns can then be appended to copies of the</span>
<span class="sd">            mathDict( ) object in other processes.</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="n">RA_length</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">rows</span><span class="o">*</span><span class="nb">len</span><span class="p">(</span> <span class="bp">self</span> <span class="p">)</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">itemsize</span>
        <span class="k">if</span> <span class="n">cache_crossproducts</span><span class="p">:</span>
            <span class="n">cp_ra_len</span><span class="p">,</span> <span class="n">CP</span><span class="p">,</span> <span class="n">cp_dtypes</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_crossproducts</span><span class="p">(</span> <span class="p">)</span>
            <span class="n">RA_length</span> <span class="o">+=</span> <span class="n">cp_ra_len</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">cp_ra_len</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">if</span> <span class="n">cache_powers</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">pwr_ra_len</span><span class="p">,</span> <span class="n">PWR</span><span class="p">,</span> <span class="n">pwr_dtypes</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_powers</span><span class="p">(</span> <span class="n">cache_powers</span> <span class="p">)</span>
            <span class="n">RA_length</span> <span class="o">+=</span> <span class="n">pwr_ra_len</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">pwr_ra_len</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="n">RA</span> <span class="o">=</span> <span class="n">sharedctypes</span><span class="o">.</span><span class="n">RawArray</span><span class="p">(</span> <span class="s1">&#39;b&#39;</span><span class="p">,</span> <span class="n">RA_length</span> <span class="p">)</span>
        <span class="n">dtypes</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span> <span class="p">)</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span> <span class="nb">len</span><span class="p">(</span> <span class="bp">self</span> <span class="p">)</span> <span class="p">):</span>
            <span class="n">a</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">rows</span><span class="o">*</span><span class="n">i</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">itemsize</span>
            <span class="n">t</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">rows</span><span class="o">*</span><span class="p">(</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">itemsize</span>
            <span class="n">RA</span><span class="p">[</span><span class="n">a</span><span class="p">:</span><span class="n">t</span><span class="p">],</span> <span class="n">dt_np</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_toBytes</span><span class="p">(</span> <span class="bp">self</span><span class="o">.</span><span class="n">key_list</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="p">)</span>
            <span class="n">dtypes</span><span class="o">.</span><span class="n">append</span><span class="p">(</span> <span class="n">dt_np</span> <span class="p">)</span>
        <span class="k">if</span> <span class="n">cache_crossproducts</span><span class="p">:</span>
            <span class="n">a</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">rows</span><span class="o">*</span><span class="nb">len</span><span class="p">(</span> <span class="bp">self</span> <span class="p">)</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">itemsize</span>
            <span class="n">t</span> <span class="o">=</span> <span class="n">a</span> <span class="o">+</span> <span class="n">cp_ra_len</span>
            <span class="n">RA</span><span class="p">[</span><span class="n">a</span><span class="p">:</span><span class="n">t</span><span class="p">]</span> <span class="o">=</span> <span class="n">CP</span><span class="p">[:]</span>
            <span class="n">dtypes</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span> <span class="n">cp_dtypes</span> <span class="p">)</span>
        <span class="k">if</span> <span class="n">cache_powers</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">a</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">rows</span><span class="o">*</span><span class="nb">len</span><span class="p">(</span> <span class="bp">self</span> <span class="p">)</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">itemsize</span> <span class="o">+</span> <span class="n">cp_ra_len</span>
            <span class="n">t</span> <span class="o">=</span> <span class="n">a</span> <span class="o">+</span> <span class="n">pwr_ra_len</span>
            <span class="n">RA</span><span class="p">[</span><span class="n">a</span><span class="p">:</span><span class="n">t</span><span class="p">]</span> <span class="o">=</span> <span class="n">PWR</span><span class="p">[:]</span>
            <span class="n">dtypes</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span> <span class="n">pwr_dtypes</span> <span class="p">)</span>
        <span class="n">MD</span> <span class="o">=</span> <span class="n">mathDict</span><span class="p">(</span> <span class="n">RA</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">rows</span><span class="o">*</span><span class="nb">len</span><span class="p">(</span> <span class="bp">self</span> <span class="p">),</span> <span class="bp">self</span><span class="o">.</span><span class="n">key_list</span><span class="p">,</span>
                       <span class="n">dtypes</span><span class="o">=</span><span class="n">dtypes</span><span class="p">,</span>
                       <span class="n">cache_crossproducts</span><span class="o">=</span><span class="n">cache_crossproducts</span><span class="p">,</span>
                       <span class="n">cache_powers</span><span class="o">=</span><span class="n">cache_powers</span><span class="p">,</span>
                       <span class="n">padding</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">padding_list</span> <span class="p">)</span>
        <span class="k">if</span> <span class="s1">&#39;terms&#39;</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">__dir__</span><span class="p">(</span> <span class="p">):</span>
            <span class="n">MD</span><span class="o">.</span><span class="n">terms</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">terms</span>
        <span class="k">return</span><span class="p">(</span> <span class="n">RA</span><span class="p">,</span> <span class="n">MD</span> <span class="p">)</span></div>

    <span class="nd">@staticmethod</span>
<div class="viewcode-block" id="mathDictMaker.fromMatrix"><a class="viewcode-back" href="../ParallelRegression.html#ParallelRegression.mathDictMaker.fromMatrix">[docs]</a>    <span class="k">def</span> <span class="nf">fromMatrix</span><span class="p">(</span> <span class="n">matrix</span><span class="p">,</span> <span class="n">integer</span><span class="o">=</span><span class="kc">False</span> <span class="p">):</span>
        <span class="sd">&#39;&#39;&#39;Creates a SharedDataArray and mathDict( ) representation from an</span>
<span class="sd">        existing two-dimensional matrix.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        matrix : 2-dimensional array</span>
<span class="sd">            An existing Numpy matrix or 2-dimensional Numpy array.</span>
<span class="sd">        integer : bool</span>
<span class="sd">            If True, the matrix in the SharedDataArray will consist of</span>
<span class="sd">            integers.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        SharedDataArray : multiprocessing.sharedctypes.RawArray</span>
<span class="sd">            The shared data array in which the matrix will be stored.</span>
<span class="sd">        mathDict( ) : mathDict( )</span>
<span class="sd">            The mathDict( ) representation of a matrix.</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="k">if</span> <span class="n">integer</span><span class="p">:</span>
            <span class="n">np_datatype</span> <span class="o">=</span> <span class="n">PR_NP_INT</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">np_datatype</span> <span class="o">=</span> <span class="n">PR_NP_FLT</span>
        <span class="n">r</span><span class="p">,</span> <span class="n">c</span> <span class="o">=</span> <span class="n">matrix</span><span class="o">.</span><span class="n">shape</span>
        <span class="n">items</span> <span class="o">=</span> <span class="n">r</span> <span class="o">*</span> <span class="n">c</span>
        <span class="n">RA_length</span> <span class="o">=</span> <span class="n">items</span> <span class="o">*</span> <span class="n">mathDictMaker</span><span class="p">(</span> <span class="p">)</span><span class="o">.</span><span class="n">itemsize</span>
        <span class="n">column_names</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;x</span><span class="si">%d</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="n">i</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span> <span class="n">c</span> <span class="p">)]</span>
        <span class="n">SharedDataArray</span> <span class="o">=</span> <span class="n">sharedctypes</span><span class="o">.</span><span class="n">RawArray</span><span class="p">(</span> <span class="s1">&#39;b&#39;</span><span class="p">,</span> <span class="n">RA_length</span> <span class="p">)</span>
        <span class="n">SharedDataArray</span><span class="p">[:]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span> <span class="n">matrix</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np_datatype</span>
                                        <span class="p">)</span><span class="o">.</span><span class="n">tobytes</span><span class="p">(</span> <span class="n">order</span><span class="o">=</span><span class="s1">&#39;F&#39;</span> <span class="p">)</span>
        <span class="k">return</span><span class="p">(</span> <span class="n">SharedDataArray</span><span class="p">,</span> <span class="n">mathDict</span><span class="p">(</span> <span class="n">SharedDataArray</span><span class="o">=</span><span class="n">SharedDataArray</span><span class="p">,</span>
                                           <span class="n">items</span><span class="o">=</span><span class="n">items</span><span class="p">,</span>
                                           <span class="n">column_names</span><span class="o">=</span><span class="n">column_names</span><span class="p">,</span>
                                           <span class="n">mask</span><span class="o">=</span><span class="p">[</span><span class="kc">True</span><span class="p">],</span>
                                           <span class="n">dtypes</span><span class="o">=</span><span class="n">np_datatype</span><span class="p">)</span> <span class="p">)</span></div></div>

<div class="viewcode-block" id="mathDictHypothesis"><a class="viewcode-back" href="../ParallelRegression.html#ParallelRegression.mathDictHypothesis">[docs]</a><span class="k">class</span> <span class="nc">mathDictHypothesis</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="sd">&#39;&#39;&#39;Generates testable hypotheses about a mathDict( ) matrix in the form of</span>
<span class="sd">    linear constraints (for use in regression analysis).</span>

<span class="sd">    An &#39;X&#39; matrix representing the regressors (RHS, or &#39;independent&#39; variables)</span>
<span class="sd">    for a linear model for testing the hypothesis is generated.  The columns in</span>
<span class="sd">    the matrix will be the union of all columns in the matrix represented by</span>
<span class="sd">    the mathDict( ) object and all columns in the hypothesis, including</span>
<span class="sd">    calculated columns.</span>

<span class="sd">    An &#39;R&#39; matrix with the same number of columns as the &#39;X&#39; matrix and one row</span>
<span class="sd">    for each column in the hypothesis, as well as an &#39;r&#39; column vector/vertical</span>
<span class="sd">    array with one row/cell for each column in the hypothesis will also be</span>
<span class="sd">    generated.  These can then be used for either an F or a Wald test.</span>

<span class="sd">    &#39;&#39;&#39;</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">mathDict</span> <span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">mathDict</span> <span class="o">=</span> <span class="n">mathDict</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">hypothesis</span> <span class="o">=</span> <span class="n">OrderedDict</span><span class="p">(</span> <span class="p">)</span>

<div class="viewcode-block" id="mathDictHypothesis.add"><a class="viewcode-back" href="../ParallelRegression.html#ParallelRegression.mathDictHypothesis.add">[docs]</a>    <span class="k">def</span> <span class="nf">add</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">column</span><span class="p">,</span> <span class="n">hypothesis</span><span class="o">=</span><span class="mi">0</span> <span class="p">):</span>
        <span class="sd">&#39;&#39;&#39;Adds a column to the hypothesis, and to the resulting X matrix if</span>
<span class="sd">        not included in the matrix represented by the mathDict( ).</span>

<span class="sd">        Raises</span>
<span class="sd">        ------</span>
<span class="sd">        RankError</span>
<span class="sd">            If an attempt to square a dummy variable is made.</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="k">def</span> <span class="nf">checkRank</span><span class="p">(</span> <span class="n">termRep</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">column</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">all_term_keys</span><span class="o">=</span><span class="kc">None</span> <span class="p">):</span>
            <span class="sd">&#39;&#39;&#39;Determines that the resulting X matrix will not be of sufficient</span>
<span class="sd">            rank if adding termRep to the hypothesis would result in duplicate</span>
<span class="sd">            column values due to the over-use of a dummy term.</span>

<span class="sd">            Parameters</span>
<span class="sd">            ----------</span>
<span class="sd">            termRep : string</span>
<span class="sd">                The representation of an individual column from the matrix of</span>
<span class="sd">                original columns used in the column being considered for the</span>
<span class="sd">                hypothesis.</span>
<span class="sd">            column : string</span>
<span class="sd">                The column for which an attempt is being made to add it to the</span>
<span class="sd">                hypothesis.  This can be a column that mathDict can calculate</span>
<span class="sd">                from one or more columns in the matrix of original columns.</span>
<span class="sd">            all_term_keys : Sequence of strings</span>
<span class="sd">                If this is specified, then each string in this sequence is</span>
<span class="sd">                checked to see if it is a dummy term.  The function returns</span>
<span class="sd">                true only if all strings in the sequence are dummy terms, and</span>
<span class="sd">                false otherwise.</span>

<span class="sd">            Raises</span>
<span class="sd">            ------</span>
<span class="sd">            RankError</span>
<span class="sd">                If all_term_keys is not specified and `termRep` is both a dummy</span>
<span class="sd">                term and already used in a column in the matrix.  (If only one</span>
<span class="sd">                column attempts to use the term, then it makes no difference</span>
<span class="sd">                whether or not the term is squared.)</span>

<span class="sd">            Note</span>
<span class="sd">            ----</span>
<span class="sd">            Either `termRep` and `column` should be specified, or</span>
<span class="sd">            `all_term_keys`, but not all three.  If the latter is specified,</span>
<span class="sd">            then the first two will be ignored.</span>
<span class="sd">            &#39;&#39;&#39;</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">mathDict</span><span class="o">.</span><span class="n">terms</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">all_term_keys</span><span class="p">:</span>
                    <span class="n">term_keys</span> <span class="o">=</span> <span class="n">all_term_keys</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">term_keys</span> <span class="o">=</span> <span class="n">_vars_in_factor</span><span class="p">(</span> <span class="n">termRep</span> <span class="p">)</span>
                <span class="k">for</span> <span class="n">key</span> <span class="ow">in</span> <span class="n">term_keys</span><span class="p">:</span>
                    <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">mathDict</span><span class="o">.</span><span class="n">terms</span><span class="o">.</span><span class="n">is_a</span><span class="p">(</span> <span class="s1">&#39;dummy&#39;</span><span class="p">,</span>
                                                 <span class="n">key</span><span class="o">=</span><span class="n">key</span><span class="p">,</span>
                                                 <span class="n">value</span><span class="o">=</span><span class="n">termRep</span> <span class="p">):</span>
                        <span class="k">if</span> <span class="n">all_term_keys</span><span class="p">:</span>
                            <span class="k">continue</span>
                        <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">mathDict</span><span class="o">.</span><span class="n">columns</span><span class="p">:</span>
                            <span class="k">if</span> <span class="n">has_term</span><span class="p">(</span> <span class="n">c</span><span class="p">,</span> <span class="n">key</span> <span class="p">):</span>
                                <span class="k">raise</span> <span class="n">RankError</span><span class="p">(</span> <span class="s1">&#39;Cannot square dummy &#39;</span>
                                      <span class="s1">&#39;variables in hypotheses.  The column &#39;</span>
                                      <span class="s1">&#39;`</span><span class="si">%s</span><span class="s1">` contains a squared dummy variable.&#39;</span>
                                      <span class="o">%</span> <span class="n">column</span> <span class="p">)</span>
                    <span class="k">elif</span> <span class="n">all_term_keys</span><span class="p">:</span>
                        <span class="k">return</span><span class="p">(</span> <span class="kc">False</span> <span class="p">)</span>
                <span class="k">if</span> <span class="n">all_term_keys</span><span class="p">:</span>
                    <span class="k">return</span><span class="p">(</span> <span class="kc">True</span> <span class="p">)</span>
        <span class="c1">#######################################################################</span>
        <span class="c1">## Body of method starts here:</span>
        <span class="k">if</span> <span class="n">column</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">mathDict</span><span class="o">.</span><span class="n">columns</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">hypothesis</span><span class="p">[</span><span class="n">column</span><span class="p">]</span> <span class="o">=</span> <span class="n">hypothesis</span>
            <span class="k">return</span><span class="p">(</span> <span class="p">)</span>
        <span class="n">mc</span> <span class="o">=</span> <span class="n">mask_brackets</span><span class="p">(</span> <span class="n">column</span> <span class="p">)</span>              <span class="c1"># Only calculated columns are</span>
        <span class="n">mobj</span> <span class="o">=</span> <span class="n">cross_Aor_power</span><span class="o">.</span><span class="n">fullmatch</span><span class="p">(</span> <span class="n">mc</span> <span class="p">)</span>    <span class="c1"># evaluated for rejection.</span>
        <span class="k">if</span> <span class="n">mobj</span> <span class="o">!=</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">mobjDict</span> <span class="o">=</span> <span class="n">masked_dict</span><span class="p">(</span> <span class="n">column</span><span class="p">,</span> <span class="n">mobj</span> <span class="p">)</span>
            <span class="k">if</span> <span class="n">mobjDict</span><span class="p">[</span><span class="s1">&#39;column_a&#39;</span><span class="p">]</span> <span class="o">==</span> <span class="n">mobjDict</span><span class="p">[</span><span class="s1">&#39;column_b&#39;</span><span class="p">]:</span> <span class="c1"># If the string is</span>
                <span class="k">if</span> <span class="n">mobjDict</span><span class="p">[</span><span class="s1">&#39;power_a&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">isdigit</span><span class="p">(</span> <span class="p">):</span>           <span class="c1"># 1 column multi-</span>
                    <span class="n">powers</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span> <span class="n">mobjDict</span><span class="p">[</span><span class="s1">&#39;power_a&#39;</span><span class="p">]</span> <span class="p">)</span>      <span class="c1"># plied by itself,</span>
                <span class="k">else</span><span class="p">:</span>                             <span class="c1"># then it&#39;s rewritten as a</span>
                    <span class="n">powers</span> <span class="o">=</span> <span class="mi">1</span>                    <span class="c1"># single instance of the</span>
                <span class="k">if</span> <span class="n">mobjDict</span><span class="p">[</span><span class="s1">&#39;power_b&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">isdigit</span><span class="p">(</span> <span class="p">):</span><span class="c1"># column, raised to a power</span>
                    <span class="n">powers</span> <span class="o">+=</span> <span class="nb">int</span><span class="p">(</span> <span class="n">mobjDict</span><span class="p">[</span><span class="s1">&#39;power_b&#39;</span><span class="p">]</span> <span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">powers</span> <span class="o">+=</span> <span class="mi">1</span>
                <span class="n">col_name</span> <span class="o">=</span> <span class="s1">&#39;</span><span class="si">%s</span><span class="s1">**</span><span class="si">%d</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="n">mobjDict</span><span class="p">[</span><span class="s1">&#39;column_a&#39;</span><span class="p">],</span> <span class="n">powers</span><span class="p">)</span>
                <span class="n">col_name</span><span class="p">,</span> <span class="n">boolchk</span> <span class="o">=</span> <span class="n">_soft_in</span><span class="p">(</span>     <span class="c1"># The rewritten column is</span>
                    <span class="n">col_name</span><span class="p">,</span>                     <span class="c1"># checked against existing</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">mathDict</span><span class="o">.</span><span class="n">columns</span> <span class="p">)</span>       <span class="c1"># columns in the matrix</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="n">boolchk</span><span class="p">:</span>                   <span class="c1"># represented by the</span>
                    <span class="n">checkRank</span><span class="p">(</span>                    <span class="c1"># mathDict( ) so that dupli-</span>
                        <span class="n">mobjDict</span><span class="p">[</span><span class="s1">&#39;column_a&#39;</span><span class="p">],</span>     <span class="c1"># cates aren&#39;t added.</span>
                        <span class="n">column</span> <span class="p">)</span>                  <span class="c1"># checkRank( ) is performed</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">hypothesis</span><span class="p">[</span><span class="n">col_name</span><span class="p">]</span> <span class="o">=</span> <span class="n">hypothesis</span> <span class="c1"># only if this would be</span>
                <span class="k">return</span><span class="p">(</span> <span class="p">)</span>                         <span class="c1"># an additional column.</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">fznCl</span>   <span class="o">=</span> <span class="nb">frozenset</span><span class="p">(</span>              <span class="c1"># If column_a and column_b</span>
                    <span class="n">_vars_in_factor</span><span class="p">(</span>              <span class="c1"># both consist of the same</span>
                        <span class="n">mobjDict</span><span class="p">[</span><span class="s1">&#39;column_a&#39;</span><span class="p">]</span> <span class="p">)</span> <span class="p">)</span>  <span class="c1"># terms, regardless of order,</span>
                <span class="n">fznCl_b</span> <span class="o">=</span> <span class="nb">frozenset</span><span class="p">(</span>              <span class="c1"># then checkRank is used to</span>
                    <span class="n">_vars_in_factor</span><span class="p">(</span>              <span class="c1"># check if all of the terms</span>
                        <span class="n">mobjDict</span><span class="p">[</span><span class="s1">&#39;column_b&#39;</span><span class="p">]</span> <span class="p">)</span> <span class="p">)</span>  <span class="c1"># are dummy terms, and if so,</span>
                <span class="k">if</span> <span class="n">fznCl</span> <span class="o">==</span> <span class="n">fznCl_b</span><span class="p">:</span>              <span class="c1"># if there already exists a</span>
                    <span class="k">if</span> <span class="n">checkRank</span><span class="p">(</span> <span class="n">all_term_keys</span><span class="o">=</span><span class="n">fznCl</span> <span class="p">):</span> <span class="c1"># column with the same</span>
                        <span class="k">for</span> <span class="n">col</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">mathDict</span><span class="o">.</span><span class="n">columns</span><span class="p">:</span><span class="c1"># set of terms.</span>
                            <span class="k">if</span> <span class="n">fznCl</span> <span class="o">==</span> <span class="nb">frozenset</span><span class="p">(</span> <span class="n">_vars_in_factor</span><span class="p">(</span> <span class="n">col</span> <span class="p">)</span> <span class="p">):</span>
                                <span class="k">if</span> <span class="n">mobjDict</span><span class="p">[</span><span class="s1">&#39;power_a&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">isdigit</span><span class="p">(</span> <span class="p">):</span>
                                    <span class="n">pa</span> <span class="o">=</span> <span class="s1">&#39;**&#39;</span> <span class="o">+</span> <span class="n">mobjDict</span><span class="p">[</span><span class="s1">&#39;power_a&#39;</span><span class="p">]</span>
                                <span class="k">else</span><span class="p">:</span>
                                    <span class="n">pa</span> <span class="o">=</span> <span class="s1">&#39;&#39;</span>
                                <span class="k">if</span> <span class="n">mobjDict</span><span class="p">[</span><span class="s1">&#39;power_b&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">isdigit</span><span class="p">(</span> <span class="p">):</span>
                                    <span class="n">pb</span> <span class="o">=</span> <span class="s1">&#39;**&#39;</span> <span class="o">+</span> <span class="n">mobjDict</span><span class="p">[</span><span class="s1">&#39;power_b&#39;</span><span class="p">]</span>
                                <span class="k">else</span><span class="p">:</span>
                                    <span class="n">pb</span> <span class="o">=</span> <span class="s1">&#39;&#39;</span>
                                <span class="k">raise</span> <span class="n">RankError</span><span class="p">(</span> <span class="s1">&#39;`</span><span class="si">%s%s</span><span class="s1">` and `</span><span class="si">%s%s</span><span class="s1">` consist of&#39;</span>
                                      <span class="s1">&#39; the same set of dummy terms.  The &#39;</span>
                                      <span class="s1">&#39;mathDict( ) matrix already has `</span><span class="si">%s</span><span class="s1">`, &#39;</span>
                                      <span class="s1">&#39;which also consists of the same dummy &#39;</span>
                                      <span class="s1">&#39;terms.&#39;</span>
                                      <span class="o">%</span> <span class="p">(</span><span class="n">mobjDict</span><span class="p">[</span><span class="s1">&#39;column_a&#39;</span><span class="p">],</span> <span class="n">pa</span><span class="p">,</span>
                                         <span class="n">mobjDict</span><span class="p">[</span><span class="s1">&#39;column_b&#39;</span><span class="p">],</span> <span class="n">pb</span><span class="p">,</span>
                                         <span class="n">col</span><span class="p">)</span> <span class="p">)</span>
            <span class="k">for</span> <span class="n">l</span> <span class="ow">in</span> <span class="p">[</span><span class="s1">&#39;a&#39;</span><span class="p">,</span> <span class="s1">&#39;b&#39;</span><span class="p">]:</span>
                <span class="k">if</span> <span class="n">mobjDict</span><span class="p">[</span><span class="s1">&#39;power_&#39;</span><span class="o">+</span><span class="n">l</span><span class="p">]</span><span class="o">.</span><span class="n">isdigit</span><span class="p">(</span> <span class="p">)</span> <span class="ow">and</span> \
                   <span class="nb">int</span><span class="p">(</span> <span class="n">mobjDict</span><span class="p">[</span><span class="s1">&#39;power_&#39;</span><span class="o">+</span><span class="n">l</span><span class="p">]</span> <span class="p">)</span> <span class="o">&gt;=</span> <span class="mi">2</span><span class="p">:</span>
                    <span class="n">checkRank</span><span class="p">(</span> <span class="n">mobjDict</span><span class="p">[</span><span class="s1">&#39;column_&#39;</span><span class="o">+</span><span class="n">l</span><span class="p">],</span> <span class="n">column</span> <span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">hypothesis</span><span class="p">[</span><span class="n">column</span><span class="p">]</span> <span class="o">=</span> <span class="n">hypothesis</span></div>

<div class="viewcode-block" id="mathDictHypothesis.make"><a class="viewcode-back" href="../ParallelRegression.html#ParallelRegression.mathDictHypothesis.make">[docs]</a>    <span class="k">def</span> <span class="nf">make</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&#39;&#39;&#39;Returns a tuple consisting of the X matrix, R matrix, and r column</span>
<span class="sd">        vector/vertical array, each in the form of a two-dimensional numpy</span>
<span class="sd">        array.</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="n">X</span><span class="p">,</span> <span class="n">R</span><span class="p">,</span> <span class="n">r</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_make</span><span class="p">(</span> <span class="p">)</span>
        <span class="k">return</span><span class="p">(</span> <span class="n">X</span><span class="p">[:],</span> <span class="n">R</span><span class="p">,</span> <span class="n">r</span> <span class="p">)</span></div>

    <span class="k">def</span> <span class="nf">_get_X</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">X</span><span class="p">,</span> <span class="n">R</span><span class="p">,</span> <span class="n">r</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_make</span><span class="p">(</span> <span class="p">)</span>
        <span class="k">return</span><span class="p">(</span> <span class="n">X</span> <span class="p">)</span>

    <span class="k">def</span> <span class="nf">_make</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">superset_only</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span> <span class="p">)</span>
        <span class="n">rt_orig</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span> <span class="p">)</span>
        <span class="n">rt_superset_only</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span> <span class="p">)</span>
        <span class="k">for</span> <span class="n">key</span><span class="p">,</span> <span class="n">val</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">hypothesis</span><span class="o">.</span><span class="n">items</span><span class="p">(</span> <span class="p">):</span>
            <span class="k">if</span> <span class="n">key</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">mathDict</span><span class="o">.</span><span class="n">columns</span><span class="p">:</span>
                <span class="n">rt_orig</span><span class="o">.</span><span class="n">append</span><span class="p">(</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">mathDict</span><span class="o">.</span><span class="n">columns</span><span class="o">.</span><span class="n">index</span><span class="p">(</span> <span class="n">key</span> <span class="p">),</span> <span class="n">val</span><span class="p">)</span> <span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">rt_superset_only</span><span class="o">.</span><span class="n">append</span><span class="p">(</span> <span class="p">(</span><span class="nb">len</span><span class="p">(</span> <span class="n">superset_only</span> <span class="p">),</span> <span class="n">val</span><span class="p">)</span> <span class="p">)</span>
                <span class="k">if</span> <span class="n">key</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">mathDict</span><span class="o">.</span><span class="n">_column_names</span><span class="p">:</span>    <span class="c1">#</span>
                    <span class="c1">###########################################################</span>
                    <span class="c1">## `**1` so that it extends the matrix to the right with  #</span>
                    <span class="c1">##  the calculated columns, instead of getting inserted   #</span>
                    <span class="n">superset_only</span><span class="o">.</span><span class="n">append</span><span class="p">(</span> <span class="s1">&#39;</span><span class="si">%s</span><span class="s1">**1&#39;</span> <span class="o">%</span> <span class="n">key</span> <span class="p">)</span> <span class="c1">## in the middle.   #</span>
                <span class="k">else</span><span class="p">:</span> <span class="c1">#########################################################</span>
                    <span class="n">superset_only</span><span class="o">.</span><span class="n">append</span><span class="p">(</span> <span class="n">key</span> <span class="p">)</span>
        <span class="c1"># Build X</span>
        <span class="n">X</span> <span class="o">=</span> <span class="n">mathDict</span><span class="p">(</span> <span class="bp">self</span><span class="o">.</span><span class="n">mathDict</span><span class="o">.</span><span class="n">buffer</span><span class="p">,</span>
                      <span class="bp">self</span><span class="o">.</span><span class="n">mathDict</span><span class="o">.</span><span class="n">items</span><span class="p">,</span>
                      <span class="bp">self</span><span class="o">.</span><span class="n">mathDict</span><span class="o">.</span><span class="n">_column_names</span><span class="p">,</span>
                      <span class="bp">self</span><span class="o">.</span><span class="n">mathDict</span><span class="o">.</span><span class="n">_mask</span><span class="p">,</span>
                      <span class="bp">self</span><span class="o">.</span><span class="n">mathDict</span><span class="o">.</span><span class="n">dtypes</span><span class="p">,</span>
                      <span class="bp">self</span><span class="o">.</span><span class="n">mathDict</span><span class="o">.</span><span class="n">_calculated_columns</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span> <span class="p">),</span>
                      <span class="bp">self</span><span class="o">.</span><span class="n">mathDict</span><span class="o">.</span><span class="n">cache_crossproducts</span><span class="p">,</span>
                      <span class="bp">self</span><span class="o">.</span><span class="n">mathDict</span><span class="o">.</span><span class="n">cache_powers</span><span class="p">,</span>
                      <span class="n">padding</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">mathDict</span><span class="o">.</span><span class="n">_orig_padding</span> <span class="p">)</span>
        <span class="n">X</span><span class="o">.</span><span class="n">_local_mask</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">mathDict</span><span class="o">.</span><span class="n">_local_mask</span>
        <span class="n">X</span><span class="o">.</span><span class="n">local</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">mathDict</span><span class="o">.</span><span class="n">local</span>
        <span class="n">X</span><span class="o">.</span><span class="n">local</span><span class="o">.</span><span class="n">mathDict</span> <span class="o">=</span> <span class="n">X</span>
        <span class="n">X</span><span class="o">.</span><span class="n">calculated_columns</span><span class="p">(</span> <span class="s1">&#39;extend&#39;</span><span class="p">,</span> <span class="n">superset_only</span> <span class="p">)</span>
        <span class="c1"># Build R, r</span>
        <span class="n">Z</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">mathDict</span><span class="o">.</span><span class="n">columns</span><span class="p">)</span> <span class="o">+</span> <span class="nb">len</span><span class="p">(</span> <span class="n">superset_only</span> <span class="p">)),</span>
                       <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">dtype</span><span class="p">(</span> <span class="n">PR_NP_INT</span> <span class="p">)</span> <span class="p">)</span>
        <span class="n">R</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros_like</span><span class="p">(</span> <span class="n">Z</span> <span class="p">)</span>
        <span class="n">r</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span> <span class="p">(</span><span class="nb">len</span><span class="p">(</span> <span class="n">rt_orig</span> <span class="p">)</span> <span class="o">+</span> <span class="nb">len</span><span class="p">(</span> <span class="n">rt_superset_only</span> <span class="p">)),</span>
                      <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">dtype</span><span class="p">(</span> <span class="n">PR_NP_INT</span> <span class="p">)</span> <span class="p">)</span>
        <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span> <span class="nb">len</span><span class="p">(</span> <span class="n">rt_orig</span> <span class="p">)</span> <span class="p">):</span>
            <span class="n">RX</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros_like</span><span class="p">(</span> <span class="n">Z</span> <span class="p">)</span>
            <span class="n">i</span><span class="p">,</span> <span class="n">v</span> <span class="o">=</span> <span class="n">rt_orig</span><span class="p">[</span><span class="n">j</span><span class="p">]</span>
            <span class="n">RX</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>
            <span class="n">R</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">(</span> <span class="p">(</span><span class="n">R</span><span class="p">,</span> <span class="n">RX</span><span class="p">)</span> <span class="p">)</span>
            <span class="n">r</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">v</span>
        <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span> <span class="nb">len</span><span class="p">(</span> <span class="n">rt_superset_only</span> <span class="p">)</span> <span class="p">):</span>
            <span class="n">RX</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros_like</span><span class="p">(</span> <span class="n">Z</span> <span class="p">)</span>
            <span class="n">i</span><span class="p">,</span> <span class="n">v</span> <span class="o">=</span> <span class="n">rt_superset_only</span><span class="p">[</span><span class="n">j</span><span class="p">]</span>
            <span class="n">RX</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="bp">self</span><span class="o">.</span><span class="n">mathDict</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>
            <span class="n">R</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">(</span> <span class="p">(</span><span class="n">R</span><span class="p">,</span> <span class="n">RX</span><span class="p">)</span> <span class="p">)</span>
            <span class="n">r</span><span class="p">[</span><span class="nb">len</span><span class="p">(</span> <span class="n">rt_orig</span> <span class="p">)</span> <span class="o">+</span> <span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">v</span>
        <span class="k">return</span><span class="p">(</span> <span class="n">X</span><span class="p">,</span> <span class="n">R</span><span class="p">[</span><span class="mi">1</span><span class="p">:,:],</span> <span class="n">r</span> <span class="p">)</span></div>

<div class="viewcode-block" id="mathDictConfig"><a class="viewcode-back" href="../ParallelRegression.html#ParallelRegression.mathDictConfig">[docs]</a><span class="k">class</span> <span class="nc">mathDictConfig</span><span class="p">(</span><span class="nb">dict</span><span class="p">):</span>
<div class="viewcode-block" id="mathDictConfig.rebuild"><a class="viewcode-back" href="../ParallelRegression.html#ParallelRegression.mathDictConfig.rebuild">[docs]</a>    <span class="k">def</span> <span class="nf">rebuild</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">SharedDataArray</span><span class="p">,</span> <span class="n">terms</span><span class="o">=</span><span class="kc">None</span> <span class="p">):</span>
        <span class="sd">&#39;&#39;&#39;Recreates the mathDict( ) object whose configuration is stored in</span>
<span class="sd">        this dict( ).  Requires that the shared data array is provided as a</span>
<span class="sd">        parameter.</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="k">if</span> <span class="n">terms</span> <span class="o">==</span> <span class="kc">None</span> <span class="ow">and</span> <span class="s1">&#39;terms&#39;</span> <span class="ow">in</span> <span class="bp">self</span><span class="p">:</span>
            <span class="n">terms</span> <span class="o">=</span> <span class="bp">self</span><span class="p">[</span><span class="s1">&#39;terms&#39;</span><span class="p">]</span>
        <span class="n">MD</span> <span class="o">=</span> <span class="n">mathDict</span><span class="p">(</span> <span class="n">SharedDataArray</span><span class="o">=</span><span class="n">SharedDataArray</span><span class="p">,</span>
                       <span class="n">items</span><span class="o">=</span><span class="bp">self</span><span class="p">[</span><span class="s1">&#39;items&#39;</span><span class="p">],</span>
                       <span class="n">column_names</span><span class="o">=</span><span class="bp">self</span><span class="p">[</span><span class="s1">&#39;_column_names&#39;</span><span class="p">],</span>
                       <span class="n">mask</span><span class="o">=</span><span class="n">deepcopy</span><span class="p">(</span> <span class="bp">self</span><span class="p">[</span><span class="s1">&#39;mask&#39;</span><span class="p">]</span> <span class="p">),</span>
                       <span class="n">dtypes</span><span class="o">=</span><span class="bp">self</span><span class="p">[</span><span class="s1">&#39;dtypes&#39;</span><span class="p">],</span>
                       <span class="n">calculated_columns</span><span class="o">=</span><span class="n">deepcopy</span><span class="p">(</span>
                                                  <span class="bp">self</span><span class="p">[</span><span class="s1">&#39;calculated_columns&#39;</span><span class="p">]</span> <span class="p">),</span>
                       <span class="n">cache_crossproducts</span><span class="o">=</span><span class="bp">self</span><span class="p">[</span><span class="s1">&#39;cache_crossproducts&#39;</span><span class="p">],</span>
                       <span class="n">cache_powers</span><span class="o">=</span><span class="bp">self</span><span class="p">[</span><span class="s1">&#39;cache_powers&#39;</span><span class="p">],</span>
                       <span class="n">padding</span><span class="o">=</span><span class="bp">self</span><span class="p">[</span><span class="s1">&#39;_orig_padding&#39;</span><span class="p">],</span>
                       <span class="n">terms</span><span class="o">=</span><span class="n">terms</span> <span class="p">)</span>
        <span class="n">MD</span><span class="o">.</span><span class="n">local_calculated</span> <span class="o">=</span> <span class="bp">self</span><span class="p">[</span><span class="s1">&#39;local_calculated&#39;</span><span class="p">]</span>
        <span class="k">for</span> <span class="n">calculated</span> <span class="ow">in</span> <span class="bp">self</span><span class="p">[</span><span class="s1">&#39;local_calculated&#39;</span><span class="p">]:</span>
            <span class="n">MD</span><span class="o">.</span><span class="n">add</span><span class="p">(</span> <span class="n">calculated</span> <span class="p">)</span>
        <span class="n">MD</span><span class="o">.</span><span class="n">_local_mask</span> <span class="o">=</span> <span class="bp">self</span><span class="p">[</span><span class="s1">&#39;local_mask&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">intersection</span><span class="p">(</span> <span class="nb">set</span><span class="p">(</span> <span class="n">MD</span><span class="o">.</span><span class="n">local</span><span class="o">.</span><span class="n">keys</span><span class="p">(</span> <span class="p">)</span>
                                                                <span class="p">)</span> <span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_last_columns</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="k">return</span><span class="p">(</span> <span class="n">MD</span> <span class="p">)</span></div></div>

<div class="viewcode-block" id="mathDict"><a class="viewcode-back" href="../ParallelRegression.html#ParallelRegression.mathDict">[docs]</a><span class="k">class</span> <span class="nc">mathDict</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
<div class="viewcode-block" id="mathDict.__init__"><a class="viewcode-back" href="../ParallelRegression.html#ParallelRegression.mathDict.__init__">[docs]</a>    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">SharedDataArray</span><span class="p">,</span> <span class="n">items</span><span class="p">,</span> <span class="n">column_names</span><span class="p">,</span>
                 <span class="n">mask</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                 <span class="n">dtypes</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                 <span class="n">calculated_columns</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                 <span class="n">cache_crossproducts</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                 <span class="n">cache_powers</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span>
                 <span class="n">terms</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                 <span class="n">padding</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&#39;&#39;&#39;dict( )-like interface to a shared-memory, two-dimensional array of</span>
<span class="sd">        heterogenous numeric data-typed columns that builds linear constraints/</span>
<span class="sd">        hypotheses and pre-calculates powers and cross-products of columns.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        SharedDataArray : multiprocessing.sharedctypes.RawArray or comparable</span>
<span class="sd">            The shared-memory byte array in which the columns and pre-</span>
<span class="sd">            calculated manipulations thereof are stored.  See the note</span>
<span class="sd">            regarding array length.</span>
<span class="sd">        items : int</span>
<span class="sd">            The number of cells in the matrix of original columns, not</span>
<span class="sd">            including the intercept column or calculated columns.  All columns</span>
<span class="sd">            must be supplied to mathDict( ) with the same number of rows.</span>
<span class="sd">        column_names : sequence of strings</span>
<span class="sd">            The names of the original columns, not including the intercept</span>
<span class="sd">            column or calculated columns.  There must be exactly one string in</span>
<span class="sd">            column_name for each column in the matrix of original columns.</span>
<span class="sd">        mask : sequence of booleans, optional</span>
<span class="sd">            Columns with an associated mask boolean of True are hidden.  The</span>
<span class="sd">            first boolean in the sequence is associated with the intercept</span>
<span class="sd">            column, resulting in a column of ones at index 0 if set to False.</span>
<span class="sd">            After that, the value at mask[1] corresponds to column_name[0], and</span>
<span class="sd">            so on.  If the mask sequence is shorter than the sequence of</span>
<span class="sd">            column_names, than columns without an associated mask value are</span>
<span class="sd">            unmasked.</span>
<span class="sd">        dtypes : string or Sequence, optional</span>
<span class="sd">            If a sequence, there must be one value for each column,</span>
<span class="sd">            representing the numpy data type of the cells in that column.  If a</span>
<span class="sd">            single string, then all columns must consist of cells of that data</span>
<span class="sd">            type.  Currently only 8-byte-per-item data types (&#39;i8&#39;, &#39;f8&#39;) are</span>
<span class="sd">            suported.</span>
<span class="sd">        calculated_columns : sequence of strings</span>
<span class="sd">            Each string represents a column that extends the matrix represented</span>
<span class="sd">            by the mathDict( ) beyond the matrix of original columns with a</span>
<span class="sd">            column calculated therefrom using operations supported by</span>
<span class="sd">            mathDict( ).  Currently limited to crossproducts, powers, and lags.</span>
<span class="sd">        cache_crossproducts : boolean, optional</span>
<span class="sd">            If True, then the crossproducts of each combination (without</span>
<span class="sd">            replacement) of columns in the matrix of original columns has been</span>
<span class="sd">            pre-calculated and appended to the shared data array after the</span>
<span class="sd">            original columns.  Use mathDictMaker( ) to pre-calculate these</span>
<span class="sd">            values.</span>
<span class="sd">        cache_powers : int, optional</span>
<span class="sd">            If set to an integer greater than 1, then the powers of each</span>
<span class="sd">            original column ranging from 2 through this value (inclusive) have</span>
<span class="sd">            been pre-calculated and appended to the shared data array after the</span>
<span class="sd">            original columns and cached crossproducts (if present).  Use</span>
<span class="sd">            mathDictMaker( ) to pre-calculate these values.</span>
<span class="sd">        terms : termSet( ), optional</span>
<span class="sd">            The termSet( ) to be used by mathDict.hypothesis.add( ) in</span>
<span class="sd">            determining whether or not adding a column string to the hypothesis</span>
<span class="sd">            should result in a RankError.</span>
<span class="sd">        padding : list of ints, optional</span>
<span class="sd">            A list in which each entry corresponds to the column at the same</span>
<span class="sd">            index in column_names, indicating the number of rows of padding at</span>
<span class="sd">            the beginning of column.  This is the list produced by</span>
<span class="sd">            mathDictMaker.padding_list.  If provided, this must be the same</span>
<span class="sd">            length as column_names, with zeros for each column that has no</span>
<span class="sd">            padding.</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        Size of `SharedDataArray`: The shared-memory array identified by the</span>
<span class="sd">        shared data array parameter stores each column in the matrix of</span>
<span class="sd">        original columns, in column-major order, followed by each pre-</span>
<span class="sd">        calculated crossproduct column (if present) and pre-calculated power</span>
<span class="sd">        column (if present).  With 8-byte-per-item data types, the matrix of</span>
<span class="sd">        original columns alone requires 8*[row count]*[column count].</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">buffer</span> <span class="o">=</span> <span class="n">SharedDataArray</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">items</span> <span class="o">=</span> <span class="n">items</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_column_names</span> <span class="o">=</span> <span class="n">column_names</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">cache_crossproducts</span> <span class="o">=</span> <span class="n">cache_crossproducts</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">cache_powers</span> <span class="o">=</span> <span class="n">cache_powers</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">itemsize</span> <span class="o">=</span> <span class="n">PR_BYTESIZE</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">hypothesis</span> <span class="o">=</span> <span class="n">mathDictHypothesis</span><span class="p">(</span> <span class="bp">self</span> <span class="p">)</span>
        <span class="c1">#######################################################################</span>
        <span class="c1">## Setting self.local to dict( ) before setting it to mathDataStore( )#</span>
        <span class="c1">## avoids an error that would otherwise result from a chicken-or-the- #</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">local</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span> <span class="p">)</span> <span class="c1">## egg problem.                                  #</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">local</span> <span class="o">=</span> <span class="n">mathDataStore</span><span class="p">(</span> <span class="n">mathDict</span><span class="o">=</span><span class="bp">self</span> <span class="p">)</span>                           <span class="c1">#</span>
        <span class="c1">#######################################################################</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_local_mask</span> <span class="o">=</span> <span class="n">setList</span><span class="p">(</span> <span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">local_calculated</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span> <span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">terms</span> <span class="o">=</span> <span class="n">terms</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">strings_checked</span> <span class="o">=</span> <span class="n">setList</span><span class="p">(</span> <span class="p">)</span>
        <span class="k">if</span> <span class="n">calculated_columns</span> <span class="o">==</span> <span class="kc">None</span><span class="p">:</span>            <span class="c1"># ._calculated_columns,</span>
            <span class="n">calculated_columns</span> <span class="o">=</span> <span class="p">[]</span>               <span class="c1"># ._mask, and ._local_mask</span>
        <span class="k">if</span> <span class="n">mask</span> <span class="o">==</span> <span class="kc">None</span><span class="p">:</span>                          <span class="c1"># should never be accessed</span>
            <span class="n">mask</span> <span class="o">=</span> <span class="p">[</span><span class="kc">False</span><span class="p">]</span>                        <span class="c1"># directly.  Use the corre-</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_mask</span> <span class="o">=</span> <span class="n">mask</span>                         <span class="c1"># sponding methods.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_calculated_columns</span> <span class="o">=</span> <span class="n">calculated_columns</span>
        <span class="k">if</span> <span class="n">dtypes</span> <span class="o">==</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">dtypes</span> <span class="o">=</span> <span class="n">PR_NP_FLT</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span> <span class="n">dtypes</span><span class="p">,</span> <span class="nb">str</span> <span class="p">):</span>
            <span class="n">dtypes</span> <span class="o">=</span> <span class="p">[</span><span class="n">dtypes</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">column_names</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">dtypes</span> <span class="o">=</span> <span class="n">dtypes</span>
        <span class="k">if</span> <span class="n">padding</span> <span class="o">==</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">padding</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span> <span class="nb">len</span><span class="p">(</span> <span class="n">column_names</span> <span class="p">)</span> <span class="p">)]</span>
        <span class="k">elif</span> <span class="nb">len</span><span class="p">(</span> <span class="n">padding</span> <span class="p">)</span> <span class="o">!=</span> <span class="nb">len</span><span class="p">(</span> <span class="n">column_names</span> <span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span> <span class="s1">&#39;Length of padding must equal length of &#39;</span>
                              <span class="s1">&#39;column_names.&#39;</span> <span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_orig_padding</span> <span class="o">=</span> <span class="n">padding</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_last_columns</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_last_max_lag</span> <span class="o">=</span> <span class="kc">None</span></div>

    <span class="k">def</span> <span class="nf">mask</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">action</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span> <span class="p">):</span>
        <span class="sd">&#39;&#39;&#39;Protected object: _mask2.</span>
<span class="sd">        For read access, calling .method( ) with no parameters returns the</span>
<span class="sd">        object, which can then be read/subscripted as usual.</span>

<span class="sd">        To call a method of the protected object, the first parameter should be</span>
<span class="sd">        the name of the method to be called.  All further parameters are passed</span>
<span class="sd">        on to the method.  To replace the protected object, `&#39;replace`&#39; should</span>
<span class="sd">        be the first parameter, followed by the new object.</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="n">protected_name</span> <span class="o">=</span> <span class="s1">&#39;_mask&#39;</span>
        <span class="n">protected</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span> <span class="bp">self</span><span class="p">,</span> <span class="n">protected_name</span> <span class="p">)</span>
        <span class="k">if</span> <span class="n">action</span> <span class="o">==</span> <span class="s1">&#39;replace&#39;</span><span class="p">:</span>
            <span class="k">return</span><span class="p">(</span> <span class="nb">setattr</span><span class="p">(</span> <span class="bp">self</span><span class="p">,</span> <span class="n">protected_name</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span> <span class="p">)</span> <span class="p">)</span>
        <span class="k">if</span> <span class="n">action</span> <span class="o">==</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">return</span><span class="p">(</span> <span class="n">protected</span> <span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_recal_max_lag</span><span class="p">(</span> <span class="p">)</span>
        <span class="k">return</span><span class="p">(</span> <span class="nb">getattr</span><span class="p">(</span> <span class="n">protected</span><span class="p">,</span> <span class="n">action</span> <span class="p">)(</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span> <span class="p">)</span> <span class="p">)</span>

    <span class="k">def</span> <span class="nf">calculated_columns</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">action</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span> <span class="p">):</span>
        <span class="sd">&#39;&#39;&#39;Protected object: _calculated_columns.</span>
<span class="sd">        For read access, calling .method( ) with no parameters returns the</span>
<span class="sd">        object, which can then be read/subscripted as usual.</span>

<span class="sd">        To call a method of the protected object, the first parameter should be</span>
<span class="sd">        the name of the method to be called.  All further parameters are passed</span>
<span class="sd">        on to the method.  To replace the protected object, `&#39;replace`&#39; should</span>
<span class="sd">        be the first parameter, followed by the new object.</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="n">protected_name</span> <span class="o">=</span> <span class="s1">&#39;_calculated_columns&#39;</span>
        <span class="n">protected</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span> <span class="bp">self</span><span class="p">,</span> <span class="n">protected_name</span> <span class="p">)</span>
        <span class="k">if</span> <span class="n">action</span> <span class="o">==</span> <span class="s1">&#39;replace&#39;</span><span class="p">:</span>
            <span class="k">return</span><span class="p">(</span> <span class="nb">setattr</span><span class="p">(</span> <span class="bp">self</span><span class="p">,</span> <span class="n">protected_name</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span> <span class="p">)</span> <span class="p">)</span>
        <span class="k">if</span> <span class="n">action</span> <span class="o">==</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">return</span><span class="p">(</span> <span class="n">protected</span> <span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_recal_max_lag</span><span class="p">(</span> <span class="p">)</span>
        <span class="k">return</span><span class="p">(</span> <span class="nb">getattr</span><span class="p">(</span> <span class="n">protected</span><span class="p">,</span> <span class="n">action</span> <span class="p">)(</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span> <span class="p">)</span> <span class="p">)</span>

    <span class="k">def</span> <span class="nf">local_mask</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">action</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span> <span class="p">):</span>
        <span class="sd">&#39;&#39;&#39;Protected object: _local_mask.</span>
<span class="sd">        For read access, calling .method( ) with no parameters returns the</span>
<span class="sd">        object, which can then be read/subscripted as usual.</span>

<span class="sd">        To call a method of the protected object, the first parameter should be</span>
<span class="sd">        the name of the method to be called.  All further parameters are passed</span>
<span class="sd">        on to the method.  To replace the protected object, `&#39;replace`&#39; should</span>
<span class="sd">        be the first parameter, followed by the new object.</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="n">protected_name</span> <span class="o">=</span> <span class="s1">&#39;_local_mask&#39;</span>
        <span class="n">protected</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span> <span class="bp">self</span><span class="p">,</span> <span class="n">protected_name</span> <span class="p">)</span>
        <span class="k">if</span> <span class="n">action</span> <span class="o">==</span> <span class="s1">&#39;replace&#39;</span><span class="p">:</span>
            <span class="k">return</span><span class="p">(</span> <span class="nb">setattr</span><span class="p">(</span> <span class="bp">self</span><span class="p">,</span> <span class="n">protected_name</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span> <span class="p">)</span> <span class="p">)</span>
        <span class="k">if</span> <span class="n">action</span> <span class="o">==</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">return</span><span class="p">(</span> <span class="n">protected</span> <span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_recal_max_lag</span><span class="p">(</span> <span class="p">)</span>
        <span class="k">return</span><span class="p">(</span> <span class="nb">getattr</span><span class="p">(</span> <span class="n">protected</span><span class="p">,</span> <span class="n">action</span> <span class="p">)(</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span> <span class="p">)</span> <span class="p">)</span>

    <span class="k">def</span> <span class="nf">_recal_max_lag</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">obj</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">attr</span><span class="o">=</span><span class="kc">None</span> <span class="p">):</span>
        <span class="sd">&#39;&#39;&#39;(for internal use): clears the cached .max_lag and .columns values</span>
<span class="sd">        so that next time either one is accessed, it is recalculated/</span>
<span class="sd">        regenerated.</span>

<span class="sd">        Originally implemented because it was necessary for .max_lag to perform</span>
<span class="sd">        well, and then extended to cover .columns as well.</span>
<span class="sd">        self.local.__setitem__( ) also clears self._last_columns, but not</span>
<span class="sd">        self._last_max_lag.</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_last_max_lag</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_last_columns</span> <span class="o">=</span> <span class="kc">None</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">columns</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&#39;&#39;&#39;list of strings: Lists the name of each column in the matrix</span>
<span class="sd">        represented by the mathDict( ), starting with the Intercept column</span>
<span class="sd">        unless masked, followed by columns in the matrix of original columns</span>
<span class="sd">        that are not masked, by local columns, and finally by calculated</span>
<span class="sd">        columns.</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_last_columns</span> <span class="o">!=</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">return</span><span class="p">(</span> <span class="bp">self</span><span class="o">.</span><span class="n">_last_columns</span> <span class="p">)</span>
        <span class="n">ret</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span> <span class="p">)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">mask</span><span class="p">(</span> <span class="p">)[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="kc">False</span><span class="p">:</span>
            <span class="n">ret</span><span class="o">.</span><span class="n">append</span><span class="p">(</span> <span class="s1">&#39;Intercept&#39;</span> <span class="p">)</span>
        <span class="n">len_mask</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span> <span class="bp">self</span><span class="o">.</span><span class="n">mask</span><span class="p">(</span> <span class="p">)</span> <span class="p">)</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span> <span class="nb">len</span><span class="p">(</span> <span class="bp">self</span><span class="o">.</span><span class="n">_column_names</span> <span class="p">)</span> <span class="p">):</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span> <span class="o">&lt;</span> <span class="n">len_mask</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">mask</span><span class="p">(</span> <span class="p">)[</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="kc">False</span><span class="p">)</span> <span class="ow">or</span> \
               <span class="n">i</span><span class="o">+</span><span class="mi">1</span> <span class="o">&gt;=</span> <span class="n">len_mask</span><span class="p">:</span>
                <span class="n">ret</span><span class="o">.</span><span class="n">append</span><span class="p">(</span> <span class="bp">self</span><span class="o">.</span><span class="n">_column_names</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="p">)</span>
        <span class="k">for</span> <span class="n">key</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">local</span><span class="o">.</span><span class="n">key_list</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">key</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">local_mask</span><span class="p">(</span> <span class="p">):</span>
                <span class="n">ret</span><span class="o">.</span><span class="n">append</span><span class="p">(</span> <span class="n">key</span> <span class="p">)</span>
        <span class="n">ret</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span> <span class="bp">self</span><span class="o">.</span><span class="n">calculated_columns</span><span class="p">(</span> <span class="p">)</span> <span class="p">)</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span> <span class="n">ret</span> <span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_last_columns</span> <span class="o">=</span> <span class="n">ret</span>
        <span class="k">return</span><span class="p">(</span> <span class="n">ret</span> <span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">rows</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&#39;&#39;&#39;The number of rows in the matrix of original columns.&#39;&#39;&#39;</span>
        <span class="k">return</span><span class="p">(</span> <span class="bp">self</span><span class="o">.</span><span class="n">items</span> <span class="o">//</span> <span class="nb">len</span><span class="p">(</span> <span class="bp">self</span><span class="o">.</span><span class="n">_column_names</span> <span class="p">)</span> <span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">max_lag</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&#39;&#39;&#39;int: Returns the maximum lag currently used in any column in the</span>
<span class="sd">        matrix represented in the mathDict( ) object.</span>

<span class="sd">        This value is recalculated each time there is a change in one of the</span>
<span class="sd">        columns in the matrix, based on the column identifier strings.</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_last_max_lag</span> <span class="o">!=</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">return</span><span class="p">(</span> <span class="bp">self</span><span class="o">.</span><span class="n">_last_max_lag</span> <span class="p">)</span>
        <span class="k">def</span> <span class="nf">column_lag</span><span class="p">(</span> <span class="n">column</span> <span class="p">):</span>
            <span class="k">if</span> <span class="n">column</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_column_names</span><span class="p">:</span>
                <span class="k">return</span><span class="p">(</span> <span class="bp">self</span><span class="o">.</span><span class="n">_orig_padding</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">_column_names</span><span class="o">.</span><span class="n">index</span><span class="p">(</span>
                                                                    <span class="n">column</span> <span class="p">)]</span> <span class="p">)</span>
            <span class="k">return</span><span class="p">(</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">local</span><span class="o">.</span><span class="n">padding</span><span class="p">[</span><span class="n">column</span><span class="p">]</span> <span class="k">if</span> <span class="n">column</span> <span class="ow">in</span> \
                     <span class="bp">self</span><span class="o">.</span><span class="n">local</span><span class="o">.</span><span class="n">padding</span><span class="o">.</span><span class="n">keys</span><span class="p">(</span> <span class="p">)</span> <span class="k">else</span> <span class="mi">0</span><span class="p">)</span> <span class="k">if</span> <span class="n">column</span> <span class="ow">in</span> \
                     <span class="bp">self</span><span class="o">.</span><span class="n">local</span><span class="o">.</span><span class="n">keys</span><span class="p">(</span> <span class="p">)</span> <span class="k">else</span> <span class="kc">None</span> <span class="p">)</span>
        <span class="n">max_lag</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">for</span> <span class="n">column</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">columns</span><span class="p">:</span>
            <span class="n">columns_lag</span> <span class="o">=</span> <span class="n">column_lag</span><span class="p">(</span> <span class="n">column</span> <span class="p">)</span>
            <span class="k">if</span> <span class="n">columns_lag</span> <span class="o">!=</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">max_lag</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span> <span class="n">max_lag</span><span class="p">,</span> <span class="n">columns_lag</span> <span class="p">)</span>
            <span class="k">elif</span> <span class="n">column</span> <span class="o">==</span> <span class="s1">&#39;Intercept&#39;</span><span class="p">:</span>
                <span class="k">pass</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">action</span><span class="p">,</span> <span class="n">mobj_dict</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_interpret_str</span><span class="p">(</span> <span class="n">column</span> <span class="p">)</span>
                <span class="k">for</span> <span class="n">kp</span> <span class="ow">in</span> <span class="p">{</span><span class="s1">&#39;&#39;</span><span class="p">,</span> <span class="s1">&#39;_a&#39;</span><span class="p">,</span> <span class="s1">&#39;_b&#39;</span><span class="p">}:</span>
                    <span class="k">if</span> <span class="s1">&#39;lag&#39;</span> <span class="o">+</span> <span class="n">kp</span> <span class="ow">in</span> <span class="n">mobj_dict</span><span class="o">.</span><span class="n">keys</span><span class="p">(</span> <span class="p">):</span>
                        <span class="n">lag</span> <span class="o">=</span> <span class="n">mobj_dict</span><span class="p">[</span><span class="s1">&#39;lag&#39;</span><span class="o">+</span><span class="n">kp</span><span class="p">]</span>
                        <span class="k">if</span> <span class="n">lag</span> <span class="ow">in</span> <span class="n">NoneSet</span><span class="p">:</span>
                            <span class="n">lag</span> <span class="o">=</span> <span class="mi">0</span>
                        <span class="k">else</span><span class="p">:</span>
                            <span class="n">lag</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span> <span class="n">lag</span> <span class="p">)</span>
                        <span class="k">if</span> <span class="n">kp</span> <span class="o">==</span> <span class="s1">&#39;&#39;</span><span class="p">:</span>
                            <span class="n">lag</span> <span class="o">+=</span> <span class="n">column_lag</span><span class="p">(</span> <span class="n">mobj_dict</span><span class="p">[</span><span class="s1">&#39;column_name&#39;</span><span class="p">]</span> <span class="p">)</span>
                        <span class="k">else</span><span class="p">:</span>
                            <span class="n">lag</span> <span class="o">+=</span> <span class="n">column_lag</span><span class="p">(</span> <span class="n">mobj_dict</span><span class="p">[</span><span class="s1">&#39;column&#39;</span><span class="o">+</span><span class="n">kp</span><span class="p">]</span> <span class="p">)</span>
                        <span class="n">max_lag</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span> <span class="n">max_lag</span><span class="p">,</span> <span class="n">lag</span> <span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_last_max_lag</span> <span class="o">=</span> <span class="n">max_lag</span>
        <span class="k">return</span><span class="p">(</span> <span class="n">max_lag</span> <span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">shape</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&#39;&#39;&#39;tuple(effective row count, column count): The effective row count</span>
<span class="sd">        will be listed even if all columns are masked, resulting in an (n, 0)</span>
<span class="sd">        tuple.</span>

<span class="sd">        Effective row count: The number of rows in the matrix of original</span>
<span class="sd">        columns, less the maximum lag that the mathDict( ) has been configured</span>
<span class="sd">        to support.</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="n">r</span>  <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">rows</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">max_lag</span>
        <span class="n">c</span>  <span class="o">=</span> <span class="nb">len</span><span class="p">(</span> <span class="bp">self</span><span class="o">.</span><span class="n">_column_names</span> <span class="p">)</span> <span class="o">+</span> <span class="mi">1</span>
        <span class="n">c</span> <span class="o">-=</span> <span class="nb">sum</span><span class="p">(</span> <span class="bp">self</span><span class="o">.</span><span class="n">mask</span><span class="p">(</span> <span class="p">)</span> <span class="p">)</span>
        <span class="n">c</span> <span class="o">+=</span> <span class="nb">len</span><span class="p">(</span> <span class="bp">self</span><span class="o">.</span><span class="n">calculated_columns</span><span class="p">(</span> <span class="p">)</span> <span class="p">)</span>
        <span class="n">c</span> <span class="o">+=</span> <span class="nb">len</span><span class="p">(</span> <span class="bp">self</span><span class="o">.</span><span class="n">local</span> <span class="p">)</span>
        <span class="n">c</span> <span class="o">-=</span> <span class="nb">len</span><span class="p">(</span> <span class="bp">self</span><span class="o">.</span><span class="n">local_mask</span><span class="p">(</span> <span class="p">)</span> <span class="p">)</span>
        <span class="k">return</span><span class="p">(</span> <span class="n">r</span><span class="p">,</span> <span class="n">c</span> <span class="p">)</span>

    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">_interpret_str</span><span class="p">(</span> <span class="n">index</span><span class="p">,</span> <span class="n">vector</span><span class="o">=</span><span class="s1">&#39;column&#39;</span><span class="p">,</span> <span class="n">lag</span><span class="o">=</span><span class="kc">None</span> <span class="p">):</span>
        <span class="sd">&#39;&#39;&#39;(for internal use): contains all logic for processing column</span>
<span class="sd">        identifier strings that is not dependent on the particulars of the</span>
<span class="sd">        specific mathDict( ) instance.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        index : string</span>
<span class="sd">            Any string that could be passed into mathDict[`index`]</span>
<span class="sd">            (.__getitem__( index )) to identify result in the form of a single</span>
<span class="sd">            column.</span>
<span class="sd">        vector : {&#39;column&#39;, &#39;row&#39;}, optional</span>
<span class="sd">            The orientation in which the result is to be returned.</span>
<span class="sd">        lag : int, optional</span>
<span class="sd">            Lag should only be specified as a separate parameter when it is not</span>
<span class="sd">            specified within the column identifier string.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        action : string</span>
<span class="sd">            The action to be taken to retrieve or calculate the column (or in</span>
<span class="sd">            the case of an interactions matrix, the matrix) to be returned.</span>
<span class="sd">            This will be the name of a particular mathDict( ) method.</span>
<span class="sd">        dict</span>
<span class="sd">            The keyword arguments to be passed into the method identified in</span>
<span class="sd">            `action`.</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="n">action</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="n">masked_index</span> <span class="o">=</span> <span class="n">mask_brackets</span><span class="p">(</span> <span class="n">index</span> <span class="p">)</span>
        <span class="n">mobj</span> <span class="o">=</span> <span class="n">crosspattern</span><span class="o">.</span><span class="n">fullmatch</span><span class="p">(</span> <span class="n">masked_index</span> <span class="p">)</span>
        <span class="k">if</span> <span class="n">mobj</span> <span class="o">!=</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">mobj_dict</span> <span class="o">=</span> <span class="n">masked_dict</span><span class="p">(</span> <span class="n">index</span><span class="p">,</span> <span class="n">mobj</span> <span class="p">)</span>
            <span class="n">action</span> <span class="o">=</span> <span class="s1">&#39;crossproduct&#39;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">action</span><span class="p">:</span>
            <span class="n">mobj</span> <span class="o">=</span> <span class="n">crosspower</span><span class="o">.</span><span class="n">fullmatch</span><span class="p">(</span> <span class="n">masked_index</span> <span class="p">)</span>
            <span class="k">if</span> <span class="n">mobj</span> <span class="o">!=</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">mobj_dict</span> <span class="o">=</span> <span class="n">masked_dict</span><span class="p">(</span> <span class="n">index</span><span class="p">,</span> <span class="n">mobj</span> <span class="p">)</span>
                <span class="n">action</span> <span class="o">=</span> <span class="s1">&#39;crosspower&#39;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">action</span><span class="p">:</span>
            <span class="n">mobj</span> <span class="o">=</span> <span class="n">powerpattern</span><span class="o">.</span><span class="n">fullmatch</span><span class="p">(</span> <span class="n">masked_index</span> <span class="p">)</span>
            <span class="k">if</span> <span class="n">mobj</span> <span class="o">!=</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">mobj_dict</span> <span class="o">=</span> <span class="n">masked_dict</span><span class="p">(</span> <span class="n">index</span><span class="p">,</span> <span class="n">mobj</span> <span class="p">)</span>
                <span class="k">if</span> <span class="n">mobj_dict</span><span class="p">[</span><span class="s1">&#39;lag&#39;</span><span class="p">]</span> <span class="ow">not</span> <span class="ow">in</span> <span class="p">{</span><span class="kc">None</span><span class="p">,</span> <span class="s1">&#39;&#39;</span><span class="p">}:</span>
                    <span class="k">if</span> <span class="n">lag</span><span class="p">:</span>
                        <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span> <span class="s1">&#39;_handle_str received lag in multiple&#39;</span>
                                         <span class="s1">&#39; forms.&#39;</span> <span class="p">)</span>
                    <span class="n">mobj_dict</span><span class="p">[</span><span class="s1">&#39;lag&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span> <span class="n">mobj_dict</span><span class="p">[</span><span class="s1">&#39;lag&#39;</span><span class="p">]</span> <span class="p">)</span>
                <span class="k">elif</span> <span class="n">lag</span><span class="p">:</span>
                    <span class="n">mobj_dict</span><span class="p">[</span><span class="s1">&#39;lag&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">lag</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">mobj_dict</span><span class="p">[</span><span class="s1">&#39;lag&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>
                <span class="k">if</span> <span class="n">mobj_dict</span><span class="p">[</span><span class="s1">&#39;power&#39;</span><span class="p">]</span> <span class="ow">in</span> <span class="p">{</span><span class="kc">None</span><span class="p">,</span> <span class="s1">&#39;&#39;</span><span class="p">}:</span>
                    <span class="n">action</span> <span class="o">=</span> <span class="s1">&#39;get_column&#39;</span>
                    <span class="k">del</span> <span class="n">mobj_dict</span><span class="p">[</span><span class="s1">&#39;power&#39;</span><span class="p">]</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">action</span> <span class="o">=</span> <span class="s1">&#39;power&#39;</span>
        <span class="k">elif</span> <span class="n">lag</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">mobj_dict</span><span class="p">[</span><span class="s1">&#39;lag_a&#39;</span><span class="p">]</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">NoneSet</span> <span class="ow">or</span> \
               <span class="n">mobj_dict</span><span class="p">[</span><span class="s1">&#39;lag_b&#39;</span><span class="p">]</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">NoneSet</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span>
                                <span class="s1">&#39;_handle_str received lag in multiple forms.&#39;</span> <span class="p">)</span>
            <span class="n">mobj_dict</span><span class="p">[</span><span class="s1">&#39;lag_a&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">lag</span>
            <span class="n">mobj_dict</span><span class="p">[</span><span class="s1">&#39;lag_b&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">lag</span>
        <span class="k">if</span> <span class="n">action</span><span class="p">:</span>
            <span class="n">mobj_dict</span><span class="p">[</span><span class="s1">&#39;vector&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">vector</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">masked_index</span><span class="o">.</span><span class="n">count</span><span class="p">(</span> <span class="s1">&#39;:&#39;</span> <span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">mobj_dict</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;index&#39;</span><span class="p">:</span> <span class="n">index</span><span class="p">,</span> <span class="s1">&#39;masked_index&#39;</span><span class="p">:</span> <span class="n">masked_index</span><span class="p">}</span>
                <span class="n">action</span> <span class="o">=</span> <span class="s1">&#39;_interaction_columns&#39;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">action</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">mathDictKeyError</span><span class="p">(</span>  <span class="s1">&#39;</span><span class="si">%s</span><span class="s1"> is not a valid key.&#39;</span> <span class="o">%</span> <span class="n">index</span>  <span class="p">)</span>
        <span class="k">return</span><span class="p">(</span> <span class="n">action</span><span class="p">,</span> <span class="n">mobj_dict</span> <span class="p">)</span>

    <span class="k">def</span> <span class="nf">_handle_str</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">index</span><span class="p">,</span>
                          <span class="n">vector</span><span class="o">=</span><span class="s1">&#39;column&#39;</span><span class="p">,</span>
                          <span class="n">lag</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                          <span class="n">expanded_columns</span><span class="o">=</span><span class="kc">False</span> <span class="p">):</span>
        <span class="sd">&#39;&#39;&#39;(for internal use): contains logic for processing column identifier</span>
<span class="sd">        strings that is dependent on the particulars of the specific</span>
<span class="sd">        mathDict( ) instance, calling ._interpret_str( ) for non-instance-</span>
<span class="sd">        dependent logic.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        index : string</span>
<span class="sd">            Any string that could be passed into mathDict[`index`]</span>
<span class="sd">            (.__getitem__( index )) to identify result in the form of a single</span>
<span class="sd">            column.</span>
<span class="sd">        vector : {&#39;column&#39;, &#39;row&#39;}, optional</span>
<span class="sd">            The orientation in which the result is to be returned.</span>
<span class="sd">        lag : int, optional</span>
<span class="sd">            Lag should only be specified as a separate parameter when it is not</span>
<span class="sd">            specified within the column identifier string.</span>
<span class="sd">        expanded_columns : bool</span>
<span class="sd">            If true, the list of column identifier strings identifying</span>
<span class="sd">            individual columns in an interactions matrix is returned after the</span>
<span class="sd">            first two return values when and only when the action identified in</span>
<span class="sd">            `index` is an interactions matrix.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        action : string</span>
<span class="sd">            The action to be taken to retrieve or calculate the column (or in</span>
<span class="sd">            the case of an interactions matrix, the matrix) to be returned.</span>
<span class="sd">            This will be the name of a particular mathDict( ) method.</span>
<span class="sd">        dict</span>
<span class="sd">            The keyword arguments to be passed into the method identified in</span>
<span class="sd">            `action`.</span>
<span class="sd">        columns : list of strings</span>
<span class="sd">            The column identifier strings for the individual columns in the</span>
<span class="sd">            interactions matrix, if applicable.</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="n">action</span><span class="p">,</span> <span class="n">mobj_dict</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_interpret_str</span><span class="p">(</span> <span class="n">index</span><span class="p">,</span>
                                                 <span class="n">vector</span><span class="o">=</span><span class="n">vector</span><span class="p">,</span>
                                                 <span class="n">lag</span><span class="o">=</span><span class="n">lag</span> <span class="p">)</span>
        <span class="k">if</span> <span class="n">action</span> <span class="o">==</span> <span class="s1">&#39;_interaction_columns&#39;</span><span class="p">:</span>
            <span class="n">columns</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_interaction_columns</span><span class="p">(</span> <span class="o">**</span><span class="n">mobj_dict</span> <span class="p">)</span>
            <span class="n">action</span> <span class="o">=</span> <span class="s1">&#39;_mat&#39;</span>
            <span class="n">mobj_dict</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;column_indexes&#39;</span><span class="p">:</span> <span class="n">columns</span><span class="p">}</span>
            <span class="k">if</span> <span class="n">expanded_columns</span><span class="p">:</span>
                <span class="k">return</span><span class="p">(</span> <span class="n">action</span><span class="p">,</span> <span class="n">mobj_dict</span><span class="p">,</span> <span class="n">columns</span> <span class="p">)</span>
        <span class="k">return</span><span class="p">(</span> <span class="n">action</span><span class="p">,</span> <span class="n">mobj_dict</span> <span class="p">)</span>

<div class="viewcode-block" id="mathDict.__getitem__"><a class="viewcode-back" href="../ParallelRegression.html#ParallelRegression.mathDict.__getitem__">[docs]</a>    <span class="k">def</span> <span class="nf">__getitem__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">index</span><span class="p">,</span> <span class="n">vector</span><span class="o">=</span><span class="s1">&#39;column&#39;</span><span class="p">,</span> <span class="n">lag</span><span class="o">=</span><span class="kc">None</span> <span class="p">):</span>
        <span class="sd">&#39;&#39;&#39;Returns the matrix represented by the mathDict( ) or a portion</span>
<span class="sd">        thereof.</span>

<span class="sd">        **Supported Notation**</span>

<span class="sd">        ------------------</span>
<span class="sd">        str -&gt; returns one vertical array</span>
<span class="sd">            A string can be the name of one column or the formula for one</span>
<span class="sd">            column that can be calculated from the original columns.  No check</span>
<span class="sd">            is performed to ensure that referenced columns are unmasked.</span>
<span class="sd">        int -&gt; returns one vertical array</span>
<span class="sd">            A single integer will return the corresponding column in the matrix</span>
<span class="sd">            represented by the mathDict( ) object.</span>
<span class="sd">        int(m):int(n) slice -&gt; returns a matrix with `n` - `m` columns.</span>
<span class="sd">            A slice with start and or stop specified will return the</span>
<span class="sd">            corresponding column in the matrix represented by the mathDict( ).</span>
<span class="sd">            A slice with neither specified will return the entire matrix</span>
<span class="sd">            represented by the mathDict( ).  This includes local columns and</span>
<span class="sd">            calculated_columns listed in the calculated_columns attribute, but</span>
<span class="sd">            does not include masked columns.</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        str : &#39;a&#39;</span>
<span class="sd">            Returns column &#39;a&#39;.</span>
<span class="sd">        str : &#39;a * b&#39;</span>
<span class="sd">            Returns a column in which each row i is &#39;a&#39;[i] * &#39;b&#39;[i].</span>
<span class="sd">        str : &#39;L2@a&#39;</span>
<span class="sd">            Returns the second lag of column &#39;a&#39;.  (Case sensitive.)</span>
<span class="sd">        int : 0</span>
<span class="sd">            If the first value in the mask sequence is False, this will return</span>
<span class="sd">            a column of ones.  The data type of cells in the Intercept column</span>
<span class="sd">            will match the first column in the matrix of original columns.</span>
<span class="sd">        slice : [:]</span>
<span class="sd">            This will return the Intercept column of ones unless masked,</span>
<span class="sd">            unmasked columns in the matrix of original columns, unmasked local</span>
<span class="sd">            columns, and finally calculated columns.</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="n">INTERNAL_NOTES</span>  <span class="o">=</span> <span class="s1">&#39;&#39;&#39;</span>
<span class="s1">        Parameters</span>
<span class="s1">        ----------</span>
<span class="s1">        index : int, slice, or str</span>
<span class="s1">            See above.</span>
<span class="s1">        vector : {&#39;column&#39;, &#39;row&#39;}, optional</span>
<span class="s1">            Passed on to column retrieval methods when used by ._mat( ) to get</span>
<span class="s1">            calculated columns.</span>

<span class="s1">        Notes</span>
<span class="s1">        -----</span>
<span class="s1">        All logic translating column numbers in the matrix represented by the</span>
<span class="s1">        mathDict( ) to index numbers/keys of stored columns is contained here.</span>
<span class="s1">        &#39;&#39;&#39;</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span> <span class="n">index</span><span class="p">,</span> <span class="nb">str</span> <span class="p">):</span>
            <span class="n">indexTpl</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_handle_str</span><span class="p">(</span> <span class="n">index</span><span class="p">,</span>
                                      <span class="n">vector</span><span class="o">=</span><span class="n">vector</span><span class="p">,</span>
                                      <span class="n">lag</span><span class="o">=</span><span class="n">lag</span> <span class="p">)</span>
            <span class="n">action</span> <span class="o">=</span> <span class="n">indexTpl</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
            <span class="n">mobj_dict</span> <span class="o">=</span> <span class="n">indexTpl</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
            <span class="k">for</span> <span class="n">key</span> <span class="ow">in</span> <span class="p">{</span><span class="s1">&#39;column_name&#39;</span><span class="p">,</span> <span class="s1">&#39;column_a&#39;</span><span class="p">,</span> <span class="s1">&#39;column_b&#39;</span><span class="p">}:</span>
                <span class="k">if</span> <span class="n">key</span> <span class="ow">in</span> <span class="n">mobj_dict</span><span class="o">.</span><span class="n">keys</span><span class="p">(</span> <span class="p">):</span>
                    <span class="k">if</span> <span class="n">mobj_dict</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_column_names</span> <span class="ow">and</span> \
                       <span class="n">mobj_dict</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">local</span><span class="o">.</span><span class="n">key_list</span><span class="p">:</span>
                        <span class="k">raise</span> <span class="n">mathDictKeyError</span><span class="p">(</span> <span class="s1">&#39;</span><span class="si">%s</span><span class="s1"> is neither a column in the&#39;</span>
                              <span class="s1">&#39; shared data matrix nor a column in the local &#39;</span>
                              <span class="s1">&#39;data store.&#39;</span> <span class="o">%</span> <span class="n">key</span> <span class="p">)</span>
            <span class="k">return</span><span class="p">(</span> <span class="nb">getattr</span><span class="p">(</span> <span class="bp">self</span><span class="p">,</span> <span class="n">action</span> <span class="p">)(</span> <span class="o">**</span><span class="n">mobj_dict</span> <span class="p">)</span> <span class="p">)</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span> <span class="n">index</span><span class="p">,</span> <span class="nb">int</span> <span class="p">):</span>
            <span class="k">if</span> <span class="n">index</span> <span class="o">==</span> <span class="mi">0</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">mask</span><span class="p">(</span> <span class="p">)[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="kc">False</span><span class="p">:</span>
                <span class="k">return</span><span class="p">(</span> <span class="bp">self</span><span class="o">.</span><span class="n">power</span><span class="p">(</span> <span class="bp">self</span><span class="o">.</span><span class="n">_column_names</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span>
                                    <span class="mi">0</span><span class="p">,</span>
                                    <span class="n">vector</span><span class="o">=</span><span class="n">vector</span><span class="p">,</span>
                                    <span class="n">lag</span><span class="o">=</span><span class="n">lag</span> <span class="p">)</span> <span class="p">)</span>
            <span class="n">index</span> <span class="o">=</span> <span class="nb">slice</span><span class="p">(</span> <span class="n">index</span><span class="p">,</span> <span class="n">index</span><span class="o">+</span><span class="mi">1</span> <span class="p">)</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span> <span class="n">index</span><span class="p">,</span> <span class="nb">slice</span> <span class="p">):</span>
            <span class="k">if</span> <span class="n">index</span><span class="o">.</span><span class="n">step</span> <span class="o">!=</span> <span class="kc">None</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">KeyError</span><span class="p">(</span> <span class="s1">&#39;Steps are not supported&#39;</span> <span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">xes</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span> <span class="p">)</span> <span class="c1">#.................... xes = list of all colums to</span>
                                                  <span class="c1"># return as part of the slice</span>
                <span class="n">ind</span> <span class="o">=</span> <span class="mi">0</span> <span class="c1">#.......................... ind = index of the column</span>
                                                  <span class="c1"># in the matrix represented</span>
                                                  <span class="c1"># by the mathDict( ) object</span>
                                                  <span class="c1"># that is currently being</span>
                                                  <span class="c1"># identified</span>
                <span class="c1">## val_if_present( ) replaces None with the default, whereas</span>
                <span class="c1">## getattr( ) does not.</span>
                <span class="n">start</span> <span class="o">=</span> <span class="n">val_if_present</span><span class="p">(</span> <span class="n">index</span><span class="p">,</span> <span class="s1">&#39;start&#39;</span><span class="p">,</span> <span class="mi">0</span> <span class="p">)</span>
                <span class="n">stop</span> <span class="o">=</span> <span class="n">val_if_present</span><span class="p">(</span> <span class="n">index</span><span class="p">,</span> <span class="s1">&#39;stop&#39;</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="p">)</span>
                <span class="k">if</span> <span class="n">stop</span> <span class="o">&gt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]:</span>
                    <span class="k">raise</span> <span class="ne">IndexError</span><span class="p">(</span> <span class="s1">&#39;Outer-bound of slice, </span><span class="si">%d</span><span class="s1">, exceeds the &#39;</span>
                                      <span class="s1">&#39;number of columns, </span><span class="si">%d</span><span class="s1">.&#39;</span>
                                      <span class="o">%</span> <span class="p">(</span><span class="n">stop</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span> <span class="p">)</span>
                <span class="c1">###############################################################</span>
                <span class="c1">## Except here, ind is incremented when a column is determined#</span>
                <span class="c1">## to be part of the matrix.  ind = n after original matrix   #</span>
                <span class="c1">## columns 0, 1, ..., n-1 if all are unmasked.  If there are  #</span>
                <span class="c1">## n+1 columns including the Intercept, then ind = n is the   #</span>
                <span class="c1">## correct stopping point, and the Intercept column still has #</span>
                <span class="c1">## to get included.                                           #</span>
                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">mask</span><span class="p">(</span> <span class="p">)[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="kc">False</span><span class="p">:</span>                                 <span class="c1">##</span>
                    <span class="n">stop</span> <span class="o">-=</span> <span class="mi">1</span>                                                <span class="c1">##</span>
                    <span class="k">if</span> <span class="n">start</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>                                           <span class="c1">##</span>
                        <span class="n">xes</span><span class="o">.</span><span class="n">append</span><span class="p">(</span> <span class="o">-</span><span class="mi">1</span> <span class="p">)</span>                                     <span class="c1">##</span>
                    <span class="k">else</span><span class="p">:</span>                                                    <span class="c1">##</span>
                        <span class="n">start</span> <span class="o">-=</span> <span class="mi">1</span>                                           <span class="c1">##</span>
                <span class="c1">###############################################################</span>
                <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span> <span class="nb">len</span><span class="p">(</span> <span class="bp">self</span><span class="o">.</span><span class="n">_column_names</span> <span class="p">)</span> <span class="p">):</span>
                    <span class="c1"># i = index of the original matrix column currently being</span>
                    <span class="c1"># considered</span>
                    <span class="k">if</span> <span class="n">i</span><span class="o">+</span><span class="mi">1</span> <span class="o">&gt;=</span> <span class="nb">len</span><span class="p">(</span> <span class="bp">self</span><span class="o">.</span><span class="n">mask</span><span class="p">(</span> <span class="p">)</span> <span class="p">)</span> <span class="ow">or</span> \
                       <span class="bp">self</span><span class="o">.</span><span class="n">mask</span><span class="p">(</span> <span class="p">)[</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="kc">False</span><span class="p">:</span>
                        <span class="k">if</span> <span class="n">ind</span> <span class="o">&gt;=</span> <span class="n">start</span> <span class="ow">and</span> <span class="n">ind</span> <span class="o">&lt;</span> <span class="n">stop</span><span class="p">:</span>
                            <span class="n">xes</span><span class="o">.</span><span class="n">append</span><span class="p">(</span> <span class="n">i</span> <span class="p">)</span> <span class="c1"># Adding original column index int</span>
                        <span class="n">ind</span> <span class="o">+=</span> <span class="mi">1</span>
                        <span class="k">if</span> <span class="n">ind</span> <span class="o">==</span> <span class="n">stop</span><span class="p">:</span>
                            <span class="k">break</span>
                <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span> <span class="nb">len</span><span class="p">(</span> <span class="bp">self</span><span class="o">.</span><span class="n">local</span><span class="o">.</span><span class="n">keys</span><span class="p">(</span> <span class="p">)</span> <span class="p">)</span> <span class="p">):</span>
                    <span class="c1"># i = index of the local column currently being considered</span>
                    <span class="k">if</span> <span class="n">ind</span> <span class="o">==</span> <span class="n">stop</span><span class="p">:</span>
                        <span class="k">break</span>
                    <span class="n">key</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">local</span><span class="o">.</span><span class="n">key_list</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
                    <span class="k">if</span> <span class="n">key</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">local_mask</span><span class="p">(</span> <span class="p">):</span>
                        <span class="k">if</span> <span class="n">ind</span> <span class="o">&gt;=</span> <span class="n">start</span> <span class="ow">and</span> <span class="n">ind</span> <span class="o">&lt;</span> <span class="n">stop</span><span class="p">:</span>
                            <span class="n">xes</span><span class="o">.</span><span class="n">append</span><span class="p">(</span> <span class="n">key</span> <span class="p">)</span> <span class="c1"># Adding local column key string</span>
                        <span class="n">ind</span> <span class="o">+=</span> <span class="mi">1</span>
                <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span> <span class="nb">len</span><span class="p">(</span> <span class="bp">self</span><span class="o">.</span><span class="n">calculated_columns</span><span class="p">(</span> <span class="p">)</span> <span class="p">)</span> <span class="p">):</span>
                    <span class="c1"># i = index of the calculated column currently being</span>
                    <span class="c1"># considered</span>
                    <span class="k">if</span> <span class="n">ind</span> <span class="o">==</span> <span class="n">stop</span><span class="p">:</span>
                        <span class="k">break</span>
                    <span class="k">if</span> <span class="n">ind</span> <span class="o">&gt;=</span> <span class="n">start</span> <span class="ow">and</span> <span class="n">ind</span> <span class="o">&lt;</span> <span class="n">stop</span><span class="p">:</span>
                        <span class="n">xes</span><span class="o">.</span><span class="n">append</span><span class="p">(</span> <span class="bp">self</span><span class="o">.</span><span class="n">calculated_columns</span><span class="p">(</span> <span class="p">)[</span><span class="n">i</span><span class="p">]</span> <span class="p">)</span>
                               <span class="c1"># Adding calculated column string</span>
                    <span class="n">ind</span> <span class="o">+=</span> <span class="mi">1</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="n">lag</span><span class="p">:</span>
                    <span class="n">lag</span> <span class="o">=</span> <span class="mi">0</span>
                <span class="k">return</span><span class="p">(</span> <span class="bp">self</span><span class="o">.</span><span class="n">_mat</span><span class="p">(</span> <span class="n">xes</span><span class="p">,</span> <span class="n">lag</span><span class="o">=</span><span class="n">lag</span> <span class="p">)</span> <span class="p">)</span></div>

    <span class="k">def</span> <span class="nf">_interaction_columns</span><span class="p">(</span> <span class="bp">self</span><span class="p">,</span> <span class="n">index</span><span class="p">,</span> <span class="n">masked_index</span> <span class="p">):</span>
        <span class="sd">&#39;&#39;&#39;(for internal use): takes a column identifier string identifying an</span>
<span class="sd">        interactions matrix in its original and masked form, and returns the</span>
<span class="sd">        list of column identifier strings for the individual columns that are</span>
<span class="sd">        actually stored in the mathDict( ), whether as local or shared columns.</span>

<span class="sd">        If no such columns exist, then .local.interactions_matrix( ) is called</span>
<span class="sd">        in order to calculate them.</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="n">terms</span><span class="p">,</span> <span class="n">real_term</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">local</span><span class="o">.</span><span class="n">_inter_col_terms</span><span class="p">(</span> <span class="n">index</span><span class="p">,</span> <span class="n">masked_index</span> <span class="p">)</span>
        <span class="n">column_name_pattern</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span> <span class="p">)</span>
        <span class="k">for</span> <span class="n">t</span> <span class="ow">in</span> <span class="n">terms</span><span class="p">:</span>
            <span class="n">column_name_pattern</span><span class="o">.</span><span class="n">append</span><span class="p">(</span> <span class="n">re</span><span class="o">.</span><span class="n">escape</span><span class="p">(</span> <span class="n">t</span> <span class="p">)</span> <span class="o">+</span> <span class="s1">&#39;=[0-1]&#39;</span> <span class="p">)</span>
        <span class="n">column_name_pattern</span> <span class="o">=</span> <span class="s1">&#39;\(&#39;</span> <span class="o">+</span> <span class="s1">&#39;:&#39;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span> <span class="n">column_name_pattern</span> <span class="p">)</span>
        <span class="k">if</span> <span class="n">real_term</span> <span class="o">!=</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">column_name_pattern</span> <span class="o">+=</span> <span class="s1">&#39;:&#39;</span> <span class="o">+</span> <span class="n">re</span><span class="o">.</span><span class="n">escape</span><span class="p">(</span> <span class="n">real_term</span> <span class="p">)</span>
        <span class="n">column_name_pattern</span> <span class="o">+=</span> <span class="s1">&#39;\)&#39;</span>
        <span class="n">repatt</span> <span class="o">=</span> <span class="n">re</span><span class="o">.</span><span class="n">compile</span><span class="p">(</span> <span class="n">column_name_pattern</span> <span class="p">)</span>
        <span class="n">ret</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span> <span class="p">)</span>
        <span class="k">for</span> <span class="n">column</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_column_names</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">repatt</span><span class="o">.</span><span class="n">fullmatch</span><span class="p">(</span> <span class="n">column</span> <span class="p">)</span> <span class="o">!=</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">ret</span><span class="o">.</span><span class="n">append</span><span class="p">(</span> <span class="n">column</span> <span class="p">)</span>
        <span class="k">for</span> <span class="n">column</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">local</span><span class="o">.</span><span class="n">key_list</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">repatt</span><span class="o">.</span><span class="n">fullmatch</span><span class="p">(</span> <span class="n">column</span> <span class="p">)</span> <span class="o">!=</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">ret</span><span class="o">.</span><span class="n">append</span><span class="p">(</span> <span class="n">column</span> <span class="p">)</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span> <span class="n">ret</span> <span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">return</span><span class="p">(</span> <span class="n">ret</span> <span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">local</span><span class="o">.</span><span class="n">interactions_matrix</span><span class="p">(</span> <span class="n">terms</span><span class="p">,</span> <span class="n">real_term</span> <span class="p">)</span>
            <span class="n">ret</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_interaction_columns</span><span class="p">(</span> <span class="n">index</span><span class="p">,</span> <span class="n">masked_index</span> <span class="p">)</span>
            <span class="k">for</span> <span class="n">column</span> <span class="ow">in</span> <span class="n">ret</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">set_mask</span><span class="p">(</span> <span class="n">column</span> <span class="p">)</span>
            <span class="k">return</span><span class="p">(</span> <span class="n">ret</span> <span class="p">)</span>

    <span class="k">def</span> <span class="nf">__setitem__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">key</span><span class="p">,</span> <span class="n">value</span> <span class="p">):</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span> <span class="n">value</span> <span class="p">)</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">rows</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">local</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="n">value</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">local</span><span class="o">.</span><span class="n">savePaddedColumn</span><span class="p">(</span> <span class="n">key</span><span class="p">,</span> <span class="n">value</span> <span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">_ofs_start</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">numcols</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span> <span class="bp">self</span><span class="o">.</span><span class="n">_column_names</span> <span class="p">)</span>
        <span class="n">cp_len</span>  <span class="o">=</span> <span class="n">math</span><span class="o">.</span><span class="n">factorial</span><span class="p">(</span> <span class="n">numcols</span> <span class="p">)</span> \
                  <span class="o">//</span> <span class="mi">2</span> \
                  <span class="o">//</span> <span class="n">math</span><span class="o">.</span><span class="n">factorial</span><span class="p">(</span> <span class="n">numcols</span> <span class="o">-</span> <span class="mi">2</span> <span class="p">)</span>
        <span class="n">pwr_len</span> <span class="o">=</span> <span class="n">numcols</span> <span class="o">*</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">cache_powers</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span>
        <span class="n">cp_start</span><span class="p">,</span> <span class="n">pwr_start</span> <span class="o">=</span> <span class="n">numcols</span><span class="p">,</span> <span class="n">numcols</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">cache_crossproducts</span><span class="p">:</span>
            <span class="n">pwr_start</span> <span class="o">+=</span> <span class="n">cp_len</span>
        <span class="k">return</span><span class="p">(</span> <span class="n">cp_start</span><span class="p">,</span> <span class="n">pwr_start</span> <span class="p">)</span>

    <span class="k">def</span> <span class="nf">_ofs</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">internal_column_index</span><span class="p">,</span> <span class="n">lag</span><span class="o">=</span><span class="mi">0</span> <span class="p">):</span>
        <span class="sd">&#39;&#39;&#39;(for internal use).</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        interior_column_index : int</span>
<span class="sd">            the index number of the column in the shared data array, whether an</span>
<span class="sd">            original column or cached, calculated column.</span>
<span class="sd">        lag : int, optional</span>
<span class="sd">            This many rows towards the top of the matrix will be unhidden,</span>
<span class="sd">            without changing the total number of rows returned.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        the offset in the shared data array at which the column with the</span>
<span class="sd">        specified index number begins, adjusted to hide rows as necessary to</span>
<span class="sd">        reserve sufficient data for lags.  Error checking for appropriate lag</span>
<span class="sd">        values occurs in .vec( ) in order to have the same set of code apply to</span>
<span class="sd">        lagged local columns as well as lagged shared columns.</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="n">ofs</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">rows</span> <span class="o">*</span> <span class="n">internal_column_index</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">itemsize</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">lag</span> <span class="o">==</span> <span class="s1">&#39;cheat&#39;</span><span class="p">:</span>
            <span class="n">ofs</span> <span class="o">+=</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">max_lag</span> <span class="o">-</span> <span class="n">lag</span><span class="p">)</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">itemsize</span>
        <span class="k">return</span><span class="p">(</span> <span class="n">ofs</span> <span class="p">)</span>

    <span class="k">def</span> <span class="nf">_vec</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">internal_column</span><span class="p">,</span> <span class="n">lag</span><span class="o">=</span><span class="mi">0</span> <span class="p">):</span>
        <span class="sd">&#39;&#39;&#39;(for internal use): returns the column of the shared data array at</span>
<span class="sd">        the requested index, in row vector/horizontal array form.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        internal_column : int or str</span>
<span class="sd">            Either an integer index for a column in the shared data array, or a</span>
<span class="sd">            string identifying either a column in the matrix of original</span>
<span class="sd">            columns or a local column by name.  Strings are accepted in order</span>
<span class="sd">            to allow calculated column retrieval methods to retrieve base</span>
<span class="sd">            columns via .get_column( ) without distinguishing between types.</span>
<span class="sd">        lag : int, optional</span>
<span class="sd">            (See ._ofs( ) docstring.)</span>

<span class="sd">        Special Values</span>
<span class="sd">        --------------</span>
<span class="sd">        - 1</span>
<span class="sd">            Returns `self[0]` for use representing the Intercept column in a</span>
<span class="sd">            list of column indexes.</span>

<span class="sd">        Raises</span>
<span class="sd">        ------</span>
<span class="sd">        ValueError</span>
<span class="sd">            If the requested lag exceeds self.max_lag.  The .max_lag attribute</span>
<span class="sd">            must be set prior to adding and/or retrieving columns involving</span>
<span class="sd">            lagged values.</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span> <span class="n">internal_column</span><span class="p">,</span> <span class="nb">str</span> <span class="p">):</span>
            <span class="k">if</span> <span class="n">internal_column</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_column_names</span><span class="p">:</span>
                <span class="n">internal_column</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_column_names</span><span class="o">.</span><span class="n">index</span><span class="p">(</span> <span class="n">internal_column</span> <span class="p">)</span>
            <span class="k">elif</span> <span class="n">internal_column</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">local</span><span class="o">.</span><span class="n">keys</span><span class="p">(</span> <span class="p">):</span>
                <span class="n">arr</span><span class="p">,</span> <span class="n">dt</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">local</span><span class="o">.</span><span class="n">_toBytes</span><span class="p">(</span> <span class="n">internal_column</span><span class="p">,</span> <span class="n">lag</span><span class="o">=</span><span class="n">lag</span> <span class="p">)</span>
                <span class="n">ret</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">fromstring</span><span class="p">(</span> <span class="n">arr</span><span class="p">,</span> <span class="n">dt</span> <span class="p">)</span>
        <span class="k">if</span> <span class="n">internal_column</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">:</span>
            <span class="k">return</span><span class="p">(</span> <span class="bp">self</span><span class="o">.</span><span class="n">power</span><span class="p">(</span> <span class="bp">self</span><span class="o">.</span><span class="n">_column_names</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="mi">0</span><span class="p">,</span> <span class="n">vector</span><span class="o">=</span><span class="s1">&#39;row&#39;</span> <span class="p">)</span> <span class="p">)</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span> <span class="n">internal_column</span><span class="p">,</span> <span class="nb">int</span> <span class="p">):</span>
            <span class="n">ofs</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_ofs</span><span class="p">(</span> <span class="n">internal_column</span><span class="p">,</span> <span class="n">lag</span><span class="o">=</span><span class="n">lag</span> <span class="p">)</span>
            <span class="n">dt</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">dtypes</span><span class="p">[</span><span class="n">internal_column</span><span class="p">]</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">lag</span> <span class="o">==</span> <span class="s1">&#39;cheat&#39;</span><span class="p">:</span>
                <span class="n">count</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">count</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">rows</span>
            <span class="n">ret</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">frombuffer</span><span class="p">(</span> <span class="bp">self</span><span class="o">.</span><span class="n">buffer</span><span class="p">,</span>
                                 <span class="n">dtype</span><span class="o">=</span><span class="n">dt</span><span class="p">,</span>
                                 <span class="n">count</span><span class="o">=</span><span class="n">count</span><span class="p">,</span>
                                 <span class="n">offset</span><span class="o">=</span><span class="n">ofs</span>
                                 <span class="p">)</span>
        <span class="k">if</span> <span class="s1">&#39;ret&#39;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="nb">dir</span><span class="p">(</span> <span class="p">):</span>
            <span class="k">raise</span> <span class="n">mathDictKeyError</span><span class="p">(</span> <span class="s1">&#39;</span><span class="si">%s</span><span class="s1"> is not a valid column identifier.&#39;</span>
                                    <span class="o">%</span> <span class="n">internal_column</span> <span class="p">)</span>
        <span class="k">return</span><span class="p">(</span> <span class="n">ret</span> <span class="p">)</span>

    <span class="k">def</span> <span class="nf">_mat</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">column_indexes</span><span class="p">,</span> <span class="n">lag</span><span class="o">=</span><span class="mi">0</span> <span class="p">):</span>
        <span class="sd">&#39;&#39;&#39;(for internal use): returns a matrix consisting of columns specified</span>
<span class="sd">        by their internal column identifier (index or local column name) in the</span>
<span class="sd">        column_indexes list.  Strings in the column_indexes list other than</span>
<span class="sd">        internal column identifiers are assumed to be calculated columns.  They</span>
<span class="sd">        are retrieved by through the .__getitem__( ) method that checks for</span>
<span class="sd">        pre-calculated columns by way of .power( ) and .crossproduct( ) before</span>
<span class="sd">        calculating a column.</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="n">ret</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span> <span class="p">)</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span> <span class="nb">len</span><span class="p">(</span> <span class="n">column_indexes</span> <span class="p">)</span> <span class="p">):</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span> <span class="n">column_indexes</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="nb">str</span> <span class="p">)</span> <span class="ow">and</span> \
               <span class="n">column_indexes</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">local</span><span class="o">.</span><span class="n">keys</span><span class="p">(</span> <span class="p">)</span> <span class="ow">and</span> \
               <span class="n">column_indexes</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_column_names</span><span class="p">:</span>
                <span class="n">ret</span><span class="o">.</span><span class="n">append</span><span class="p">(</span> <span class="bp">self</span><span class="o">.</span><span class="n">__getitem__</span><span class="p">(</span> <span class="n">column_indexes</span><span class="p">[</span><span class="n">i</span><span class="p">],</span>
                                              <span class="n">vector</span><span class="o">=</span><span class="s1">&#39;row&#39;</span> <span class="p">)</span> <span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">ret</span><span class="o">.</span><span class="n">append</span><span class="p">(</span> <span class="bp">self</span><span class="o">.</span><span class="n">_vec</span><span class="p">(</span> <span class="n">column_indexes</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">lag</span><span class="o">=</span><span class="n">lag</span> <span class="p">)</span> <span class="p">)</span>
        <span class="n">ret</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">stack</span><span class="p">(</span> <span class="n">ret</span><span class="p">,</span> <span class="mi">1</span> <span class="p">)</span>
        <span class="k">return</span><span class="p">(</span> <span class="n">ret</span> <span class="p">)</span>

<div class="viewcode-block" id="mathDict.get_column"><a class="viewcode-back" href="../ParallelRegression.html#ParallelRegression.mathDict.get_column">[docs]</a>    <span class="k">def</span> <span class="nf">get_column</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">column_name</span><span class="p">,</span> <span class="n">lag</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">vector</span><span class="o">=</span><span class="s1">&#39;column&#39;</span> <span class="p">):</span>
        <span class="sd">&#39;&#39;&#39;Returns the column with the specified name from either the matrix of</span>
<span class="sd">        original columns or the local column store.</span>

<span class="sd">        No check is performed to ensure that the requested column is not</span>
<span class="sd">        masked, and calculated columns are not returned.</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="n">INTERNAL_NOTE</span> <span class="o">=</span> <span class="s1">&#39;&#39;&#39;</span>
<span class="s1">        All columns are stored as 1-dimensional arrays, which numpy perceives</span>
<span class="s1">        as row vectors unless they are transposed.  Except for when a slice or</span>
<span class="s1">        integer subscript causes .__getitem__( ) to call ._mat( ) directly,</span>
<span class="s1">        other methods pass `vector`(=&#39;column&#39; by default) to .get_column( ) so</span>
<span class="s1">        that .get_column( ) can transpose the vector.  Stored vectors are</span>
<span class="s1">        transposed via .get_column( ) calling ._mat( ) prior to manipulation or</span>
<span class="s1">        return by single-column-return methods such as .power( ) and</span>
<span class="s1">        .crossproduct( ).</span>
<span class="s1">        &#39;&#39;&#39;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">lag</span><span class="p">:</span>
            <span class="n">lag</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">if</span> <span class="n">vector</span> <span class="o">==</span> <span class="s1">&#39;column&#39;</span><span class="p">:</span>
            <span class="n">ret</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_mat</span><span class="p">(</span> <span class="p">[</span><span class="n">column_name</span><span class="p">],</span> <span class="n">lag</span><span class="o">=</span><span class="n">lag</span> <span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">ret</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_vec</span><span class="p">(</span> <span class="n">column_name</span><span class="p">,</span> <span class="n">lag</span><span class="o">=</span><span class="n">lag</span> <span class="p">)</span>
        <span class="k">return</span><span class="p">(</span> <span class="n">ret</span> <span class="p">)</span></div>

<div class="viewcode-block" id="mathDict.power"><a class="viewcode-back" href="../ParallelRegression.html#ParallelRegression.mathDict.power">[docs]</a>    <span class="k">def</span> <span class="nf">power</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">column_name</span><span class="p">,</span> <span class="n">power</span><span class="p">,</span> <span class="n">lag</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">vector</span><span class="o">=</span><span class="s1">&#39;column&#39;</span> <span class="p">):</span>
        <span class="sd">&#39;&#39;&#39;Returns the requested column with each cell raised to the requested</span>
<span class="sd">        power.  Checks to see if the power has been pre-calculated and returns</span>
<span class="sd">        the pre-calculated column if present.</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span> <span class="n">power</span><span class="p">,</span> <span class="nb">str</span> <span class="p">):</span>
            <span class="k">if</span> <span class="n">power</span><span class="o">.</span><span class="n">isdigit</span><span class="p">(</span> <span class="p">):</span>
                <span class="n">power</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span> <span class="n">power</span> <span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span> <span class="s1">&#39;</span><span class="si">%s</span><span class="s1"> is not a valid power.&#39;</span> <span class="o">%</span> <span class="n">power</span> <span class="p">)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">cache_powers</span> <span class="o">&gt;=</span> <span class="n">power</span> <span class="ow">and</span> \
           <span class="n">power</span> <span class="o">&gt;</span> <span class="mi">1</span> <span class="ow">and</span> \
           <span class="n">column_name</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_column_names</span><span class="p">:</span>
            <span class="n">index_base</span><span class="p">,</span> <span class="n">index</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_ofs_start</span>
            <span class="n">index</span> <span class="o">+=</span> <span class="nb">len</span><span class="p">(</span> <span class="bp">self</span><span class="o">.</span><span class="n">_column_names</span> <span class="p">)</span> <span class="o">*</span> <span class="p">(</span><span class="n">power</span> <span class="o">-</span> <span class="mi">2</span><span class="p">)</span>
            <span class="n">index</span> <span class="o">+=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_column_names</span><span class="o">.</span><span class="n">index</span><span class="p">(</span> <span class="n">column_name</span> <span class="p">)</span>
            <span class="n">ret</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_column</span><span class="p">(</span> <span class="n">index</span><span class="p">,</span> <span class="n">lag</span><span class="o">=</span><span class="n">lag</span><span class="p">,</span> <span class="n">vector</span><span class="o">=</span><span class="n">vector</span> <span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">ret</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_column</span><span class="p">(</span> <span class="n">column_name</span><span class="p">,</span> <span class="n">lag</span><span class="o">=</span><span class="n">lag</span><span class="p">,</span> <span class="n">vector</span><span class="o">=</span><span class="n">vector</span> <span class="p">)</span>
            <span class="n">ret</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">power</span><span class="p">(</span> <span class="n">ret</span><span class="p">,</span> <span class="n">power</span> <span class="p">)</span>
        <span class="k">return</span><span class="p">(</span> <span class="n">ret</span> <span class="p">)</span></div>

<div class="viewcode-block" id="mathDict.crosspower"><a class="viewcode-back" href="../ParallelRegression.html#ParallelRegression.mathDict.crosspower">[docs]</a>    <span class="k">def</span> <span class="nf">crosspower</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">column_a</span><span class="p">,</span> <span class="n">power_a</span><span class="p">,</span> <span class="n">column_b</span><span class="p">,</span> <span class="n">power_b</span><span class="p">,</span>
                   <span class="n">lag_a</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">lag_b</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">vector</span><span class="o">=</span><span class="s1">&#39;column&#39;</span> <span class="p">):</span>
        <span class="sd">&#39;&#39;&#39;Returns the product of two columns, each raised to the specified</span>
<span class="sd">        power.  Makes use of precalculated columns if applicable.</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="n">NoneSet</span> <span class="o">=</span> <span class="p">{</span><span class="kc">None</span><span class="p">,</span> <span class="s1">&#39;&#39;</span><span class="p">}</span>
        <span class="c1"># Lags</span>
        <span class="k">if</span> <span class="n">lag_a</span> <span class="ow">in</span> <span class="n">NoneSet</span><span class="p">:</span>
            <span class="n">lag_a</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">lag_a</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span> <span class="n">lag_a</span> <span class="p">)</span>
        <span class="k">if</span> <span class="n">lag_b</span> <span class="ow">in</span> <span class="n">NoneSet</span><span class="p">:</span>
            <span class="n">lag_b</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">lag_b</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span> <span class="n">lag_b</span> <span class="p">)</span>
        <span class="c1"># Powers</span>
        <span class="k">if</span> <span class="n">power_a</span> <span class="ow">in</span> <span class="n">NoneSet</span><span class="p">:</span>
            <span class="n">power_a</span> <span class="o">=</span> <span class="mi">1</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">power_a</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span> <span class="n">power_a</span> <span class="p">)</span>
        <span class="k">if</span> <span class="n">power_b</span> <span class="ow">in</span> <span class="n">NoneSet</span><span class="p">:</span>
            <span class="n">power_b</span> <span class="o">=</span> <span class="mi">1</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">power_b</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span> <span class="n">power_b</span> <span class="p">)</span>
        <span class="c1"># Math</span>
        <span class="n">ret</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">crossproduct</span><span class="p">(</span> <span class="n">column_a</span><span class="p">,</span>
                                 <span class="n">column_b</span><span class="p">,</span>
                                 <span class="n">lag_a</span><span class="o">=</span><span class="n">lag_a</span><span class="p">,</span>
                                 <span class="n">lag_b</span><span class="o">=</span><span class="n">lag_b</span><span class="p">,</span>
                                 <span class="n">vector</span><span class="o">=</span><span class="n">vector</span> <span class="p">)</span>
        <span class="k">if</span> <span class="n">power_a</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">ret</span> <span class="o">=</span> <span class="n">ret</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">power</span><span class="p">(</span> <span class="n">column_a</span><span class="p">,</span>
                                    <span class="n">power_a</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span>
                                    <span class="n">lag</span><span class="o">=</span><span class="n">lag_a</span><span class="p">,</span>
                                    <span class="n">vector</span><span class="o">=</span><span class="n">vector</span> <span class="p">)</span>
        <span class="k">if</span> <span class="n">power_b</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">ret</span> <span class="o">=</span> <span class="n">ret</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">power</span><span class="p">(</span> <span class="n">column_b</span><span class="p">,</span>
                                    <span class="n">power_b</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span>
                                    <span class="n">lag</span><span class="o">=</span><span class="n">lag_b</span><span class="p">,</span>
                                    <span class="n">vector</span><span class="o">=</span><span class="n">vector</span> <span class="p">)</span>
        <span class="k">return</span><span class="p">(</span> <span class="n">ret</span> <span class="p">)</span></div>

<div class="viewcode-block" id="mathDict.crossproduct"><a class="viewcode-back" href="../ParallelRegression.html#ParallelRegression.mathDict.crossproduct">[docs]</a>    <span class="k">def</span> <span class="nf">crossproduct</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">column_a</span><span class="p">,</span> <span class="n">column_b</span><span class="p">,</span>
                     <span class="n">lag_a</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">lag_b</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">vector</span><span class="o">=</span><span class="s1">&#39;column&#39;</span> <span class="p">):</span>
        <span class="sd">&#39;&#39;&#39;Returns a column in which each row `i` is `column_a[i]` *</span>
<span class="sd">        `column_b[i]`.  Checks to see if crossproducts have been pre-calculated</span>
<span class="sd">        and returns the pre-calculated column if present.  If `column_a` and</span>
<span class="sd">        `column_b` identify the same column, the requested is transfered to the</span>
<span class="sd">        .power( ) method.</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="k">if</span> <span class="n">column_a</span> <span class="o">==</span> <span class="n">column_b</span><span class="p">:</span>
            <span class="k">return</span><span class="p">(</span> <span class="bp">self</span><span class="o">.</span><span class="n">power</span><span class="p">(</span> <span class="n">column_a</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="n">vector</span><span class="o">=</span><span class="n">vector</span> <span class="p">)</span> <span class="p">)</span>
        <span class="n">orig_columns</span> <span class="o">=</span> <span class="n">column_a</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_column_names</span> <span class="ow">and</span> \
                       <span class="n">column_b</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_column_names</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">cache_crossproducts</span> <span class="o">==</span> <span class="kc">True</span> <span class="ow">and</span> \
           <span class="n">lag_a</span> <span class="o">==</span> <span class="n">lag_b</span> <span class="ow">and</span> \
           <span class="n">orig_columns</span><span class="p">:</span>
            <span class="n">indices</span> <span class="o">=</span> <span class="p">[</span><span class="n">i</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span> <span class="nb">len</span><span class="p">(</span> <span class="bp">self</span><span class="o">.</span><span class="n">_column_names</span> <span class="p">)</span> <span class="p">)]</span>
            <span class="n">indices</span> <span class="o">=</span> <span class="p">[</span><span class="n">i</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">itertools</span><span class="o">.</span><span class="n">combinations</span><span class="p">(</span> <span class="n">indices</span><span class="p">,</span> <span class="mi">2</span> <span class="p">)]</span>
            <span class="n">cp_index</span> <span class="o">=</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_column_names</span><span class="o">.</span><span class="n">index</span><span class="p">(</span> <span class="n">column_a</span> <span class="p">),</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">_column_names</span><span class="o">.</span><span class="n">index</span><span class="p">(</span> <span class="n">column_b</span> <span class="p">))</span>
            <span class="k">if</span> <span class="n">cp_index</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">cp_index</span><span class="p">[</span><span class="mi">0</span><span class="p">]:</span>
                <span class="n">cp_index_one</span><span class="p">,</span> <span class="n">cp_index_zero</span> <span class="o">=</span> <span class="n">cp_index</span>
                <span class="n">cp_index</span> <span class="o">=</span> <span class="p">(</span><span class="n">cp_index_zero</span><span class="p">,</span> <span class="n">cp_index_one</span><span class="p">)</span>
            <span class="n">cp_index</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_ofs_start</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="n">indices</span><span class="o">.</span><span class="n">index</span><span class="p">(</span> <span class="n">cp_index</span> <span class="p">)</span>
            <span class="k">return</span><span class="p">(</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_column</span><span class="p">(</span> <span class="n">cp_index</span><span class="p">,</span> <span class="n">lag</span><span class="o">=</span><span class="n">lag_a</span><span class="p">,</span> <span class="n">vector</span><span class="o">=</span><span class="n">vector</span> <span class="p">)</span> <span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">ret</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_column</span><span class="p">(</span> <span class="n">column_a</span><span class="p">,</span> <span class="n">lag</span><span class="o">=</span><span class="n">lag_a</span><span class="p">,</span> <span class="n">vector</span><span class="o">=</span><span class="n">vector</span> <span class="p">)</span>
            <span class="n">ret</span> <span class="o">=</span> <span class="n">ret</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_column</span><span class="p">(</span> <span class="n">column_b</span><span class="p">,</span> <span class="n">lag</span><span class="o">=</span><span class="n">lag_b</span><span class="p">,</span> <span class="n">vector</span><span class="o">=</span><span class="n">vector</span> <span class="p">)</span>
        <span class="k">return</span><span class="p">(</span> <span class="n">ret</span> <span class="p">)</span></div>

<div class="viewcode-block" id="mathDict.mask_all"><a class="viewcode-back" href="../ParallelRegression.html#ParallelRegression.mathDict.mask_all">[docs]</a>    <span class="k">def</span> <span class="nf">mask_all</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">except_intercept</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">clear_calculated</span><span class="o">=</span><span class="kc">True</span> <span class="p">):</span>
        <span class="sd">&#39;&#39;&#39;Masks the Intercept column (by default), every column in the matrix</span>
<span class="sd">        of original columns, and every local column, leaving calculated columns</span>
<span class="sd">        unaffected (by default).</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        except_intercept : boolean, optional</span>
<span class="sd">            If True, then the Intercept will be unmasked regardless of its</span>
<span class="sd">            state prior to this method call.</span>
<span class="sd">        clear_calculated : boolean, optional</span>
<span class="sd">            If True, then the list of calculated columns will be deleted.</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">mask</span><span class="p">(</span> <span class="s1">&#39;replace&#39;</span><span class="p">,</span> <span class="p">[</span><span class="kc">True</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span> <span class="nb">len</span><span class="p">(</span>
                                                  <span class="bp">self</span><span class="o">.</span><span class="n">_column_names</span> <span class="p">)</span> <span class="o">+</span> <span class="mi">1</span> <span class="p">)]</span> <span class="p">)</span>
        <span class="k">for</span> <span class="n">column</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">local</span><span class="o">.</span><span class="n">keys</span><span class="p">(</span> <span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">local_mask</span><span class="p">(</span> <span class="s1">&#39;add&#39;</span><span class="p">,</span> <span class="n">column</span> <span class="p">)</span>
        <span class="k">if</span> <span class="n">except_intercept</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">mask</span><span class="p">(</span> <span class="s1">&#39;__setitem__&#39;</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="kc">False</span> <span class="p">)</span>
        <span class="k">if</span> <span class="n">clear_calculated</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">calculated_columns</span><span class="p">(</span> <span class="s1">&#39;replace&#39;</span><span class="p">,</span> <span class="p">[]</span> <span class="p">)</span></div>

<div class="viewcode-block" id="mathDict.unmask_all"><a class="viewcode-back" href="../ParallelRegression.html#ParallelRegression.mathDict.unmask_all">[docs]</a>    <span class="k">def</span> <span class="nf">unmask_all</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&#39;&#39;&#39;Unmasks the Intercept column and every column in the matrix of</span>
<span class="sd">        original columns.</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">mask</span><span class="p">(</span> <span class="s1">&#39;replace&#39;</span><span class="p">,</span> <span class="p">[</span><span class="kc">False</span><span class="p">]</span> <span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">local_mask</span><span class="p">(</span> <span class="s1">&#39;clear&#39;</span> <span class="p">)</span></div>

<div class="viewcode-block" id="mathDict.set_mask"><a class="viewcode-back" href="../ParallelRegression.html#ParallelRegression.mathDict.set_mask">[docs]</a>    <span class="k">def</span> <span class="nf">set_mask</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">column_name</span><span class="p">,</span> <span class="n">mask</span><span class="o">=</span><span class="kc">True</span> <span class="p">):</span>
        <span class="sd">&#39;&#39;&#39;Sets the mask of the specified column to the specified value,</span>
<span class="sd">        extending the length of the mask sequence if necessary.  If</span>
<span class="sd">        `column_name` == &#39;Intercept&#39;, then it sets the mask of the Intercept</span>
<span class="sd">        column instead.</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="k">if</span> <span class="n">column_name</span> <span class="o">==</span> <span class="s1">&#39;Intercept&#39;</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">mask</span><span class="p">(</span> <span class="s1">&#39;__setitem__&#39;</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">mask</span> <span class="p">)</span>
            <span class="k">return</span><span class="p">(</span> <span class="p">)</span>
        <span class="k">elif</span> <span class="n">column_name</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_column_names</span><span class="p">:</span>
            <span class="n">index</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_column_names</span><span class="o">.</span><span class="n">index</span><span class="p">(</span> <span class="n">column_name</span> <span class="p">)</span> <span class="o">+</span> <span class="mi">1</span>
            <span class="k">if</span> <span class="n">index</span> <span class="o">&gt;=</span> <span class="nb">len</span><span class="p">(</span> <span class="bp">self</span><span class="o">.</span><span class="n">mask</span><span class="p">(</span> <span class="p">)</span> <span class="p">):</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">mask</span><span class="p">(</span> <span class="s1">&#39;extend&#39;</span><span class="p">,</span> <span class="p">[</span><span class="kc">False</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> \
                                    <span class="nb">range</span><span class="p">(</span> <span class="nb">len</span><span class="p">(</span> <span class="bp">self</span><span class="o">.</span><span class="n">mask</span><span class="p">(</span> <span class="p">)</span> <span class="p">),</span> <span class="n">index</span> <span class="o">+</span> <span class="mi">1</span> <span class="p">)]</span> <span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">mask</span><span class="p">(</span> <span class="s1">&#39;__setitem__&#39;</span><span class="p">,</span> <span class="n">index</span><span class="p">,</span> <span class="n">mask</span> <span class="p">)</span>
        <span class="k">elif</span> <span class="n">column_name</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">local</span><span class="o">.</span><span class="n">keys</span><span class="p">(</span> <span class="p">)</span> <span class="ow">and</span> <span class="n">mask</span> <span class="o">==</span> <span class="kc">True</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">local_mask</span><span class="p">(</span> <span class="s1">&#39;add&#39;</span><span class="p">,</span> <span class="n">column_name</span> <span class="p">)</span>
        <span class="k">elif</span> <span class="n">column_name</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">local</span><span class="o">.</span><span class="n">keys</span><span class="p">(</span> <span class="p">)</span> <span class="ow">and</span> <span class="n">mask</span> <span class="o">==</span> <span class="kc">False</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">local_mask</span><span class="p">(</span> <span class="s1">&#39;discard&#39;</span><span class="p">,</span> <span class="n">column_name</span> <span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">KeyError</span><span class="p">(</span> <span class="s1">&#39;</span><span class="si">%s</span><span class="s1"> is not a valid column name.&#39;</span> <span class="o">%</span> <span class="n">column_name</span> <span class="p">)</span></div>

<div class="viewcode-block" id="mathDict.add"><a class="viewcode-back" href="../ParallelRegression.html#ParallelRegression.mathDict.add">[docs]</a>    <span class="k">def</span> <span class="nf">add</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">column_string</span> <span class="p">):</span>
        <span class="sd">&#39;&#39;&#39;Adds column_string to the matrix represented by the mathDict( ), and</span>
<span class="sd">        returns the mathDict( ) if successful.</span>

<span class="sd">        Raises</span>
<span class="sd">        ------</span>
<span class="sd">        UnsupportedColumn(Warning)</span>
<span class="sd">            If `column_string` is neither the name of a shared or local column,</span>
<span class="sd">            nor something that mathDict( ) can calculate therefrom.  `.args[1]`</span>
<span class="sd">            == `.columns` is a list of the unsupported column(s).</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="k">if</span> <span class="n">column_string</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_column_names</span> <span class="ow">or</span> \
           <span class="n">column_string</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">local</span> <span class="ow">or</span> \
           <span class="n">column_string</span> <span class="o">==</span> <span class="s1">&#39;Intercept&#39;</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">set_mask</span><span class="p">(</span> <span class="n">column_name</span><span class="o">=</span><span class="n">column_string</span><span class="p">,</span> <span class="n">mask</span><span class="o">=</span><span class="kc">False</span> <span class="p">)</span>
            <span class="k">return</span><span class="p">(</span> <span class="bp">self</span> <span class="p">)</span>
        <span class="k">elif</span> <span class="n">column_string</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">calculated_columns</span><span class="p">(</span> <span class="p">):</span>
            <span class="k">return</span><span class="p">(</span> <span class="bp">self</span> <span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">column_string</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">strings_checked</span><span class="p">:</span>
                <span class="k">try</span><span class="p">:</span>
                    <span class="n">cs_append</span> <span class="o">=</span> <span class="n">column_string</span><span class="o">.</span><span class="n">count</span><span class="p">(</span> <span class="s1">&#39;:&#39;</span> <span class="p">)</span> <span class="o">==</span> <span class="mi">0</span>
                    <span class="k">if</span> <span class="n">cs_append</span><span class="p">:</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">calculated_columns</span><span class="p">(</span> <span class="s1">&#39;append&#39;</span><span class="p">,</span> <span class="n">column_string</span> <span class="p">)</span>
                    <span class="n">attempt</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_handle_str</span><span class="p">(</span> <span class="n">column_string</span><span class="p">,</span>
                                                <span class="n">expanded_columns</span><span class="o">=</span><span class="kc">True</span> <span class="p">)</span>
                    <span class="nb">getattr</span><span class="p">(</span> <span class="bp">self</span><span class="p">,</span> <span class="n">attempt</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="p">)(</span> <span class="o">**</span><span class="n">attempt</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="p">)</span>
                    <span class="k">if</span> <span class="ow">not</span> <span class="n">cs_append</span><span class="p">:</span>
                    <span class="c1">#if len( attempt ) == 3:</span>
                        <span class="c1">#self.calculated_columns.remove( column_string )</span>
                        <span class="k">for</span> <span class="n">column</span> <span class="ow">in</span> <span class="n">attempt</span><span class="p">[</span><span class="mi">2</span><span class="p">]:</span>
                            <span class="bp">self</span><span class="o">.</span><span class="n">set_mask</span><span class="p">(</span> <span class="n">column_name</span><span class="o">=</span><span class="n">column</span><span class="p">,</span> <span class="n">mask</span><span class="o">=</span><span class="kc">False</span> <span class="p">)</span>
                        <span class="k">return</span><span class="p">(</span> <span class="bp">self</span> <span class="p">)</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">strings_checked</span><span class="o">.</span><span class="n">add</span><span class="p">(</span> <span class="n">column_string</span> <span class="p">)</span>
                <span class="k">except</span> <span class="n">mathDictKeyError</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
                    <span class="k">if</span> <span class="n">cs_append</span><span class="p">:</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">calculated_columns</span><span class="p">(</span> <span class="s1">&#39;remove&#39;</span><span class="p">,</span> <span class="n">column_string</span> <span class="p">)</span>
                    <span class="k">raise</span> <span class="n">UnsupportedColumn</span><span class="p">(</span> <span class="s2">&quot;mathDict( ) neither contains a &quot;</span>
                         <span class="s2">&quot;column named, nor supports the calculation of, &#39;</span><span class="si">%s</span><span class="s2">&#39;.&quot;</span>
                         <span class="o">%</span> <span class="n">column_string</span><span class="p">,</span> <span class="p">[</span><span class="n">column_string</span><span class="p">]</span> <span class="p">)</span>
            <span class="k">elif</span> <span class="n">column_string</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">calculated_columns</span><span class="p">(</span> <span class="p">):</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">calculated_columns</span><span class="p">(</span> <span class="s1">&#39;append&#39;</span><span class="p">,</span> <span class="n">column_string</span> <span class="p">)</span>
            <span class="k">return</span><span class="p">(</span> <span class="bp">self</span> <span class="p">)</span></div>

<div class="viewcode-block" id="mathDict.add_from_RHS"><a class="viewcode-back" href="../ParallelRegression.html#ParallelRegression.mathDict.add_from_RHS">[docs]</a>    <span class="k">def</span> <span class="nf">add_from_RHS</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">formula</span><span class="p">,</span> <span class="n">defer_calculations</span><span class="o">=</span><span class="kc">False</span> <span class="p">):</span>
        <span class="sd">&#39;&#39;&#39;Adds columns to the matrix represented by the mathDict( ) based on</span>
<span class="sd">        terms in the right hand side of a string representation of a formula.</span>

<span class="sd">        If there is one or more &#39;~&#39; characters in the formula string,</span>
<span class="sd">        everything to the left of the first &#39;~&#39; character will be ignored.</span>
<span class="sd">        Then, the string will be divided into `column_string`s by splitting on</span>
<span class="sd">        &#39;+&#39; and &#39;-&#39; characters  that are not enclosed within brackets, and</span>
<span class="sd">        .add( column_string ) will be attempted for each column string.</span>

<span class="sd">        Note: Subtracting in lieu of adding negatives is not currently</span>
<span class="sd">        supported, but there is no error checking for this.  Formula strings</span>
<span class="sd">        split on the minus sign in anticipation of a subsequent release</span>
<span class="sd">        supporting subtraction directly.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        self : mathDict</span>
<span class="sd">            If there were zero &#39;~&#39; characters in the original string and every</span>
<span class="sd">            .add( ) attempt was successful.</span>
<span class="sd">        string</span>
<span class="sd">            If there were one or more &#39;~&#39; characters in the original string,</span>
<span class="sd">            then the substring to the left of the first &#39;~&#39; character, stripped</span>
<span class="sd">            of padding whitespaces, is returned if/when every .add( ) attempt</span>
<span class="sd">            is successful.</span>

<span class="sd">        Raises</span>
<span class="sd">        ------</span>
<span class="sd">        UnsupportedColumn(Warning)</span>
<span class="sd">            If one or more column strings is unsupported.  `.args[1]` ==</span>
<span class="sd">            `.columns` is a list of the unsupported column(s).  `.LHS` contains</span>
<span class="sd">            the string to the left of the first `~`, if any, stripped of</span>
<span class="sd">            padding whitespaces.  All supported columns are still added even</span>
<span class="sd">            when an unsupported column occurds mid-formula.</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="n">LHS</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="n">unsupported</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span> <span class="p">)</span>
        <span class="k">if</span> <span class="n">formula</span><span class="o">.</span><span class="n">count</span><span class="p">(</span> <span class="s1">&#39;~&#39;</span> <span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">LHS</span><span class="p">,</span> <span class="n">formula</span> <span class="o">=</span> <span class="n">formula</span><span class="o">.</span><span class="n">split</span><span class="p">(</span> <span class="s1">&#39;~&#39;</span><span class="p">,</span> <span class="mi">1</span> <span class="p">)</span>
        <span class="k">for</span> <span class="n">term</span> <span class="ow">in</span> <span class="n">terms_in</span><span class="p">(</span> <span class="n">formula</span> <span class="p">):</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">add</span><span class="p">(</span> <span class="n">despace</span><span class="p">(</span> <span class="n">term</span> <span class="p">)</span> <span class="p">)</span>
            <span class="k">except</span> <span class="n">UnsupportedColumn</span> <span class="k">as</span> <span class="n">w</span><span class="p">:</span>
                <span class="n">unsupported</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span> <span class="n">w</span><span class="o">.</span><span class="n">columns</span> <span class="p">)</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span> <span class="n">unsupported</span> <span class="p">)</span> <span class="o">==</span> <span class="mi">0</span> <span class="ow">and</span> <span class="n">LHS</span> <span class="o">==</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">return</span><span class="p">(</span> <span class="bp">self</span> <span class="p">)</span>
        <span class="k">if</span> <span class="n">LHS</span> <span class="o">!=</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">LHS</span> <span class="o">=</span> <span class="n">LHS</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span> <span class="s1">&#39; &#39;</span><span class="p">,</span> <span class="s1">&#39;&#39;</span> <span class="p">)</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span> <span class="n">unsupported</span> <span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">UnsupportedColumn</span><span class="p">(</span> <span class="s2">&quot;One or more RHS terms could not be &quot;</span>
                                     <span class="s2">&quot;added.  RHS: &#39;</span><span class="si">%s</span><span class="s2">&#39;.&quot;</span>
                                     <span class="o">%</span> <span class="n">formula</span><span class="p">,</span> <span class="n">unsupported</span><span class="p">,</span> <span class="n">LHS</span><span class="o">=</span><span class="n">LHS</span> <span class="p">)</span>
        <span class="k">return</span><span class="p">(</span> <span class="n">LHS</span> <span class="p">)</span></div>

<div class="viewcode-block" id="mathDict.config_to_dict"><a class="viewcode-back" href="../ParallelRegression.html#ParallelRegression.mathDict.config_to_dict">[docs]</a>    <span class="k">def</span> <span class="nf">config_to_dict</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">save_terms</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
        <span class="sd">&#39;&#39;&#39;Returns a dict( ) subclass object containing the configuration of</span>
<span class="sd">        this mathDict( ) matrix that has a .rebuild( SharedDataArray=REQUIRED )</span>
<span class="sd">        method to recreate the mathDict( ) in a different process.</span>

<span class="sd">        *NOTE: Hypothesis information is not stored.*</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="n">INTERNAL_NOTE</span> <span class="o">=</span> <span class="s1">&#39;&#39;&#39;Where a call to deepcopy( ) is needed, it is</span>
<span class="s1">        performed upon rebuilding the mathDict( ) from the configuration</span>
<span class="s1">        dictionary, as opposed to on creating the configuration dictionary.&#39;&#39;&#39;</span>
        <span class="n">config</span>                        <span class="o">=</span> <span class="n">mathDictConfig</span><span class="p">(</span> <span class="p">)</span>
        <span class="n">config</span><span class="p">[</span><span class="s1">&#39;items&#39;</span><span class="p">]</span>               <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">items</span>
        <span class="n">config</span><span class="p">[</span><span class="s1">&#39;_column_names&#39;</span><span class="p">]</span>       <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_column_names</span>
        <span class="n">config</span><span class="p">[</span><span class="s1">&#39;mask&#39;</span><span class="p">]</span>                <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_mask</span>
        <span class="n">config</span><span class="p">[</span><span class="s1">&#39;dtypes&#39;</span><span class="p">]</span>              <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">dtypes</span>
        <span class="n">config</span><span class="p">[</span><span class="s1">&#39;calculated_columns&#39;</span><span class="p">]</span>  <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_calculated_columns</span>
        <span class="n">config</span><span class="p">[</span><span class="s1">&#39;cache_crossproducts&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">cache_crossproducts</span>
        <span class="n">config</span><span class="p">[</span><span class="s1">&#39;cache_powers&#39;</span><span class="p">]</span>        <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">cache_powers</span>
        <span class="n">config</span><span class="p">[</span><span class="s1">&#39;_orig_padding&#39;</span><span class="p">]</span>       <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_orig_padding</span>
        <span class="k">if</span> <span class="n">save_terms</span><span class="p">:</span>
            <span class="n">config</span><span class="p">[</span><span class="s1">&#39;terms&#39;</span><span class="p">]</span>           <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">terms</span>
        <span class="n">config</span><span class="p">[</span><span class="s1">&#39;local_calculated&#39;</span><span class="p">]</span>    <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">local_calculated</span>
        <span class="n">config</span><span class="p">[</span><span class="s1">&#39;local_mask&#39;</span><span class="p">]</span>          <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_local_mask</span>
        <span class="k">return</span><span class="p">(</span> <span class="n">config</span> <span class="p">)</span></div>

<div class="viewcode-block" id="mathDict.iter_map"><a class="viewcode-back" href="../ParallelRegression.html#ParallelRegression.mathDict.iter_map">[docs]</a>    <span class="k">def</span> <span class="nf">iter_map</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">arg_iterable</span><span class="p">,</span>
                       <span class="n">func</span><span class="p">,</span>
                       <span class="n">placement</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span>
                       <span class="n">process_count</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                       <span class="n">use_kwargs</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                       <span class="n">number_results</span><span class="o">=</span><span class="kc">False</span> <span class="p">):</span>
        <span class="sd">&#39;&#39;&#39;Comparable to .map( ) except that it returns an unsorted iterable</span>
<span class="sd">        instead of a list( ).</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        arg_iterable : iterable of tuples</span>
<span class="sd">            tuple of positional arguments to be passed into `func`.  The final</span>
<span class="sd">            value in the tuple can be a dict( ) of keyword arguments if</span>
<span class="sd">            `use_kwargs` is set to True.</span>
<span class="sd">        func : function</span>
<span class="sd">            The function to be called.  It must be pickleable.</span>
<span class="sd">        placement : int or string, optional</span>
<span class="sd">            If an integer, then the matrix will be inserted as a positional</span>
<span class="sd">            argument at this location.  If a string, then the matrix will be</span>
<span class="sd">            passed in as a keyword argument using this keyword.</span>
<span class="sd">        process_count : int, optional</span>
<span class="sd">            The number of child processes to launch.  If this is not set, then</span>
<span class="sd">            Python will try to figure it out using a minimum of two processes,</span>
<span class="sd">            but Python isn&#39;t good at figuring it out so it is always better to</span>
<span class="sd">            provide this argument.</span>
<span class="sd">        use_kwargs : bool</span>
<span class="sd">            If True, then the final value in each tuple of arguments will be</span>
<span class="sd">            treated as a dict( ) of keyword arguments for `func`.</span>
<span class="sd">        number_results : bool</span>
<span class="sd">            If True, each result will be provided in the form of a tuple in</span>
<span class="sd">            which the first value is the position of the argument tuple in</span>
<span class="sd">            `arg_iterable` from which the result was computed, and the second</span>
<span class="sd">            value is the result itself.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        Iterable</span>
<span class="sd">            Results in unsorted, iterable form.</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="n">ProcessQueue</span> <span class="o">=</span> <span class="n">Queue</span><span class="p">(</span> <span class="p">)</span>
        <span class="n">ReturnQueue</span> <span class="o">=</span> <span class="n">Queue</span><span class="p">(</span> <span class="p">)</span>
        <span class="n">procList</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span> <span class="p">)</span>
        <span class="k">if</span> <span class="n">process_count</span> <span class="o">==</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">process_count</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span> <span class="n">cpu_count</span><span class="p">(</span> <span class="p">),</span> <span class="mi">2</span> <span class="p">)</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span> <span class="n">process_count</span> <span class="p">):</span>
            <span class="n">p</span> <span class="o">=</span> <span class="n">Process</span><span class="p">(</span> <span class="n">target</span><span class="o">=</span><span class="n">_mapper</span><span class="p">,</span>
                         <span class="n">args</span><span class="o">=</span><span class="p">(</span><span class="n">ProcessQueue</span><span class="p">,</span>
                               <span class="n">ReturnQueue</span><span class="p">,</span>
                               <span class="bp">self</span><span class="o">.</span><span class="n">buffer</span><span class="p">,</span>
                               <span class="bp">self</span><span class="o">.</span><span class="n">config_to_dict</span><span class="p">(</span> <span class="p">),</span>
                               <span class="n">func</span><span class="p">,</span>
                               <span class="n">placement</span> <span class="p">)</span>
                         <span class="p">)</span>
            <span class="n">p</span><span class="o">.</span><span class="n">start</span><span class="p">(</span> <span class="p">)</span>
            <span class="n">procList</span><span class="o">.</span><span class="n">append</span><span class="p">(</span> <span class="n">p</span> <span class="p">)</span>
        <span class="n">kwargs</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span> <span class="p">)</span>
        <span class="k">if</span> <span class="n">number_results</span><span class="p">:</span>
            <span class="n">rid</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="k">for</span> <span class="n">args</span> <span class="ow">in</span> <span class="n">arg_iterable</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">use_kwargs</span><span class="p">:</span>
                    <span class="n">kwargs</span> <span class="o">=</span> <span class="n">args</span><span class="p">[</span><span class="nb">len</span><span class="p">(</span> <span class="n">args</span> <span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span>
                    <span class="n">pargs</span> <span class="o">=</span> <span class="n">args</span><span class="p">[:</span><span class="nb">len</span><span class="p">(</span> <span class="n">args</span> <span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">pargs</span> <span class="o">=</span> <span class="n">args</span>
                <span class="n">ProcessQueue</span><span class="o">.</span><span class="n">put</span><span class="p">(</span> <span class="p">(</span><span class="n">rid</span><span class="p">,</span> <span class="n">pargs</span><span class="p">,</span> <span class="n">kwargs</span><span class="p">)</span> <span class="p">)</span>
                <span class="n">rid</span> <span class="o">+=</span> <span class="mi">1</span>
        <span class="k">elif</span> <span class="n">use_kwargs</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">args</span> <span class="ow">in</span> <span class="n">arg_iterable</span><span class="p">:</span>
                <span class="n">kwargs</span> <span class="o">=</span> <span class="n">args</span><span class="p">[</span><span class="nb">len</span><span class="p">(</span> <span class="n">args</span> <span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span>
                <span class="n">pargs</span> <span class="o">=</span> <span class="n">args</span><span class="p">[:</span><span class="nb">len</span><span class="p">(</span> <span class="n">args</span> <span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span>
                <span class="n">ProcessQueue</span><span class="o">.</span><span class="n">put</span><span class="p">(</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">pargs</span><span class="p">,</span> <span class="n">kwargs</span><span class="p">)</span> <span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">args</span> <span class="ow">in</span> <span class="n">arg_iterable</span><span class="p">:</span>
                <span class="c1">## Yes, this involves redundant code.  It also minimizes</span>
                <span class="c1">## branching in an algorithm that could be looped through tens</span>
                <span class="c1">## of thousands or in some scenarios millions of times.</span>
                <span class="n">ProcessQueue</span><span class="o">.</span><span class="n">put</span><span class="p">(</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">args</span><span class="p">,</span> <span class="n">kwargs</span><span class="p">)</span> <span class="p">)</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span> <span class="nb">len</span><span class="p">(</span> <span class="n">procList</span> <span class="p">)</span> <span class="p">):</span>
            <span class="n">ProcessQueue</span><span class="o">.</span><span class="n">put</span><span class="p">(</span> <span class="s1">&#39;Terminate.&#39;</span> <span class="p">)</span>
        <span class="n">termination_count</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">while</span> <span class="n">termination_count</span> <span class="o">&lt;</span> <span class="nb">len</span><span class="p">(</span> <span class="n">procList</span> <span class="p">):</span>
            <span class="n">QueueObject</span> <span class="o">=</span> <span class="n">ReturnQueue</span><span class="o">.</span><span class="n">get</span><span class="p">(</span> <span class="p">)</span>
            <span class="k">if</span> <span class="n">QueueObject</span> <span class="o">==</span> <span class="s1">&#39;Terminated.&#39;</span><span class="p">:</span>
                <span class="n">termination_count</span> <span class="o">+=</span> <span class="mi">1</span>
            <span class="k">elif</span> <span class="n">number_results</span><span class="p">:</span>
                <span class="k">yield</span><span class="p">(</span> <span class="n">QueueObject</span> <span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">yield</span><span class="p">(</span> <span class="n">QueueObject</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="p">)</span></div>

<div class="viewcode-block" id="mathDict.map"><a class="viewcode-back" href="../ParallelRegression.html#ParallelRegression.mathDict.map">[docs]</a>    <span class="k">def</span> <span class="nf">map</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">arg_iterable</span><span class="p">,</span>
                  <span class="n">func</span><span class="p">,</span>
                  <span class="n">placement</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span>
                  <span class="n">process_count</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                  <span class="n">use_kwargs</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                  <span class="n">ordered</span><span class="o">=</span><span class="kc">False</span> <span class="p">):</span>
        <span class="sd">&#39;&#39;&#39;Uses parallel processes and shared memory to call `func` with each</span>
<span class="sd">        tuple of arguments, also passing in the matrix as an argument.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        arg_iterable : iterable of tuples</span>
<span class="sd">            tuple of positional arguments to be passed into `func`.  The final</span>
<span class="sd">            value in the tuple can be a dict( ) of keyword arguments if</span>
<span class="sd">            `use_kwargs` is set to True.</span>
<span class="sd">        func : function</span>
<span class="sd">            The function to be called.  It must be pickleable.</span>
<span class="sd">        placement : int or string, optional</span>
<span class="sd">            If an integer, then the matrix will be inserted as a positional</span>
<span class="sd">            argument at this location.  If a string, then the matrix will be</span>
<span class="sd">            passed in as a keyword argument using this keyword.</span>
<span class="sd">        process_count : int, optional</span>
<span class="sd">            The number of child processes to launch.  If this is not set, then</span>
<span class="sd">            Python will try to figure it out using a minimum of two processes,</span>
<span class="sd">            but Python isn&#39;t good at figuring it out so it is always better to</span>
<span class="sd">            provide this argument.</span>
<span class="sd">        use_kwargs : bool</span>
<span class="sd">            If True, then the final value in each tuple of arguments will be</span>
<span class="sd">            treated as a dict( ) of keyword arguments for `func`.</span>
<span class="sd">        ordered : bool</span>
<span class="sd">            If True, then the results will be listed in the order of the</span>
<span class="sd">            argument tuples.  Otherwise, results may be in any order.  Note:</span>
<span class="sd">            argument tuples are processed asynchronously (out-of-sequence)</span>
<span class="sd">            either way. This option sorts the results after they have been</span>
<span class="sd">            computed.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        list</span>
<span class="sd">            Results in list( ) form.</span>

<span class="sd">        Example</span>
<span class="sd">        -------</span>
<span class="sd">        &gt;&gt;&gt; def sum_row( matrix, row ):</span>
<span class="sd">        &gt;&gt;&gt;     # Put this in a_file.py and import it if you receive pickle-</span>
<span class="sd">        &gt;&gt;&gt;     # related errors.</span>
<span class="sd">        &gt;&gt;&gt;     return( sum( matrix[row,:] ) )</span>
<span class="sd">        &gt;&gt;&gt; matrix = np.array( [i for i in range( 24 )] ).reshape( (6, 4) )</span>
<span class="sd">        &gt;&gt;&gt; RA, MD = mathDictMaker.fromMatrix( matrix, integer=True )</span>
<span class="sd">        &gt;&gt;&gt; res = MD.map( [(i,) for i in range( 6 )], sum_row, ordered=True )</span>
<span class="sd">        &gt;&gt;&gt; print( res )</span>
<span class="sd">        [6, 22, 38, 54, 70, 86]</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="n">retList</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span> <span class="p">)</span>
        <span class="k">for</span> <span class="n">ret</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">iter_map</span><span class="p">(</span> <span class="n">arg_iterable</span><span class="o">=</span><span class="n">arg_iterable</span><span class="p">,</span>
                                  <span class="n">func</span><span class="o">=</span><span class="n">func</span><span class="p">,</span>
                                  <span class="n">placement</span><span class="o">=</span><span class="n">placement</span><span class="p">,</span>
                                  <span class="n">process_count</span><span class="o">=</span><span class="n">process_count</span><span class="p">,</span>
                                  <span class="n">use_kwargs</span><span class="o">=</span><span class="n">use_kwargs</span><span class="p">,</span>
                                  <span class="n">number_results</span><span class="o">=</span><span class="n">ordered</span> <span class="p">):</span>
            <span class="n">retList</span><span class="o">.</span><span class="n">append</span><span class="p">(</span> <span class="n">ret</span> <span class="p">)</span>
        <span class="k">if</span> <span class="n">ordered</span><span class="p">:</span>
            <span class="n">retList</span><span class="o">.</span><span class="n">sort</span><span class="p">(</span> <span class="p">)</span>
            <span class="n">retList</span> <span class="o">=</span> <span class="p">[</span><span class="n">tpl</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="k">for</span> <span class="n">tpl</span> <span class="ow">in</span> <span class="n">retList</span><span class="p">]</span>
        <span class="k">return</span><span class="p">(</span> <span class="n">retList</span> <span class="p">)</span></div></div>

<span class="k">class</span> <span class="nc">TestCase</span><span class="p">(</span><span class="n">unittest</span><span class="o">.</span><span class="n">TestCase</span><span class="p">):</span>
    <span class="sd">&#39;&#39;&#39;Included solely for internal use.</span>
<span class="sd">    &#39;&#39;&#39;</span>
    <span class="n">_dirname</span>   <span class="o">=</span> <span class="s1">&#39;test_files/&#39;</span>
    <span class="n">_rfilename</span> <span class="o">=</span> <span class="n">_dirname</span> <span class="o">+</span> <span class="s1">&#39;exp_&#39;</span>
    <span class="n">_wfilename</span> <span class="o">=</span> <span class="n">_dirname</span> <span class="o">+</span> <span class="s1">&#39;act_&#39;</span>
    <span class="k">def</span> <span class="nf">assertDictUnsortedEqual</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">dictA</span><span class="p">,</span> <span class="n">dictB</span> <span class="p">):</span>
        <span class="sd">&#39;&#39;&#39;Compares two dict( )s in which each entry is expected to have an</span>
<span class="sd">        iterable for its value.</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">assertSetEqual</span><span class="p">(</span> <span class="nb">set</span><span class="p">(</span> <span class="n">dictA</span><span class="o">.</span><span class="n">keys</span><span class="p">(</span> <span class="p">)</span> <span class="p">),</span> <span class="nb">set</span><span class="p">(</span> <span class="n">dictB</span><span class="o">.</span><span class="n">keys</span><span class="p">(</span> <span class="p">)</span> <span class="p">)</span> <span class="p">)</span>
        <span class="k">for</span> <span class="n">key</span> <span class="ow">in</span> <span class="n">dictA</span><span class="o">.</span><span class="n">keys</span><span class="p">(</span> <span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">assertSetEqual</span><span class="p">(</span> <span class="nb">set</span><span class="p">(</span> <span class="n">dictA</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="p">),</span> <span class="nb">set</span><span class="p">(</span> <span class="n">dictB</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="p">)</span> <span class="p">)</span>

    <span class="nd">@contextmanager</span>
    <span class="k">def</span> <span class="nf">assertRaisesWithMessage</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">e</span><span class="p">,</span> <span class="n">msg</span><span class="p">,</span> <span class="n">index</span><span class="o">=</span><span class="mi">0</span> <span class="p">):</span>
        <span class="k">with</span> <span class="bp">self</span><span class="o">.</span><span class="n">assertRaises</span><span class="p">(</span> <span class="n">e</span> <span class="p">)</span> <span class="k">as</span> <span class="n">cm</span><span class="p">:</span>
            <span class="k">yield</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">assertEqual</span><span class="p">(</span> <span class="n">cm</span><span class="o">.</span><span class="n">exception</span><span class="o">.</span><span class="n">args</span><span class="p">[</span><span class="n">index</span><span class="p">],</span> <span class="n">msg</span> <span class="p">)</span>

    <span class="k">def</span> <span class="nf">assertFileLineSetEqual</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">f1</span><span class="p">,</span> <span class="n">f2</span><span class="p">,</span> <span class="n">msg</span><span class="o">=</span><span class="kc">None</span> <span class="p">):</span>
        <span class="n">f1</span> <span class="o">=</span> <span class="n">TestCase</span><span class="o">.</span><span class="n">_dirname</span> <span class="o">+</span> <span class="n">f1</span>
        <span class="n">f2</span> <span class="o">=</span> <span class="n">TestCase</span><span class="o">.</span><span class="n">_dirname</span> <span class="o">+</span> <span class="n">f2</span>
        <span class="n">lines1</span> <span class="o">=</span> <span class="nb">open</span><span class="p">(</span> <span class="n">f1</span><span class="p">,</span> <span class="s1">&#39;r&#39;</span> <span class="p">)</span><span class="o">.</span><span class="n">readlines</span><span class="p">(</span> <span class="p">)</span>
        <span class="n">lines2</span> <span class="o">=</span> <span class="nb">open</span><span class="p">(</span> <span class="n">f2</span><span class="p">,</span> <span class="s1">&#39;r&#39;</span> <span class="p">)</span><span class="o">.</span><span class="n">readlines</span><span class="p">(</span> <span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">assertEqual</span><span class="p">(</span> <span class="nb">len</span><span class="p">(</span> <span class="n">lines1</span> <span class="p">),</span> <span class="nb">len</span><span class="p">(</span> <span class="n">lines2</span> <span class="p">)</span> <span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">assertSetEqual</span><span class="p">(</span> <span class="nb">set</span><span class="p">(</span> <span class="n">lines1</span> <span class="p">),</span> <span class="nb">set</span><span class="p">(</span> <span class="n">lines2</span> <span class="p">),</span> <span class="n">msg</span> <span class="p">)</span>

    <span class="nd">@contextmanager</span>
    <span class="k">def</span> <span class="nf">assertStreamFileEqual</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">filename</span><span class="p">,</span> <span class="n">encoding</span><span class="o">=</span><span class="kc">None</span> <span class="p">):</span>
        <span class="n">_rfilename</span> <span class="o">=</span> <span class="n">TestCase</span><span class="o">.</span><span class="n">_rfilename</span> <span class="o">+</span> <span class="n">filename</span>
        <span class="n">_wfilename</span> <span class="o">=</span> <span class="n">TestCase</span><span class="o">.</span><span class="n">_wfilename</span> <span class="o">+</span> <span class="n">filename</span>
        <span class="n">stream</span> <span class="o">=</span> <span class="n">StringIO</span><span class="p">(</span> <span class="p">)</span>
        <span class="n">err</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="k">yield</span><span class="p">(</span> <span class="n">stream</span> <span class="p">)</span>
        <span class="k">except</span> <span class="ne">Exception</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
            <span class="n">err</span> <span class="o">=</span> <span class="n">e</span>
        <span class="k">finally</span><span class="p">:</span>
            <span class="n">expected</span> <span class="o">=</span> <span class="s1">&#39;&#39;</span>
            <span class="k">with</span> <span class="n">suppress</span><span class="p">(</span><span class="ne">FileNotFoundError</span><span class="p">):</span>
                <span class="k">if</span> <span class="n">encoding</span> <span class="o">!=</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="n">expected</span> <span class="o">=</span> <span class="nb">open</span><span class="p">(</span> <span class="n">_rfilename</span><span class="p">,</span>
                                    <span class="s1">&#39;r&#39;</span><span class="p">,</span>
                                    <span class="n">encoding</span><span class="o">=</span><span class="n">encoding</span> <span class="p">)</span><span class="o">.</span><span class="n">read</span><span class="p">(</span> <span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">expected</span> <span class="o">=</span> <span class="nb">open</span><span class="p">(</span> <span class="n">_rfilename</span><span class="p">,</span> <span class="s1">&#39;r&#39;</span> <span class="p">)</span><span class="o">.</span><span class="n">read</span><span class="p">(</span> <span class="p">)</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">assertMultiLineEqual</span><span class="p">(</span> <span class="n">stream</span><span class="o">.</span><span class="n">getvalue</span><span class="p">(</span> <span class="p">),</span> <span class="n">expected</span> <span class="p">)</span>
            <span class="k">except</span> <span class="ne">AssertionError</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
                <span class="n">stream</span><span class="o">.</span><span class="n">seek</span><span class="p">(</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span> <span class="p">)</span>
                <span class="k">if</span> <span class="n">encoding</span> <span class="o">!=</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="n">wf</span> <span class="o">=</span> <span class="nb">open</span><span class="p">(</span> <span class="n">_wfilename</span><span class="p">,</span>
                               <span class="s1">&#39;w&#39;</span><span class="p">,</span>
                               <span class="n">encoding</span><span class="o">=</span><span class="n">encoding</span>
                             <span class="p">)</span><span class="o">.</span><span class="n">writelines</span><span class="p">(</span> <span class="n">stream</span><span class="o">.</span><span class="n">readlines</span><span class="p">(</span> <span class="p">)</span> <span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">wf</span> <span class="o">=</span> <span class="nb">open</span><span class="p">(</span> <span class="n">_wfilename</span><span class="p">,</span>
                               <span class="s1">&#39;w&#39;</span> <span class="p">)</span><span class="o">.</span><span class="n">writelines</span><span class="p">(</span> <span class="n">stream</span><span class="o">.</span><span class="n">readlines</span><span class="p">(</span> <span class="p">)</span> <span class="p">)</span>
                <span class="k">if</span> <span class="n">err</span> <span class="o">==</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="n">err</span> <span class="o">=</span> <span class="n">e</span>
            <span class="k">if</span> <span class="n">err</span> <span class="o">!=</span> <span class="kc">None</span><span class="p">:</span>
                <span class="k">raise</span> <span class="n">err</span>

    <span class="nd">@contextmanager</span>
    <span class="k">def</span> <span class="nf">assertStdoutStringEqual</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">string</span> <span class="p">):</span>
        <span class="n">_old_target</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">sys</span><span class="p">,</span> <span class="s1">&#39;stdout&#39;</span><span class="p">)</span>
        <span class="n">_new_stream</span> <span class="o">=</span> <span class="n">StringIO</span><span class="p">(</span> <span class="p">)</span>
        <span class="n">err</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="nb">setattr</span><span class="p">(</span> <span class="n">sys</span><span class="p">,</span> <span class="s1">&#39;stdout&#39;</span><span class="p">,</span> <span class="n">_new_stream</span> <span class="p">)</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="k">yield</span>
        <span class="k">except</span> <span class="ne">Exception</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
            <span class="n">err</span> <span class="o">=</span> <span class="n">e</span>
        <span class="k">finally</span><span class="p">:</span>
            <span class="nb">setattr</span><span class="p">(</span> <span class="n">sys</span><span class="p">,</span> <span class="s1">&#39;stdout&#39;</span><span class="p">,</span> <span class="n">_old_target</span> <span class="p">)</span>
            <span class="k">if</span> <span class="n">err</span> <span class="o">!=</span> <span class="kc">None</span><span class="p">:</span>
                <span class="k">raise</span> <span class="n">err</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">assertEqual</span><span class="p">(</span> <span class="n">_new_stream</span><span class="o">.</span><span class="n">getvalue</span><span class="p">(</span> <span class="p">)</span><span class="o">.</span><span class="n">rstrip</span><span class="p">(</span> <span class="p">),</span> <span class="n">string</span> <span class="p">)</span>
        <span class="k">except</span> <span class="ne">AssertionError</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
            <span class="n">_new_stream</span><span class="o">.</span><span class="n">seek</span><span class="p">(</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span> <span class="p">)</span>
            <span class="k">raise</span> <span class="ne">AssertionError</span><span class="p">(</span> <span class="s1">&#39;Output was `</span><span class="si">%s</span><span class="s1">`.  Expected `</span><span class="si">%s</span><span class="s1">`.&#39;</span>
                                  <span class="o">%</span> <span class="p">(</span><span class="n">_new_stream</span><span class="o">.</span><span class="n">getvalue</span><span class="p">(</span> <span class="p">),</span> <span class="n">string</span><span class="p">)</span> <span class="p">)</span>

    <span class="k">class</span> <span class="nc">assertStdoutFileEqual</span><span class="p">(</span><span class="n">ContextDecorator</span><span class="p">):</span>
        <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">filename</span><span class="p">,</span> <span class="n">parent</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">encoding</span><span class="o">=</span><span class="kc">None</span> <span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_old_target</span> <span class="o">=</span> <span class="kc">None</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_rfilename</span> <span class="o">=</span> <span class="n">TestCase</span><span class="o">.</span><span class="n">_rfilename</span> <span class="o">+</span> <span class="n">filename</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_wfilename</span> <span class="o">=</span> <span class="n">TestCase</span><span class="o">.</span><span class="n">_wfilename</span> <span class="o">+</span> <span class="n">filename</span>

            <span class="k">if</span> <span class="n">encoding</span> <span class="o">!=</span> <span class="kc">None</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_encoding</span> <span class="o">=</span> <span class="n">encoding</span>
            <span class="k">if</span> <span class="n">parent</span> <span class="o">!=</span> <span class="kc">None</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_parent</span> <span class="o">=</span> <span class="n">parent</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_parent</span> <span class="o">=</span> <span class="n">unittest</span><span class="o">.</span><span class="n">TestCase</span><span class="p">(</span> <span class="p">)</span>

        <span class="k">def</span> <span class="nf">__enter__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_old_target</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">sys</span><span class="p">,</span> <span class="s1">&#39;stdout&#39;</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_new_stream</span> <span class="o">=</span> <span class="n">StringIO</span><span class="p">(</span> <span class="p">)</span>
            <span class="nb">setattr</span><span class="p">(</span> <span class="n">sys</span><span class="p">,</span> <span class="s1">&#39;stdout&#39;</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_new_stream</span> <span class="p">)</span>
            <span class="k">return</span><span class="p">(</span> <span class="bp">self</span><span class="o">.</span><span class="n">_new_stream</span> <span class="p">)</span>

        <span class="k">def</span> <span class="nf">__exit__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">exc_type</span><span class="p">,</span> <span class="n">exc</span><span class="p">,</span> <span class="n">exc_tb</span><span class="p">):</span>
            <span class="nb">setattr</span><span class="p">(</span> <span class="n">sys</span><span class="p">,</span> <span class="s1">&#39;stdout&#39;</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_old_target</span> <span class="p">)</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">exc_type</span> <span class="o">==</span> <span class="n">exc</span> <span class="o">==</span> <span class="n">exc_tb</span> <span class="o">==</span> <span class="kc">None</span><span class="p">:</span>
                <span class="k">return</span><span class="p">(</span> <span class="kc">False</span> <span class="p">)</span>
            <span class="n">expected</span> <span class="o">=</span> <span class="s1">&#39;&#39;</span>
            <span class="k">with</span> <span class="n">suppress</span><span class="p">(</span><span class="ne">FileNotFoundError</span><span class="p">):</span>
                <span class="k">if</span> <span class="nb">getattr</span><span class="p">(</span> <span class="bp">self</span><span class="p">,</span> <span class="s1">&#39;_encoding&#39;</span><span class="p">,</span> <span class="kc">None</span> <span class="p">)</span> <span class="o">!=</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="k">with</span> <span class="nb">open</span><span class="p">(</span> <span class="bp">self</span><span class="o">.</span><span class="n">_rfilename</span><span class="p">,</span>
                               <span class="s1">&#39;r&#39;</span><span class="p">,</span>
                               <span class="n">encoding</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_encoding</span> <span class="p">)</span> <span class="k">as</span> <span class="n">rf</span><span class="p">:</span>
                        <span class="n">expected</span> <span class="o">=</span> <span class="n">rf</span><span class="o">.</span><span class="n">read</span><span class="p">(</span> <span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="k">with</span> <span class="nb">open</span><span class="p">(</span> <span class="bp">self</span><span class="o">.</span><span class="n">_rfilename</span><span class="p">,</span> <span class="s1">&#39;r&#39;</span> <span class="p">)</span> <span class="k">as</span> <span class="n">rf</span><span class="p">:</span>
                        <span class="n">expected</span> <span class="o">=</span> <span class="n">rf</span><span class="o">.</span><span class="n">read</span><span class="p">(</span> <span class="p">)</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="n">unittest</span><span class="o">.</span><span class="n">TestCase</span><span class="o">.</span><span class="n">assertMultiLineEqual</span><span class="p">(</span> <span class="bp">self</span><span class="o">.</span><span class="n">_parent</span><span class="p">,</span>
                                       <span class="bp">self</span><span class="o">.</span><span class="n">_new_stream</span><span class="o">.</span><span class="n">getvalue</span><span class="p">(</span> <span class="p">),</span> <span class="n">expected</span> <span class="p">)</span>
            <span class="k">except</span> <span class="ne">AssertionError</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_new_stream</span><span class="o">.</span><span class="n">seek</span><span class="p">(</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span> <span class="p">)</span>
                <span class="k">if</span> <span class="nb">getattr</span><span class="p">(</span> <span class="bp">self</span><span class="p">,</span> <span class="s1">&#39;_encoding&#39;</span><span class="p">,</span> <span class="kc">None</span> <span class="p">)</span> <span class="o">!=</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="n">wf</span> <span class="o">=</span> <span class="nb">open</span><span class="p">(</span> <span class="bp">self</span><span class="o">.</span><span class="n">_wfilename</span><span class="p">,</span>
                               <span class="s1">&#39;w&#39;</span><span class="p">,</span>
                               <span class="n">encoding</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_encoding</span>
                             <span class="p">)</span><span class="o">.</span><span class="n">writelines</span><span class="p">(</span> <span class="bp">self</span><span class="o">.</span><span class="n">_new_stream</span><span class="o">.</span><span class="n">readlines</span><span class="p">(</span> <span class="p">)</span> <span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">wf</span> <span class="o">=</span> <span class="nb">open</span><span class="p">(</span> <span class="bp">self</span><span class="o">.</span><span class="n">_wfilename</span><span class="p">,</span>
                               <span class="s1">&#39;w&#39;</span>
                             <span class="p">)</span><span class="o">.</span><span class="n">writelines</span><span class="p">(</span> <span class="bp">self</span><span class="o">.</span><span class="n">_new_stream</span><span class="o">.</span><span class="n">readlines</span><span class="p">(</span> <span class="p">)</span> <span class="p">)</span>
                <span class="k">raise</span> <span class="n">e</span>

<span class="k">if</span> <span class="n">__name__</span> <span class="o">==</span> <span class="s2">&quot;__main__&quot;</span><span class="p">:</span>
    <span class="k">pass</span>
</pre></div>

          </div>
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
<div id="searchbox" style="display: none" role="search">
  <h3>Quick search</h3>
    <form class="search" action="../search.html" method="get">
      <div><input type="text" name="q" /></div>
      <div><input type="submit" value="Go" /></div>
      <input type="hidden" name="check_keywords" value="yes" />
      <input type="hidden" name="area" value="default" />
    </form>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../genindex.html" title="General Index"
             >index</a></li>
        <li class="nav-item nav-item-0"><a href="../index.html">ParallelRegression v1.0.0b3 - tools for conducting parallel analysis of a shared memory data set</a> &#187;</li>
          <li class="nav-item nav-item-1"><a href="index.html" >Module code</a> &#187;</li> 
      </ul>
    </div>
    <div class="footer" role="contentinfo">
        &#169; Copyright 2017, Richard C. Bellamy.
    </div>
  </body>
</html>