<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">


<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>ParallelRegression &#8212; ParallelRegression v1.0.0b2 - tools for conducting parallel analysis of a shared memory data set</title>
    
    <link rel="stylesheet" href="../_static/classic.css" type="text/css" />
    <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
    
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    '../',
        VERSION:     '1.0.0b2',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true,
        SOURCELINK_SUFFIX: '.txt'
      };
    </script>
    <script type="text/javascript" src="../_static/jquery.js"></script>
    <script type="text/javascript" src="../_static/underscore.js"></script>
    <script type="text/javascript" src="../_static/doctools.js"></script>
    <script type="text/javascript" src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" /> 
  </head>
  <body role="document">
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="nav-item nav-item-0"><a href="../index.html">ParallelRegression v1.0.0b2 - tools for conducting parallel analysis of a shared memory data set</a> &#187;</li>
          <li class="nav-item nav-item-1"><a href="index.html" accesskey="U">Module code</a> &#187;</li> 
      </ul>
    </div>  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <h1>Source code for ParallelRegression</h1><div class="highlight"><pre>
<span></span><span class="c1">## (C) 2017 by Richard Bellamy</span>
<span class="c1">##</span>
<span class="c1">## This software is licensed under the terms of version 3 of the GNU Affero</span>
<span class="c1">## General Public License.</span>
<span class="kn">from</span> <span class="nn">copy</span> <span class="k">import</span> <span class="n">deepcopy</span>
<span class="kn">from</span> <span class="nn">collections</span> <span class="k">import</span> <span class="n">abc</span><span class="p">,</span> <span class="n">UserList</span><span class="p">,</span> <span class="n">Sequence</span><span class="p">,</span> <span class="n">OrderedDict</span>
<span class="kn">from</span> <span class="nn">contextlib</span> <span class="k">import</span> <span class="n">suppress</span><span class="p">,</span> <span class="n">ContextDecorator</span><span class="p">,</span> <span class="n">contextmanager</span>
<span class="kn">from</span> <span class="nn">io</span> <span class="k">import</span> <span class="n">StringIO</span><span class="p">,</span> <span class="n">BytesIO</span>
<span class="kn">import</span> <span class="nn">unittest</span>
<span class="kn">import</span> <span class="nn">sys</span>
<span class="kn">import</span> <span class="nn">re</span>
<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="kn">from</span> <span class="nn">multiprocessing</span> <span class="k">import</span> <span class="n">sharedctypes</span><span class="p">,</span> <span class="n">Queue</span><span class="p">,</span> <span class="n">Process</span><span class="p">,</span> <span class="n">cpu_count</span>
<span class="kn">import</span> <span class="nn">array</span>
<span class="kn">import</span> <span class="nn">math</span><span class="o">,</span> <span class="nn">itertools</span>

<span class="n">__all__</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;vCovMatrix&#39;</span><span class="p">,</span>                          <span class="c1"># Functions</span>
           <span class="s1">&#39;FStatistic&#39;</span><span class="p">,</span>
           <span class="s1">&#39;syncText&#39;</span><span class="p">,</span>
           <span class="s1">&#39;val_if_present&#39;</span><span class="p">,</span>
           <span class="s1">&#39;has_term&#39;</span><span class="p">,</span>
           <span class="s1">&#39;mask_brackets&#39;</span><span class="p">,</span>
           <span class="s1">&#39;masked_dict&#39;</span><span class="p">,</span>
           <span class="s1">&#39;masked_iter&#39;</span><span class="p">,</span>
           <span class="s1">&#39;masked_split&#39;</span><span class="p">,</span>
           <span class="s1">&#39;terms_in&#39;</span><span class="p">,</span>
           <span class="s1">&#39;formulas_match&#39;</span><span class="p">,</span>
           <span class="s1">&#39;termString&#39;</span><span class="p">,</span>
           <span class="s1">&#39;CategoryError&#39;</span><span class="p">,</span>                       <span class="c1"># Errors &amp; warnings</span>
           <span class="s1">&#39;UnsupportedColumn&#39;</span><span class="p">,</span>
           <span class="s1">&#39;mathDictKeyError&#39;</span><span class="p">,</span>
           <span class="s1">&#39;RankError&#39;</span><span class="p">,</span>
           <span class="s1">&#39;setList&#39;</span><span class="p">,</span>                             <span class="c1"># Building block classes</span>
           <span class="s1">&#39;typedDict&#39;</span><span class="p">,</span>
           <span class="s1">&#39;categorizedSetDict&#39;</span><span class="p">,</span>
           <span class="s1">&#39;termSet&#39;</span><span class="p">,</span>                             <span class="c1"># Parallel regression-</span>
           <span class="s1">&#39;mathDataStore&#39;</span><span class="p">,</span>                       <span class="c1"># oriented classes</span>
           <span class="s1">&#39;mathDictMaker&#39;</span><span class="p">,</span>
           <span class="s1">&#39;mathDictHypothesis&#39;</span><span class="p">,</span>
           <span class="s1">&#39;mathDictConfig&#39;</span><span class="p">,</span>
           <span class="s1">&#39;mathDict&#39;</span><span class="p">]</span>

<div class="viewcode-block" id="vCovMatrix"><a class="viewcode-back" href="../ParallelRegression.html#ParallelRegression.vCovMatrix">[docs]</a><span class="k">def</span> <span class="nf">vCovMatrix</span><span class="p">(</span> <span class="n">X</span><span class="p">,</span> <span class="n">u</span><span class="p">,</span> <span class="n">vcType</span><span class="o">=</span><span class="s1">&#39;White1980&#39;</span> <span class="p">):</span>
    <span class="sd">&#39;&#39;&#39;Computes a variance-covariance matrix.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    X : 2-dimensional array</span>
<span class="sd">        Matrix of X values.</span>
<span class="sd">    u : vector array</span>
<span class="sd">        Vector of residuals.</span>
<span class="sd">    vcType : {&#39;White1980&#39;, &#39;Classical&#39;}, optional</span>
<span class="sd">        Type of variance-covariance matrix requested.  &#39;Classical&#39; for the</span>
<span class="sd">        classical statistics formula, or &#39;White1980&#39; for the</span>
<span class="sd">        heteroskedasticity-robust formula originally proposed by Halbert White</span>
<span class="sd">        in his 1980 paper, &#39;A Heteroskedasticity-Consistent Covariance Matrix</span>
<span class="sd">        Estimator and a Direct Test for Heteroskedasticity&#39;.</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    The heteroskedasticity-robust formula supported is the formula explained</span>
<span class="sd">    in the documentation to the &quot;car&quot; R package&#39;s &quot;hccm&quot; function:</span>

<span class="sd">    &quot;The classical White-corrected coefficient covariance matrix (&quot;hc0&quot;) (for</span>
<span class="sd">    an unweighted model) is</span>

<span class="sd">    &quot;V(b) = inv(X&#39;X) X&#39; diag(e^2) X inv(X&#39;X)</span>

<span class="sd">    &quot;where e^2 are the squared residuals, and X is the model matrix.&quot;</span>

<span class="sd">    This is the same formula proposed by White in 1980.  However, the car</span>
<span class="sd">    pachage documentation is substantially more clear and concise than either</span>
<span class="sd">    the original paper or most textbook discussions.</span>
<span class="sd">    &#39;&#39;&#39;</span>
    <span class="k">try</span><span class="p">:</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span> <span class="n">X</span><span class="o">.</span><span class="n">shape</span> <span class="p">)</span> <span class="o">!=</span> <span class="mi">2</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;`X` must have exactly two dimensions.&#39;</span><span class="p">)</span>
    <span class="k">except</span> <span class="ne">AttributeError</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s1">&#39;`X` must be a 2-dimensional ndarray.&#39;</span><span class="p">)</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span> <span class="n">X</span><span class="p">[:,</span><span class="mi">0</span><span class="p">]</span> <span class="p">)</span> <span class="o">!=</span> <span class="nb">len</span><span class="p">(</span> <span class="n">u</span> <span class="p">):</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;Length of `u` must match the number of rows in `X`.&#39;</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">nobs</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span> <span class="n">u</span> <span class="p">)</span>
    <span class="n">XpXi</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">inv</span><span class="p">(</span> <span class="n">X</span><span class="o">.</span><span class="n">T</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span> <span class="n">X</span> <span class="p">)</span> <span class="p">)</span>

    <span class="n">horse</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span> <span class="p">(</span> <span class="n">nobs</span><span class="p">,</span> <span class="n">nobs</span> <span class="p">)</span> <span class="p">)</span>
    <span class="n">u</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span> <span class="n">u</span> <span class="p">)</span>
    <span class="n">sigma_sq</span> <span class="o">=</span> <span class="n">u</span><span class="o">.</span><span class="n">T</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span> <span class="n">u</span> <span class="p">)</span> <span class="o">/</span> <span class="p">(</span> <span class="nb">len</span><span class="p">(</span> <span class="n">u</span> <span class="p">)</span> <span class="o">-</span> <span class="nb">len</span><span class="p">(</span> <span class="n">X</span><span class="p">[</span><span class="mi">0</span><span class="p">,:]</span> <span class="p">)</span> <span class="p">)</span>
    <span class="k">if</span> <span class="n">vcType</span> <span class="o">==</span> <span class="s1">&#39;White1980&#39;</span><span class="p">:</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span> <span class="n">nobs</span> <span class="p">):</span>
            <span class="n">horse</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">u</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">**</span><span class="mi">2</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span> <span class="n">nobs</span> <span class="p">):</span>
            <span class="n">horse</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">sigma_sq</span>
    <span class="n">inner</span> <span class="o">=</span> <span class="n">X</span><span class="o">.</span><span class="n">T</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span> <span class="n">horse</span> <span class="p">)</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span> <span class="n">X</span> <span class="p">)</span>

    <span class="n">vCovM</span> <span class="o">=</span> <span class="n">XpXi</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span> <span class="n">inner</span> <span class="p">)</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span> <span class="n">XpXi</span> <span class="p">)</span>
    <span class="k">return</span><span class="p">(</span> <span class="n">vCovM</span> <span class="p">)</span></div>

<div class="viewcode-block" id="FStatistic"><a class="viewcode-back" href="../ParallelRegression.html#ParallelRegression.FStatistic">[docs]</a><span class="k">def</span> <span class="nf">FStatistic</span><span class="p">(</span> <span class="n">X</span><span class="p">,</span> <span class="n">u</span><span class="p">,</span> <span class="n">coefs</span><span class="p">,</span> <span class="n">R</span><span class="p">,</span> <span class="n">r</span><span class="p">,</span> <span class="n">vcType</span><span class="o">=</span><span class="s1">&#39;White1980&#39;</span> <span class="p">):</span>
    <span class="sd">&#39;&#39;&#39;Computes an F statistic that by default is heteroskedasticity-robust.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    X : 2-dimensional array</span>
<span class="sd">        Matrix of all regressors including the intercept.</span>
<span class="sd">    u : vector array</span>
<span class="sd">        Vector of all residuals.</span>
<span class="sd">    coefs : vector array</span>
<span class="sd">        All coefficients from the model that is being tested, including the</span>
<span class="sd">        intercept and untested parameters.</span>
<span class="sd">    R : 2-dimensional array</span>
<span class="sd">        Linear restrictions in matrix form.</span>
<span class="sd">    r : vector array</span>
<span class="sd">        Linear restriction values in vector form.</span>
<span class="sd">    vcType : {&#39;White1980&#39;, &#39;Classical&#39;}, optional</span>
<span class="sd">        Type of variance-covariance matrix requested.  Keep the default setting</span>
<span class="sd">        for a heteroskedasticity-robust result.  See vCovMatrix function for</span>
<span class="sd">        details.</span>
<span class="sd">    &#39;&#39;&#39;</span>
    <span class="n">vc</span> <span class="o">=</span> <span class="n">vCovMatrix</span><span class="p">(</span> <span class="n">X</span><span class="p">,</span> <span class="n">u</span><span class="p">,</span> <span class="n">vcType</span> <span class="p">)</span>
    <span class="n">Rterm</span> <span class="o">=</span> <span class="n">R</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span> <span class="n">coefs</span> <span class="p">)</span> <span class="o">-</span> <span class="n">r</span>
    <span class="n">Lterm</span> <span class="o">=</span> <span class="n">Rterm</span><span class="o">.</span><span class="n">T</span>
    <span class="n">Mterm</span> <span class="o">=</span> <span class="n">R</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span> <span class="n">vc</span> <span class="p">)</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span> <span class="n">R</span><span class="o">.</span><span class="n">T</span> <span class="p">)</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span> <span class="n">r</span> <span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
        <span class="n">Mterm</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">inv</span><span class="p">(</span> <span class="n">Mterm</span> <span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">Mterm</span> <span class="o">=</span> <span class="n">Mterm</span><span class="o">**-</span><span class="mi">1</span>
    <span class="n">F</span> <span class="o">=</span> <span class="n">Lterm</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span> <span class="n">Mterm</span> <span class="p">)</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span> <span class="n">Rterm</span> <span class="p">)</span> <span class="o">/</span> <span class="nb">len</span><span class="p">(</span> <span class="n">r</span> <span class="p">)</span>
    <span class="k">if</span> <span class="n">math</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span> <span class="n">F</span> <span class="p">):</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span> <span class="s1">&#39;F Statistic calculation resulted in nan.&#39;</span><span class="p">,</span> <span class="n">vcType</span><span class="p">,</span>
                                                                      <span class="n">vc</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span>
                                                                      <span class="n">F</span><span class="p">,</span>
                                                                      <span class="n">Mterm</span><span class="p">,</span>
                                                                      <span class="n">Rterm</span><span class="p">,</span>
                                                                      <span class="n">r</span> <span class="p">)</span>
    <span class="k">return</span><span class="p">(</span> <span class="n">F</span> <span class="p">)</span></div>

<div class="viewcode-block" id="syncText"><a class="viewcode-back" href="../ParallelRegression.html#ParallelRegression.syncText">[docs]</a><span class="k">def</span> <span class="nf">syncText</span><span class="p">(</span> <span class="n">strA</span><span class="p">,</span> <span class="n">strB</span><span class="p">,</span> <span class="n">addA</span><span class="p">,</span> <span class="n">addB</span><span class="p">,</span> <span class="n">pre</span><span class="o">=</span><span class="s1">&#39;&#39;</span> <span class="p">):</span>
    <span class="sd">&#39;&#39;&#39;Adds necessary spacing to align simultaneous additions to two strings.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>

<span class="sd">    strA : string</span>
<span class="sd">        The first of the two strings.</span>
<span class="sd">    strB : string</span>
<span class="sd">        The second of the two strings.</span>
<span class="sd">    addA : string</span>
<span class="sd">        The string to be appended to the first string.</span>
<span class="sd">    addB : string</span>
<span class="sd">        The string to be appended to the second string.</span>
<span class="sd">    pre : string, optional</span>
<span class="sd">        This string is appended to `strA` and `strB` immediately before `addA`</span>
<span class="sd">        and `addB`.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>

<span class="sd">    strA : string</span>
<span class="sd">        The first string, with `addA` appended.</span>
<span class="sd">    strB : string</span>
<span class="sd">        The second string, with `addB` appended, starting at the same index as</span>
<span class="sd">        `addA` in the first string.</span>

<span class="sd">    Example</span>
<span class="sd">    -------</span>

<span class="sd">    &gt;&gt;&gt; upper, lower = (&#39;John&#39;, &#39;Proper Noun&#39;)</span>
<span class="sd">    &gt;&gt;&gt; for a, b in [(&#39;ate&#39;, &#39;Verb&#39;),(&#39;an&#39;, &#39;Article&#39;),(&#39;apple.&#39;, &#39;Noun&#39;)]:</span>
<span class="sd">    &gt;&gt;&gt;     upper, lower = syncText( upper, lower, a, b, &#39; &#39; )</span>
<span class="sd">    &gt;&gt;&gt; print( upper, &#39;\\n&#39;, lower )</span>
<span class="sd">    John        ate  an      apple.</span>
<span class="sd">    Proper Noun Verb Article Noun</span>
<span class="sd">    &#39;&#39;&#39;</span>
    <span class="c1">## Please pardon the inconsistency in the headings&#39; line spacing between</span>
    <span class="c1">## this and other docstrings, and the escaping the backslash in &#39;\n&#39;.  Both</span>
    <span class="c1">## were necessitated by Sphinx.</span>
    <span class="n">spaces</span> <span class="o">=</span> <span class="nb">abs</span><span class="p">(</span> <span class="nb">len</span><span class="p">(</span> <span class="n">strA</span> <span class="p">)</span> <span class="o">-</span> <span class="nb">len</span><span class="p">(</span> <span class="n">strB</span> <span class="p">)</span> <span class="p">)</span>
    <span class="n">spaces</span> <span class="o">=</span> <span class="s1">&#39;&#39;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span> <span class="p">[</span><span class="s1">&#39; &#39;</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span> <span class="n">spaces</span> <span class="p">)]</span> <span class="p">)</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span> <span class="n">strA</span> <span class="p">)</span> <span class="o">&gt;</span> <span class="nb">len</span><span class="p">(</span> <span class="n">strB</span> <span class="p">):</span>
        <span class="n">strB</span> <span class="o">+=</span> <span class="n">spaces</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">strA</span> <span class="o">+=</span> <span class="n">spaces</span>
    <span class="n">strA</span> <span class="o">+=</span> <span class="n">pre</span> <span class="o">+</span> <span class="n">addA</span>
    <span class="n">strB</span> <span class="o">+=</span> <span class="n">pre</span> <span class="o">+</span> <span class="n">addB</span>
    <span class="k">return</span><span class="p">(</span> <span class="n">strA</span><span class="p">,</span> <span class="n">strB</span> <span class="p">)</span></div>

<div class="viewcode-block" id="val_if_present"><a class="viewcode-back" href="../ParallelRegression.html#ParallelRegression.val_if_present">[docs]</a><span class="k">def</span> <span class="nf">val_if_present</span><span class="p">(</span> <span class="n">obj</span><span class="p">,</span> <span class="n">attr</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">alt</span><span class="o">=</span><span class="kc">None</span> <span class="p">):</span>
    <span class="sd">&#39;&#39;&#39;Returns the requested value if it is set and is not None.  Otherwise</span>
<span class="sd">    `alt` is returned.</span>

<span class="sd">    Avoids errors if the requested value does not exist, while handling the</span>
<span class="sd">    presence of a None value and a default value in a different manner than</span>
<span class="sd">    getattr( ).</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    obj</span>
<span class="sd">        An object from which to attempt to retrieve an attribute value.</span>
<span class="sd">    attr : string, optional</span>
<span class="sd">        The name of the attribute to be retrieved.  If `attr` is not set, then</span>
<span class="sd">        the value of `obj` will be returned unless it is equal to None.  If &#39;.&#39;</span>
<span class="sd">        is present in this string, child objects will be retrieved recursively.</span>
<span class="sd">        See example below.</span>
<span class="sd">    alt, optional</span>
<span class="sd">        The value to be returned if the requested attribute does not exist, or</span>
<span class="sd">        is equal to None, or if the object&#39;s value is requested but is equal to</span>
<span class="sd">        None.  If this is not set, then None will be returned in these</span>
<span class="sd">        scenarios.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    obj</span>
<span class="sd">        If the requested value is set and is not equal to None, then the</span>
<span class="sd">        requested value is returned.  Otherwise, `alt` is returned.  No error</span>
<span class="sd">        is raised if `obj` does not have an attribute named `attr`.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; class testFixture(object):</span>
<span class="sd">    &gt;&gt;&gt;     NoneVal = None</span>
<span class="sd">    &gt;&gt;&gt;     number = 123</span>
<span class="sd">    &gt;&gt;&gt; testFix = testFixture( )</span>
<span class="sd">    &gt;&gt;&gt; val_if_present( testFix, &#39;NoneVal&#39;, &#39;ABCdef&#39; ) == &#39;ABCdef&#39;</span>
<span class="sd">    True</span>
<span class="sd">    &gt;&gt;&gt; testFix.fixtureTwo = testFixture( )</span>
<span class="sd">    &gt;&gt;&gt; testFix.fixtureTwo.dict_object = {&#39;a_key&#39;: &#39;has a value.&#39;}</span>
<span class="sd">    &gt;&gt;&gt; val_if_present( testFix, &#39;fixtureTwo.dict_object.a_key&#39; ) \\</span>
<span class="sd">    &gt;&gt;&gt;               == &#39;has a value.&#39;</span>
<span class="sd">    True</span>
<span class="sd">    &#39;&#39;&#39;</span>
    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span> <span class="n">obj</span><span class="p">,</span> <span class="nb">dict</span> <span class="p">):</span>
        <span class="k">if</span> <span class="n">attr</span> <span class="ow">in</span> <span class="n">obj</span><span class="o">.</span><span class="n">keys</span><span class="p">(</span> <span class="p">):</span>
            <span class="k">return</span><span class="p">(</span> <span class="n">obj</span><span class="p">[</span><span class="n">attr</span><span class="p">]</span> <span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span><span class="p">(</span> <span class="n">alt</span> <span class="p">)</span>
    <span class="k">if</span> <span class="n">obj</span> <span class="o">==</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">return</span><span class="p">(</span> <span class="n">alt</span> <span class="p">)</span>
    <span class="k">if</span> <span class="n">attr</span> <span class="o">==</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">return</span><span class="p">(</span> <span class="n">obj</span> <span class="p">)</span>
    <span class="k">if</span> <span class="n">attr</span><span class="o">.</span><span class="n">count</span><span class="p">(</span> <span class="s1">&#39;.&#39;</span> <span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
        <span class="n">attr</span> <span class="o">=</span> <span class="n">attr</span><span class="o">.</span><span class="n">split</span><span class="p">(</span> <span class="s1">&#39;.&#39;</span><span class="p">,</span> <span class="n">maxsplit</span><span class="o">=</span><span class="mi">1</span> <span class="p">)</span>
        <span class="k">if</span> <span class="n">attr</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="ow">in</span> <span class="n">obj</span><span class="o">.</span><span class="n">__dir__</span><span class="p">(</span> <span class="p">):</span>
            <span class="n">tpl</span> <span class="o">=</span> <span class="p">(</span> <span class="nb">getattr</span><span class="p">(</span> <span class="n">obj</span><span class="p">,</span> <span class="n">attr</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="p">),</span> <span class="n">attr</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">alt</span> <span class="p">)</span>
            <span class="k">return</span><span class="p">(</span> <span class="n">val_if_present</span><span class="p">(</span> <span class="nb">getattr</span><span class="p">(</span> <span class="n">obj</span><span class="p">,</span> <span class="n">attr</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="p">),</span> <span class="n">attr</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">alt</span> <span class="p">)</span> <span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span><span class="p">(</span> <span class="n">alt</span> <span class="p">)</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">attr</span> <span class="ow">in</span> <span class="n">obj</span><span class="o">.</span><span class="n">__dir__</span><span class="p">(</span> <span class="p">):</span>
        <span class="k">return</span><span class="p">(</span> <span class="n">alt</span> <span class="p">)</span>
    <span class="n">attrVal</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span> <span class="n">obj</span><span class="p">,</span> <span class="n">attr</span> <span class="p">)</span>
    <span class="k">if</span> <span class="n">attrVal</span> <span class="o">==</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">return</span><span class="p">(</span> <span class="n">alt</span> <span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span><span class="p">(</span> <span class="n">attrVal</span> <span class="p">)</span></div>

<div class="viewcode-block" id="has_term"><a class="viewcode-back" href="../ParallelRegression.html#ParallelRegression.has_term">[docs]</a><span class="k">def</span> <span class="nf">has_term</span><span class="p">(</span> <span class="n">formula</span><span class="p">,</span> <span class="n">term</span> <span class="p">):</span>
    <span class="sd">&#39;&#39;&#39;Returns True if `formula` either starts with `term` followed by one of</span>
<span class="sd">    [ )+-~*:] or contains `term` followed by one those characters, preceeded by</span>
<span class="sd">    one of [ (+-~*:].</span>
<span class="sd">    &#39;&#39;&#39;</span>
    <span class="n">before</span> <span class="o">=</span> <span class="s1">&#39; (+-~*:&#39;</span>
    <span class="n">after</span> <span class="o">=</span> <span class="s1">&#39; )+-~*:&#39;</span>
    <span class="k">if</span> <span class="n">formula</span><span class="o">.</span><span class="n">startswith</span><span class="p">(</span> <span class="n">term</span> <span class="p">):</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span> <span class="n">formula</span> <span class="p">)</span> <span class="o">==</span> <span class="nb">len</span><span class="p">(</span> <span class="n">term</span> <span class="p">)</span> <span class="ow">or</span> <span class="n">formula</span><span class="p">[</span><span class="nb">len</span><span class="p">(</span> <span class="n">term</span> <span class="p">)]</span> <span class="ow">in</span> <span class="n">after</span><span class="p">:</span>
            <span class="k">return</span><span class="p">(</span> <span class="kc">True</span> <span class="p">)</span>
    <span class="k">for</span> <span class="n">b</span> <span class="ow">in</span> <span class="n">before</span><span class="p">:</span>
        <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">while</span> <span class="n">i</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">i</span> <span class="o">=</span> <span class="n">formula</span><span class="o">.</span><span class="n">find</span><span class="p">(</span> <span class="n">b</span><span class="p">,</span> <span class="n">i</span> <span class="o">+</span> <span class="mi">1</span> <span class="p">)</span>
            <span class="k">if</span> <span class="n">formula</span><span class="p">[</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">:]</span><span class="o">.</span><span class="n">startswith</span><span class="p">(</span> <span class="n">term</span> <span class="p">):</span>
                <span class="k">if</span> <span class="nb">len</span><span class="p">(</span> <span class="n">formula</span><span class="p">[</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">:]</span> <span class="p">)</span> <span class="o">==</span> <span class="nb">len</span><span class="p">(</span> <span class="n">term</span> <span class="p">):</span>
                    <span class="k">return</span><span class="p">(</span> <span class="kc">True</span> <span class="p">)</span>
                <span class="k">if</span> <span class="p">(</span> <span class="n">formula</span><span class="p">[</span><span class="n">i</span><span class="o">+</span><span class="nb">len</span><span class="p">(</span> <span class="n">term</span> <span class="p">)</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span> <span class="ow">in</span> <span class="n">after</span> <span class="p">):</span>
                    <span class="k">return</span><span class="p">(</span> <span class="kc">True</span> <span class="p">)</span>
    <span class="k">return</span><span class="p">(</span> <span class="kc">False</span> <span class="p">)</span></div>

<span class="n">splitter</span> <span class="o">=</span> <span class="n">re</span><span class="o">.</span><span class="n">compile</span><span class="p">(</span> <span class="s1">r&#39;[\+\-\~]+&#39;</span> <span class="p">)</span>
<span class="n">one_star</span> <span class="o">=</span> <span class="n">re</span><span class="o">.</span><span class="n">compile</span><span class="p">(</span> <span class="s1">r&#39;\*(?!\*)&#39;</span> <span class="p">)</span>
<span class="n">paren</span> <span class="o">=</span> <span class="n">re</span><span class="o">.</span><span class="n">compile</span><span class="p">(</span> <span class="s1">r&#39;(?:\([^\(]*?\))|(?:\{[^\{]*?\})|(?:\[[^\[]*?\])&#39;</span> <span class="p">)</span>
<span class="n">varpattern_rstr</span> <span class="o">=</span> <span class="s1">r&#39;[a-zA-Z_][a-zA-Z_0-9]*(?![a-zA-Z_0-9\(\{\[])&#39;</span>
<span class="n">varpattern</span> <span class="o">=</span> <span class="n">re</span><span class="o">.</span><span class="n">compile</span><span class="p">(</span> <span class="n">varpattern_rstr</span> <span class="p">)</span>
<span class="n">termpat_rstr</span> <span class="o">=</span> <span class="s1">r&#39;[a-zA-Z_0-9]+(?:[ ]*[^ \+\-\(\{\[]+)*(?![a-zA-Z_0-9\(\{\[])&#39;</span>
<span class="n">termpattern</span> <span class="o">=</span> <span class="n">re</span><span class="o">.</span><span class="n">compile</span><span class="p">(</span> <span class="n">termpat_rstr</span> <span class="p">)</span>

<div class="viewcode-block" id="mask_brackets"><a class="viewcode-back" href="../ParallelRegression.html#ParallelRegression.mask_brackets">[docs]</a><span class="k">def</span> <span class="nf">mask_brackets</span><span class="p">(</span> <span class="n">string</span> <span class="p">):</span>
    <span class="sd">&#39;&#39;&#39; Mask anything inside brackets, including nested brackets, by replacing</span>
<span class="sd">    the brackets and their contents with a same-length string of repeated</span>
<span class="sd">    underscores.</span>
<span class="sd">    &#39;&#39;&#39;</span>
    <span class="k">def</span> <span class="nf">repl</span><span class="p">(</span> <span class="n">mobj</span> <span class="p">):</span>
        <span class="n">replacement</span> <span class="o">=</span> <span class="s1">&#39;&#39;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span> <span class="p">[</span><span class="s1">&#39;_&#39;</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> \
                                <span class="nb">range</span><span class="p">(</span> <span class="n">mobj</span><span class="o">.</span><span class="n">end</span><span class="p">(</span> <span class="p">)</span> <span class="o">-</span> <span class="n">mobj</span><span class="o">.</span><span class="n">start</span><span class="p">(</span> <span class="p">)</span> <span class="p">)]</span> <span class="p">)</span>
        <span class="k">return</span><span class="p">(</span> <span class="n">replacement</span> <span class="p">)</span>
    <span class="n">nsubstitutions</span> <span class="o">=</span> <span class="mi">1</span>
    <span class="k">while</span> <span class="n">nsubstitutions</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
        <span class="n">string</span><span class="p">,</span> <span class="n">nsubstitutions</span> <span class="o">=</span> <span class="n">paren</span><span class="o">.</span><span class="n">subn</span><span class="p">(</span> <span class="n">repl</span><span class="p">,</span> <span class="n">string</span> <span class="p">)</span>
    <span class="k">return</span><span class="p">(</span> <span class="n">string</span> <span class="p">)</span></div>

<div class="viewcode-block" id="masked_dict"><a class="viewcode-back" href="../ParallelRegression.html#ParallelRegression.masked_dict">[docs]</a><span class="k">def</span> <span class="nf">masked_dict</span><span class="p">(</span> <span class="n">string</span><span class="p">,</span> <span class="n">mobj</span> <span class="p">):</span>
    <span class="sd">&#39;&#39;&#39;Recovers the corresponding contents from the original string based on a</span>
<span class="sd">    regular expressions match object produced using a masked string.  Compare</span>
<span class="sd">    to mobj.groupdict( ).</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    string : string</span>
<span class="sd">        The unmasked string from which content is to be recovered.</span>
<span class="sd">    mobj : regular expression match object</span>
<span class="sd">        The match object resulting from a regular expression pattern matched to</span>
<span class="sd">        a masked version of `string`.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    dict</span>
<span class="sd">        Dictionary containing the substrings of `string` corresponding to the</span>
<span class="sd">        named subgroups of the match, keyed by the subgroup name.</span>
<span class="sd">    &#39;&#39;&#39;</span>
    <span class="n">ret</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span> <span class="p">)</span>
    <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">mobj</span><span class="o">.</span><span class="n">re</span><span class="o">.</span><span class="n">groupindex</span><span class="o">.</span><span class="n">items</span><span class="p">(</span> <span class="p">):</span>
        <span class="n">a</span><span class="p">,</span> <span class="n">t</span> <span class="o">=</span> <span class="n">mobj</span><span class="o">.</span><span class="n">span</span><span class="p">(</span> <span class="n">v</span> <span class="p">)</span>
        <span class="n">ret</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">=</span> <span class="n">string</span><span class="p">[</span><span class="n">a</span><span class="p">:</span><span class="n">t</span><span class="p">]</span>
    <span class="k">return</span><span class="p">(</span> <span class="n">ret</span> <span class="p">)</span></div>

<div class="viewcode-block" id="masked_iter"><a class="viewcode-back" href="../ParallelRegression.html#ParallelRegression.masked_iter">[docs]</a><span class="k">def</span> <span class="nf">masked_iter</span><span class="p">(</span> <span class="n">string</span><span class="p">,</span> <span class="n">mobj_iter</span> <span class="p">):</span>
    <span class="sd">&#39;&#39;&#39;Recovers the corresponding contents from the original string based on</span>
<span class="sd">    regular expression match objects produced by an iterable returned from</span>
<span class="sd">    re.finditer( ) or from a pattern object&#39;s .finditer( ) method.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    string : string</span>
<span class="sd">        The unmasked string from which content is to be recovered.</span>
<span class="sd">    mobj_iter : iterable of regular expression match objects</span>
<span class="sd">        The iterable of regular expression match objects resulting from a</span>
<span class="sd">        regular expression pattern matched to a masked version of `string`.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    list</span>
<span class="sd">        List containing the substrings of `string` corresponding to the</span>
<span class="sd">        substring matched by each match object produced by the iterable.</span>
<span class="sd">    &#39;&#39;&#39;</span>
    <span class="n">ret</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span> <span class="p">)</span>
    <span class="k">for</span> <span class="n">mobj</span> <span class="ow">in</span> <span class="n">mobj_iter</span><span class="p">:</span>
        <span class="n">a</span><span class="p">,</span> <span class="n">t</span> <span class="o">=</span> <span class="n">mobj</span><span class="o">.</span><span class="n">span</span><span class="p">(</span> <span class="p">)</span>
        <span class="n">ret</span><span class="o">.</span><span class="n">append</span><span class="p">(</span> <span class="n">string</span><span class="p">[</span><span class="n">a</span><span class="p">:</span><span class="n">t</span><span class="p">]</span> <span class="p">)</span>
    <span class="k">return</span><span class="p">(</span> <span class="n">ret</span> <span class="p">)</span></div>

<div class="viewcode-block" id="masked_split"><a class="viewcode-back" href="../ParallelRegression.html#ParallelRegression.masked_split">[docs]</a><span class="k">def</span> <span class="nf">masked_split</span><span class="p">(</span> <span class="n">string</span><span class="p">,</span> <span class="n">mask</span><span class="p">,</span> <span class="n">split</span> <span class="p">):</span>
    <span class="sd">&#39;&#39;&#39;Splits `string` based on the location(s) at which `split` is located in</span>
<span class="sd">    `mask`.  Compare to str.split( ).</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    string : string</span>
<span class="sd">        The unmasked string from which content is to be recovered.</span>
<span class="sd">    mask : string</span>
<span class="sd">        The masked version of `string` to be used to determine the the</span>
<span class="sd">        location(s) at which to split `string`.</span>
<span class="sd">    split : string</span>
<span class="sd">        The string identifying the location(s) at which to split `string`.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    list</span>
<span class="sd">        List of substrings resulting from splitting `string` based on the</span>
<span class="sd">        presence of `split` in `mask`.</span>
<span class="sd">    &#39;&#39;&#39;</span>
    <span class="n">mask</span> <span class="o">=</span> <span class="n">mask</span><span class="o">.</span><span class="n">split</span><span class="p">(</span> <span class="n">split</span> <span class="p">)</span>
    <span class="n">ret</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span> <span class="p">)</span>
    <span class="n">a</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="k">for</span> <span class="n">m</span> <span class="ow">in</span> <span class="n">mask</span><span class="p">:</span>
        <span class="n">t</span> <span class="o">=</span> <span class="n">a</span> <span class="o">+</span> <span class="nb">len</span><span class="p">(</span> <span class="n">m</span> <span class="p">)</span>
        <span class="n">ret</span><span class="o">.</span><span class="n">append</span><span class="p">(</span> <span class="n">string</span><span class="p">[</span><span class="n">a</span><span class="p">:</span><span class="n">t</span><span class="p">]</span> <span class="p">)</span>
        <span class="n">a</span> <span class="o">=</span> <span class="n">t</span> <span class="o">+</span> <span class="nb">len</span><span class="p">(</span> <span class="n">split</span> <span class="p">)</span>
    <span class="k">return</span><span class="p">(</span> <span class="n">ret</span> <span class="p">)</span></div>

<div class="viewcode-block" id="terms_in"><a class="viewcode-back" href="../ParallelRegression.html#ParallelRegression.terms_in">[docs]</a><span class="k">def</span> <span class="nf">terms_in</span><span class="p">(</span> <span class="n">formula</span> <span class="p">):</span>
    <span class="sd">&#39;&#39;&#39;Generator that yields individual terms in `formula`.</span>
<span class="sd">    &#39;&#39;&#39;</span>
    <span class="n">mask</span> <span class="o">=</span> <span class="n">mask_brackets</span><span class="p">(</span> <span class="n">formula</span> <span class="p">)</span>
    <span class="k">for</span> <span class="n">mobj</span> <span class="ow">in</span> <span class="n">termpattern</span><span class="o">.</span><span class="n">finditer</span><span class="p">(</span> <span class="n">mask</span> <span class="p">):</span>
        <span class="n">a</span><span class="p">,</span> <span class="n">t</span> <span class="o">=</span> <span class="n">mobj</span><span class="o">.</span><span class="n">span</span><span class="p">(</span> <span class="p">)</span>
        <span class="k">yield</span> <span class="n">formula</span><span class="p">[</span><span class="n">a</span><span class="p">:</span><span class="n">t</span><span class="p">]</span></div>


<span class="k">def</span> <span class="nf">_regex_split</span><span class="p">(</span> <span class="n">string</span><span class="p">,</span> <span class="n">pattern</span> <span class="p">):</span>
    <span class="n">a</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="n">wall</span> <span class="o">=</span> <span class="n">pattern</span><span class="o">.</span><span class="n">search</span><span class="p">(</span> <span class="n">string</span> <span class="p">)</span>
    <span class="k">while</span> <span class="n">wall</span> <span class="o">!=</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">t</span> <span class="o">=</span> <span class="n">wall</span><span class="o">.</span><span class="n">start</span><span class="p">(</span> <span class="p">)</span>
        <span class="k">yield</span><span class="p">(</span> <span class="n">string</span><span class="p">[</span><span class="n">a</span><span class="p">:</span><span class="n">t</span><span class="p">]</span> <span class="p">)</span>
        <span class="n">a</span> <span class="o">=</span> <span class="n">wall</span><span class="o">.</span><span class="n">end</span><span class="p">(</span> <span class="p">)</span>
        <span class="n">wall</span> <span class="o">=</span> <span class="n">pattern</span><span class="o">.</span><span class="n">search</span><span class="p">(</span> <span class="n">string</span><span class="p">,</span> <span class="n">a</span> <span class="p">)</span>
    <span class="k">if</span> <span class="n">a</span> <span class="o">&lt;</span> <span class="nb">len</span><span class="p">(</span> <span class="n">string</span> <span class="p">):</span>
        <span class="k">yield</span><span class="p">(</span> <span class="n">string</span><span class="p">[</span><span class="n">a</span><span class="p">:]</span> <span class="p">)</span>

<span class="k">def</span> <span class="nf">_patsy_terms</span><span class="p">(</span> <span class="n">formula</span><span class="p">,</span> <span class="n">reduce_to_vars</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">setfrozen</span><span class="o">=</span><span class="kc">True</span> <span class="p">):</span>
    <span class="c1">## Mask brackets so that only patsy operators are processed.</span>
    <span class="n">mask</span> <span class="o">=</span> <span class="n">mask_brackets</span><span class="p">(</span> <span class="n">formula</span> <span class="p">)</span>
    <span class="n">start</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="n">final</span> <span class="o">=</span> <span class="kc">False</span>
    <span class="n">patsySet</span> <span class="o">=</span> <span class="n">setList</span><span class="p">(</span> <span class="p">)</span>
    <span class="n">wall</span> <span class="o">=</span> <span class="n">splitter</span><span class="o">.</span><span class="n">search</span><span class="p">(</span> <span class="n">mask</span><span class="p">,</span> <span class="n">start</span> <span class="p">)</span>
    <span class="c1">## Treating `+`, `-`, and `~` as walls between terms,</span>
    <span class="c1">## create a set of factors in each term, splitting on &#39;:&#39;.</span>
    <span class="k">while</span> <span class="n">wall</span> <span class="o">!=</span> <span class="kc">None</span> <span class="ow">or</span> <span class="n">final</span> <span class="o">==</span> <span class="kc">False</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">wall</span> <span class="o">==</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">final</span> <span class="o">=</span> <span class="kc">True</span>
            <span class="n">endpos</span> <span class="o">=</span> <span class="n">wallpos</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span> <span class="n">formula</span> <span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">wallpos</span> <span class="o">=</span> <span class="n">wall</span><span class="o">.</span><span class="n">start</span><span class="p">(</span> <span class="p">)</span>
            <span class="n">endpos</span> <span class="o">=</span> <span class="n">wall</span><span class="o">.</span><span class="n">end</span><span class="p">(</span> <span class="p">)</span>
        <span class="n">factorList</span> <span class="o">=</span> <span class="n">formula</span><span class="p">[</span><span class="n">start</span><span class="p">:</span><span class="n">wallpos</span><span class="p">]</span>
        <span class="n">factorList</span> <span class="o">=</span> <span class="n">factorList</span><span class="o">.</span><span class="n">split</span><span class="p">(</span> <span class="s1">&#39;:&#39;</span> <span class="p">)</span>
        <span class="n">factorList2</span> <span class="o">=</span> <span class="n">setList</span><span class="p">(</span> <span class="p">)</span>
        <span class="k">for</span> <span class="n">f</span> <span class="ow">in</span> <span class="n">factorList</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">reduce_to_vars</span> <span class="o">==</span> <span class="kc">True</span><span class="p">:</span>
                <span class="n">factorList2</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span> <span class="n">_vars_in_factor</span><span class="p">(</span> <span class="n">f</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span> <span class="s1">&#39; &#39;</span><span class="p">,</span> <span class="s1">&#39;&#39;</span> <span class="p">)</span> <span class="p">)</span> <span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">factorList2</span><span class="o">.</span><span class="n">append</span><span class="p">(</span> <span class="n">f</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span> <span class="s1">&#39; &#39;</span><span class="p">,</span> <span class="s1">&#39;&#39;</span> <span class="p">)</span> <span class="p">)</span>
        <span class="n">patsySet</span><span class="o">.</span><span class="n">append</span><span class="p">(</span> <span class="n">factorList2</span> <span class="p">)</span>
        <span class="n">start</span> <span class="o">=</span> <span class="n">endpos</span>
        <span class="k">if</span> <span class="n">wall</span> <span class="o">!=</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">wall</span> <span class="o">=</span> <span class="n">splitter</span><span class="o">.</span><span class="n">search</span><span class="p">(</span> <span class="n">mask</span><span class="p">,</span> <span class="n">start</span> <span class="p">)</span>
    <span class="k">return</span><span class="p">(</span> <span class="n">patsySet</span> <span class="p">)</span>

<span class="n">poly_rs</span> <span class="o">=</span> <span class="s1">r&#39; *([a-zA-Z_][a-zA-Z_0-9]*(?![a-zA-Z_0-9\(\{\[])) *\*\* *([0-9]+) *&#39;</span>
<span class="n">polypattern</span>   <span class="o">=</span> <span class="n">re</span><span class="o">.</span><span class="n">compile</span><span class="p">(</span> <span class="n">poly_rs</span> <span class="p">)</span>
<span class="n">polypattern_I</span> <span class="o">=</span> <span class="n">re</span><span class="o">.</span><span class="n">compile</span><span class="p">(</span> <span class="s1">r&#39;I\(&#39;</span> <span class="o">+</span> <span class="n">poly_rs</span> <span class="o">+</span> <span class="s1">r&#39;\)&#39;</span> <span class="p">)</span>

<span class="k">def</span> <span class="nf">pre_rstr</span><span class="p">(</span> <span class="n">name</span><span class="o">=</span><span class="kc">None</span> <span class="p">):</span>                        <span class="c1"># initial underscore omitted</span>
    <span class="k">if</span> <span class="n">name</span> <span class="o">==</span> <span class="kc">None</span><span class="p">:</span>                              <span class="c1"># for brevity, treat as a</span>
        <span class="k">return</span><span class="p">(</span> <span class="s1">r&#39;(?:L(?:[0-9]+))@&#39;</span> <span class="p">)</span>             <span class="c1"># private function.</span>
    <span class="k">return</span><span class="p">(</span> <span class="s1">r&#39;(?:L(?P&lt;&#39;</span> <span class="o">+</span> <span class="n">name</span> <span class="o">+</span> <span class="s1">r&#39;&gt;[0-9]+))@&#39;</span> <span class="p">)</span>

<span class="n">prefixed_varpattern_rstr</span> <span class="o">=</span> <span class="s1">r&#39;(?:&#39;</span> <span class="o">+</span> <span class="n">pre_rstr</span><span class="p">(</span> <span class="p">)</span> <span class="o">+</span> <span class="s1">r&#39;)?&#39;</span> <span class="o">+</span> <span class="n">varpattern_rstr</span>
<span class="n">prefixed_varpattern</span> <span class="o">=</span> <span class="n">re</span><span class="o">.</span><span class="n">compile</span><span class="p">(</span> <span class="n">prefixed_varpattern_rstr</span> <span class="p">)</span>
<span class="n">powerpattern</span> <span class="o">=</span> <span class="n">re</span><span class="o">.</span><span class="n">compile</span><span class="p">(</span> <span class="s1">r&#39;\ *(?:&#39;</span> <span class="o">+</span> <span class="n">pre_rstr</span><span class="p">(</span> <span class="s1">r&#39;lag&#39;</span> <span class="p">)</span> <span class="o">+</span> <span class="s1">r&#39;&#39;&#39;)?</span>
<span class="s1">                                (?P&lt;column_name&gt;&#39;&#39;&#39;</span> <span class="o">+</span> <span class="n">varpattern_rstr</span> <span class="o">+</span> <span class="s1">r&#39;&#39;&#39;)</span>
<span class="s1">                   (?:\ *\*\*\ *(?P&lt;power&gt;[0-9]+)\ *)?&#39;&#39;&#39;</span><span class="p">,</span> <span class="n">re</span><span class="o">.</span><span class="n">X</span> <span class="p">)</span>
<span class="c1">###############################################################################</span>
<span class="n">crosspower</span> <span class="o">=</span> <span class="n">re</span><span class="o">.</span><span class="n">compile</span><span class="p">(</span> <span class="s1">r&#39;(?:&#39;</span> <span class="o">+</span> <span class="n">pre_rstr</span><span class="p">(</span> <span class="s1">r&#39;lag_a&#39;</span> <span class="p">)</span> <span class="o">+</span> <span class="s1">r&#39;&#39;&#39;)?</span>
<span class="s1">                           (?P&lt;column_a&gt;&#39;&#39;&#39;</span> <span class="o">+</span> <span class="n">varpattern_rstr</span> <span class="o">+</span> <span class="s1">r&#39;&#39;&#39;)</span>
<span class="s1">              (?:\ *\*\*\ *(?P&lt;power_a&gt;[0-9]+)\ *)?</span>
<span class="s1">               \ *\*\ *&#39;&#39;&#39;</span> <span class="o">+</span> <span class="c1"># multiplication</span>
                         <span class="s1">r&#39;(?:&#39;</span> <span class="o">+</span> <span class="n">pre_rstr</span><span class="p">(</span> <span class="s1">r&#39;lag_b&#39;</span> <span class="p">)</span> <span class="o">+</span> <span class="s1">r&#39;&#39;&#39;)?</span>
<span class="s1">                           (?P&lt;column_b&gt;&#39;&#39;&#39;</span> <span class="o">+</span> <span class="n">varpattern_rstr</span> <span class="o">+</span> <span class="s1">r&#39;&#39;&#39;)</span>
<span class="s1">              (?:\ *\*\*\ *(?P&lt;power_b&gt;[0-9]+)\ *)?&#39;&#39;&#39;</span><span class="p">,</span> <span class="n">re</span><span class="o">.</span><span class="n">X</span> <span class="p">)</span>
<span class="c1">###############################################################################</span>
<span class="n">cross_Aor_power</span> <span class="o">=</span> <span class="n">re</span><span class="o">.</span><span class="n">compile</span><span class="p">(</span> <span class="s1">r&#39;(?:&#39;</span> <span class="o">+</span> <span class="n">pre_rstr</span><span class="p">(</span> <span class="s1">r&#39;lag_a&#39;</span> <span class="p">)</span> <span class="o">+</span> <span class="s1">r&#39;&#39;&#39;)?</span>
<span class="s1">                                (?P&lt;column_a&gt;&#39;&#39;&#39;</span> <span class="o">+</span> <span class="n">varpattern_rstr</span> <span class="o">+</span> <span class="s1">r&#39;&#39;&#39;)</span>
<span class="s1">                   (?:\ *\*\*\ *(?P&lt;power_a&gt;[0-9]+)\ *)?</span>
<span class="s1">                  \ *\*?\ *&#39;&#39;&#39;</span> <span class="o">+</span> <span class="c1"># multiplication</span>
                              <span class="s1">r&#39;(?:&#39;</span> <span class="o">+</span> <span class="n">pre_rstr</span><span class="p">(</span> <span class="s1">r&#39;lag_b&#39;</span> <span class="p">)</span> <span class="o">+</span> <span class="s1">r&#39;&#39;&#39;)?</span>
<span class="s1">                                (?P&lt;column_b&gt;&#39;&#39;&#39;</span> <span class="o">+</span> <span class="n">varpattern_rstr</span> <span class="o">+</span> <span class="s1">r&#39;&#39;&#39;)?</span>
<span class="s1">                   (?:\ *\*\*\ *(?P&lt;power_b&gt;[0-9]+)\ *)?&#39;&#39;&#39;</span><span class="p">,</span> <span class="n">re</span><span class="o">.</span><span class="n">X</span> <span class="p">)</span>
<span class="c1">###############################################################################</span>
<span class="n">crosspattern</span> <span class="o">=</span> <span class="n">re</span><span class="o">.</span><span class="n">compile</span><span class="p">(</span> <span class="s1">r&#39;\ *(?P&lt;column_a&gt;&#39;</span> <span class="o">+</span> <span class="n">varpattern_rstr</span> <span class="o">+</span> <span class="s1">r&#39;&#39;&#39;)</span>
<span class="s1">                   \ *\*\ *&#39;&#39;&#39;</span> <span class="o">+</span> <span class="c1"># multiplication</span>
                           <span class="s1">r&#39;\ *(?P&lt;column_b&gt;&#39;</span> <span class="o">+</span> <span class="n">varpattern_rstr</span> <span class="o">+</span> <span class="s1">r&#39;)\ *&#39;</span><span class="p">,</span>
                           <span class="n">re</span><span class="o">.</span><span class="n">X</span> <span class="p">)</span>

<span class="k">def</span> <span class="nf">_vars_in_factor</span><span class="p">(</span> <span class="n">factor</span> <span class="p">):</span>
    <span class="n">ret</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span> <span class="p">)</span>
    <span class="k">for</span> <span class="n">mobj</span> <span class="ow">in</span> <span class="n">varpattern</span><span class="o">.</span><span class="n">finditer</span><span class="p">(</span> <span class="n">factor</span> <span class="p">):</span>
        <span class="n">ret</span><span class="o">.</span><span class="n">append</span><span class="p">(</span> <span class="n">mobj</span><span class="o">.</span><span class="n">group</span><span class="p">(</span> <span class="p">)</span> <span class="p">)</span>
    <span class="k">return</span><span class="p">(</span> <span class="n">ret</span> <span class="p">)</span>

<span class="n">impr_space_pattern</span> <span class="o">=</span> <span class="n">re</span><span class="o">.</span><span class="n">compile</span><span class="p">(</span> <span class="s1">r&#39;[a-zA-Z_0-9] +[a-zA-Z_0-9]&#39;</span> <span class="p">)</span>
<div class="viewcode-block" id="formulas_match"><a class="viewcode-back" href="../ParallelRegression.html#ParallelRegression.formulas_match">[docs]</a><span class="k">def</span> <span class="nf">formulas_match</span><span class="p">(</span> <span class="n">formA</span><span class="p">,</span> <span class="n">formB</span> <span class="p">):</span>
    <span class="sd">&#39;&#39;&#39;Determines whether or not two formula strings are the same formula</span>
<span class="sd">    despite differences in the order of terms and/or spacing.</span>
<span class="sd">    &#39;&#39;&#39;</span>
    <span class="k">def</span> <span class="nf">re_sort</span><span class="p">(</span> <span class="n">item</span> <span class="p">):</span>
        <span class="n">strList</span> <span class="o">=</span> <span class="p">[</span><span class="nb">str</span><span class="p">(</span> <span class="n">x</span> <span class="p">)</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">_regex_split</span><span class="p">(</span> <span class="n">item</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">one_star</span> <span class="p">)]</span>
        <span class="n">strList</span><span class="o">.</span><span class="n">sort</span><span class="p">(</span> <span class="p">)</span>
        <span class="n">item</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="s1">&#39;*&#39;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span> <span class="n">strList</span> <span class="p">)</span>
        <span class="k">return</span><span class="p">(</span> <span class="n">item</span> <span class="p">)</span>
    <span class="k">def</span> <span class="nf">prep</span><span class="p">(</span> <span class="n">string</span> <span class="p">):</span>
        <span class="n">mobj</span> <span class="o">=</span> <span class="n">impr_space_pattern</span><span class="o">.</span><span class="n">search</span><span class="p">(</span> <span class="n">string</span> <span class="p">)</span>
        <span class="k">if</span> <span class="n">mobj</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span> <span class="s1">&#39;There is an improper space in `</span><span class="si">%s</span><span class="s1">`.&#39;</span> <span class="o">%</span> <span class="n">string</span> <span class="p">)</span>
        <span class="k">return</span><span class="p">(</span> <span class="n">string</span><span class="o">.</span><span class="n">split</span><span class="p">(</span> <span class="s1">&#39;~&#39;</span> <span class="p">)</span> <span class="p">)</span>
    <span class="n">formA</span> <span class="o">=</span> <span class="n">prep</span><span class="p">(</span> <span class="n">formA</span> <span class="p">)</span>
    <span class="n">formB</span> <span class="o">=</span> <span class="n">prep</span><span class="p">(</span> <span class="n">formB</span> <span class="p">)</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span> <span class="n">formA</span> <span class="p">)</span> <span class="o">!=</span> <span class="nb">len</span><span class="p">(</span> <span class="n">formB</span> <span class="p">):</span>
        <span class="k">return</span><span class="p">(</span> <span class="kc">False</span> <span class="p">)</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span> <span class="nb">len</span><span class="p">(</span> <span class="n">formA</span> <span class="p">)</span> <span class="p">):</span>
        <span class="n">termsA</span> <span class="o">=</span> <span class="n">_patsy_terms</span><span class="p">(</span> <span class="n">formA</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">reduce_to_vars</span><span class="o">=</span><span class="kc">False</span> <span class="p">)</span>
        <span class="n">termsB</span> <span class="o">=</span> <span class="n">_patsy_terms</span><span class="p">(</span> <span class="n">formB</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">reduce_to_vars</span><span class="o">=</span><span class="kc">False</span> <span class="p">)</span>
        <span class="n">termsA</span><span class="o">.</span><span class="n">_re_sort</span> <span class="o">=</span> <span class="n">re_sort</span>
        <span class="n">termsB</span><span class="o">.</span><span class="n">_re_sort</span> <span class="o">=</span> <span class="n">re_sort</span>
        <span class="k">if</span> <span class="n">termsA</span><span class="o">.</span><span class="n">as_fsets</span> <span class="o">!=</span> <span class="n">termsB</span><span class="o">.</span><span class="n">as_fsets</span><span class="p">:</span>
            <span class="k">return</span><span class="p">(</span> <span class="kc">False</span> <span class="p">)</span>
    <span class="k">return</span><span class="p">(</span> <span class="kc">True</span> <span class="p">)</span></div>

<span class="k">def</span> <span class="nf">_soft_in</span><span class="p">(</span> <span class="n">checking</span><span class="p">,</span> <span class="n">container</span><span class="p">,</span> <span class="n">else_unchanged</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">else_val</span><span class="o">=</span><span class="kc">None</span> <span class="p">):</span>
    <span class="k">if</span> <span class="n">checking</span> <span class="ow">in</span> <span class="n">container</span><span class="p">:</span>
        <span class="k">return</span><span class="p">(</span> <span class="n">checking</span><span class="p">,</span> <span class="kc">True</span> <span class="p">)</span>
    <span class="k">for</span> <span class="n">member</span> <span class="ow">in</span> <span class="n">container</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">formulas_match</span><span class="p">(</span> <span class="n">checking</span><span class="p">,</span> <span class="n">member</span> <span class="p">):</span>
            <span class="k">return</span><span class="p">(</span> <span class="n">member</span><span class="p">,</span> <span class="kc">True</span> <span class="p">)</span>
    <span class="k">if</span> <span class="n">else_unchanged</span><span class="p">:</span>
        <span class="n">else_val</span> <span class="o">=</span> <span class="n">checking</span>
    <span class="k">return</span><span class="p">(</span> <span class="n">else_val</span><span class="p">,</span> <span class="kc">False</span> <span class="p">)</span>

<div class="viewcode-block" id="termString"><a class="viewcode-back" href="../ParallelRegression.html#ParallelRegression.termString">[docs]</a><span class="k">def</span> <span class="nf">termString</span><span class="p">(</span> <span class="n">formula</span><span class="p">,</span> <span class="n">termList</span> <span class="p">):</span>
    <span class="sd">&#39;&#39;&#39;Returns the subset of terms in `termList` that occur in `formula`.</span>
<span class="sd">    &#39;&#39;&#39;</span>
    <span class="n">termString</span> <span class="o">=</span> <span class="s1">&#39;&#39;</span>
    <span class="k">for</span> <span class="n">t</span> <span class="ow">in</span> <span class="n">termList</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">has_term</span><span class="p">(</span> <span class="n">formula</span><span class="p">,</span> <span class="n">t</span> <span class="p">):</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span> <span class="n">termString</span> <span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">termString</span> <span class="o">+=</span> <span class="s1">&#39;, &#39;</span>
            <span class="n">termString</span> <span class="o">+=</span> <span class="n">t</span>
    <span class="k">return</span><span class="p">(</span> <span class="n">termString</span> <span class="p">)</span></div>

<span class="k">def</span> <span class="nf">_mapper</span><span class="p">(</span> <span class="n">ProcessQueue</span><span class="p">,</span>
             <span class="n">ReturnQueue</span><span class="p">,</span>
             <span class="n">SharedDataArray</span><span class="p">,</span>
             <span class="n">mDictCfg</span><span class="p">,</span>
             <span class="n">func</span><span class="p">,</span>
             <span class="n">placement</span><span class="p">,</span>
             <span class="n">number_results</span><span class="o">=</span><span class="kc">False</span> <span class="p">):</span>
    <span class="n">mDict</span> <span class="o">=</span> <span class="n">mDictCfg</span><span class="o">.</span><span class="n">rebuild</span><span class="p">(</span> <span class="n">SharedDataArray</span> <span class="p">)</span>
    <span class="n">matrix</span> <span class="o">=</span> <span class="n">mDict</span><span class="p">[:]</span>
    <span class="n">QueueObject</span> <span class="o">=</span> <span class="n">ProcessQueue</span><span class="o">.</span><span class="n">get</span><span class="p">(</span> <span class="p">)</span>
    <span class="k">while</span> <span class="n">QueueObject</span> <span class="o">!=</span> <span class="s1">&#39;Terminate.&#39;</span><span class="p">:</span>
        <span class="n">rid</span><span class="p">,</span> <span class="n">args</span><span class="p">,</span> <span class="n">kwargs</span> <span class="o">=</span> <span class="n">QueueObject</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span> <span class="n">placement</span><span class="p">,</span> <span class="nb">int</span> <span class="p">):</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span> <span class="n">args</span> <span class="p">)</span> <span class="o">&lt;</span> <span class="n">placement</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span> <span class="s1">&#39;Not enough positional arguments to insert &#39;</span>
                                  <span class="s1">&#39;the matrix at </span><span class="si">%d</span><span class="s1">.&#39;</span> <span class="o">%</span> <span class="n">placement</span> <span class="p">)</span>
            <span class="n">pargs</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span> <span class="n">args</span><span class="p">[:</span><span class="n">placement</span><span class="p">]</span> <span class="p">)</span>
            <span class="n">pargs</span><span class="o">.</span><span class="n">append</span><span class="p">(</span> <span class="n">matrix</span> <span class="p">)</span>
            <span class="n">pargs</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span> <span class="n">args</span><span class="p">[</span><span class="n">placement</span><span class="p">:]</span> <span class="p">)</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span> <span class="n">placement</span><span class="p">,</span> <span class="nb">str</span> <span class="p">):</span>
            <span class="n">kwargs</span><span class="p">[</span><span class="n">placement</span><span class="p">]</span> <span class="o">=</span> <span class="n">matrix</span>
            <span class="n">pargs</span> <span class="o">=</span> <span class="n">args</span>
        <span class="n">ReturnQueue</span><span class="o">.</span><span class="n">put</span><span class="p">(</span> <span class="p">(</span><span class="n">rid</span><span class="p">,</span> <span class="n">func</span><span class="p">(</span> <span class="o">*</span><span class="n">pargs</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span> <span class="p">))</span> <span class="p">)</span>
        <span class="n">QueueObject</span> <span class="o">=</span> <span class="n">ProcessQueue</span><span class="o">.</span><span class="n">get</span><span class="p">(</span> <span class="p">)</span>
    <span class="n">ReturnQueue</span><span class="o">.</span><span class="n">put</span><span class="p">(</span> <span class="s1">&#39;Terminated.&#39;</span> <span class="p">)</span>

<div class="viewcode-block" id="CategoryError"><a class="viewcode-back" href="../ParallelRegression.html#ParallelRegression.CategoryError">[docs]</a><span class="k">class</span> <span class="nc">CategoryError</span><span class="p">(</span><span class="ne">Exception</span><span class="p">):</span>
    <span class="sd">&#39;&#39;&#39;Raised by categorizedSetDict( ) when an error results from an invalid</span>
<span class="sd">    category as opposed to an invalid key or value that would raise a KeyError</span>
<span class="sd">    or ValueError.</span>
<span class="sd">    &#39;&#39;&#39;</span>
    <span class="k">pass</span></div>

<div class="viewcode-block" id="UnsupportedColumn"><a class="viewcode-back" href="../ParallelRegression.html#ParallelRegression.UnsupportedColumn">[docs]</a><span class="k">class</span> <span class="nc">UnsupportedColumn</span><span class="p">(</span><span class="ne">Warning</span><span class="p">):</span>
    <span class="sd">&#39;&#39;&#39;Raised by mathDict( ) when .add( ) or .add_from_RHS( ) is used in an</span>
<span class="sd">    attempt to add a string as a column that is not understood as a column by</span>
<span class="sd">    mathDict( ).</span>

<span class="sd">    Attributes</span>
<span class="sd">    ----------</span>
<span class="sd">    msg, args[0] : string</span>
<span class="sd">        Error message.</span>
<span class="sd">    columns, args[1] : list</span>
<span class="sd">        Lists the column or columns that are not understood by mathDict( ).</span>
<span class="sd">    LHS : string</span>
<span class="sd">        The left-hand-side of a formula string provided to .add_from_RHS( )</span>
<span class="sd">        when the formula string contained at least one tilde (&#39;~&#39;) character.</span>
<span class="sd">    &#39;&#39;&#39;</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="n">LHS</span><span class="o">=</span><span class="kc">None</span> <span class="p">):</span>
        <span class="ne">Warning</span><span class="o">.</span><span class="n">__init__</span><span class="p">(</span> <span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span> <span class="p">)</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span> <span class="n">args</span> <span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">msg</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">args</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span> <span class="n">args</span> <span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">columns</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">args</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">LHS</span> <span class="o">=</span> <span class="n">LHS</span></div>

<div class="viewcode-block" id="mathDictKeyError"><a class="viewcode-back" href="../ParallelRegression.html#ParallelRegression.mathDictKeyError">[docs]</a><span class="k">class</span> <span class="nc">mathDictKeyError</span><span class="p">(</span><span class="ne">KeyError</span><span class="p">):</span>
    <span class="sd">&#39;&#39;&#39;Subclass of KeyError used in error handling to distinguish between</span>
<span class="sd">    calling mathDict( ).__getitem__( ) with an invalid key/index, resulting in</span>
<span class="sd">    mathDictKeyError, or a facially-valid key/index the handling of which</span>
<span class="sd">    causes a KeyError for some other reason.</span>
<span class="sd">    &#39;&#39;&#39;</span>
    <span class="k">pass</span></div>

<div class="viewcode-block" id="RankError"><a class="viewcode-back" href="../ParallelRegression.html#ParallelRegression.RankError">[docs]</a><span class="k">class</span> <span class="nc">RankError</span><span class="p">(</span><span class="ne">Warning</span><span class="p">):</span>
    <span class="sd">&#39;&#39;&#39;Raised by mathDictHypothesis( ) when mathDictHypothesis( ).add( ) is</span>
<span class="sd">    able to determine that adding a hypothesis about the specified column would</span>
<span class="sd">    result in a matrix of insufficient rank for computing an F statistic</span>
<span class="sd">    evaluating the hypothesis.</span>

<span class="sd">    To enable mathDict&#39;s ability to anticipate matrices of less than full rank,</span>
<span class="sd">    use the .terms termSet( ) attribute of mathDict( ) to inform</span>
<span class="sd">    mathDictHypothesis( ) which terms in which forms are dummy variables.  This</span>
<span class="sd">    has been shown in profiles to be substantially more efficient than</span>
<span class="sd">    mathematically determining the impact of the additional column on the rank</span>
<span class="sd">    of the matrix.</span>

<span class="sd">    Example</span>
<span class="sd">    -------</span>
<span class="sd">    &gt;&gt;&gt; RA, MD = mathDictMaker( [details omitted] ).make( )</span>
<span class="sd">    &gt;&gt;&gt; MD.terms = termSet( [details omitted] )</span>
<span class="sd">    &gt;&gt;&gt; MD.hypothesis.add( [details omitted] )</span>
<span class="sd">    &gt;&gt;&gt; # Link the mathDict( ) to an existing termSet( ) using simple attribute</span>
<span class="sd">    &gt;&gt;&gt; # assignment.</span>
<span class="sd">    &#39;&#39;&#39;</span>
    <span class="k">pass</span></div>

<div class="viewcode-block" id="setList"><a class="viewcode-back" href="../ParallelRegression.html#ParallelRegression.setList">[docs]</a><span class="k">class</span> <span class="nc">setList</span><span class="p">(</span><span class="n">UserList</span><span class="p">):</span>
    <span class="sd">&#39;&#39;&#39;List that eliminates redundant list items and implements set comparison</span>
<span class="sd">    methods.</span>
<span class="sd">    &#39;&#39;&#39;</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">values</span><span class="o">=</span><span class="kc">None</span> <span class="p">):</span>
        <span class="n">UserList</span><span class="o">.</span><span class="n">__init__</span><span class="p">(</span> <span class="bp">self</span> <span class="p">)</span>
        <span class="k">if</span> <span class="n">values</span> <span class="o">!=</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span> <span class="n">values</span> <span class="p">)</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span> <span class="n">values</span><span class="p">,</span> <span class="p">(</span><span class="nb">set</span><span class="p">,</span> <span class="nb">frozenset</span><span class="p">,</span> <span class="nb">type</span><span class="p">(</span> <span class="nb">dict</span><span class="p">(</span> <span class="p">)</span><span class="o">.</span><span class="n">keys</span><span class="p">(</span> <span class="p">)</span> <span class="p">))</span> <span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">sort</span><span class="p">(</span> <span class="p">)</span>

    <span class="k">def</span> <span class="nf">__setitem__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">key</span><span class="p">,</span> <span class="n">value</span> <span class="p">):</span>
        <span class="k">if</span> <span class="n">value</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">lastSIOutcome</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">key</span> <span class="o">==</span> <span class="nb">len</span><span class="p">(</span> <span class="bp">self</span><span class="o">.</span><span class="n">data</span> <span class="p">):</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">append</span><span class="p">(</span> <span class="n">value</span> <span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="n">value</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">lastSIOutcome</span> <span class="o">=</span> <span class="kc">True</span>

    <span class="k">def</span> <span class="nf">append</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">value</span> <span class="p">):</span>
        <span class="k">if</span> <span class="n">value</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="p">:</span>
            <span class="k">return</span><span class="p">(</span> <span class="kc">False</span> <span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">append</span><span class="p">(</span> <span class="n">value</span> <span class="p">)</span>
            <span class="k">return</span><span class="p">(</span> <span class="kc">True</span> <span class="p">)</span>

    <span class="k">def</span> <span class="nf">extend</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">values</span> <span class="p">):</span>
        <span class="k">return</span><span class="p">(</span> <span class="bp">self</span><span class="o">.</span><span class="n">update</span><span class="p">(</span> <span class="n">values</span> <span class="p">)</span> <span class="p">)</span>

    <span class="k">def</span> <span class="nf">add</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">value</span> <span class="p">):</span>
        <span class="k">return</span><span class="p">(</span> <span class="bp">self</span><span class="o">.</span><span class="n">append</span><span class="p">(</span> <span class="n">value</span> <span class="p">)</span> <span class="p">)</span>

    <span class="k">def</span> <span class="nf">discard</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">value</span> <span class="p">):</span>
        <span class="k">if</span> <span class="n">value</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">remove</span><span class="p">(</span> <span class="n">value</span> <span class="p">)</span>
            <span class="k">return</span><span class="p">(</span> <span class="kc">True</span> <span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span><span class="p">(</span> <span class="kc">False</span> <span class="p">)</span>

    <span class="k">def</span> <span class="nf">pop</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="p">,</span> <span class="n">value</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">index</span><span class="o">=</span><span class="kc">None</span> <span class="p">):</span>
        <span class="k">if</span> <span class="n">index</span> <span class="o">!=</span> <span class="kc">None</span> <span class="ow">and</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span> <span class="n">index</span><span class="p">,</span> <span class="nb">int</span> <span class="p">):</span>
            <span class="k">raise</span> <span class="ne">KeyError</span><span class="p">(</span> <span class="s1">&#39;Index must be specified as an integer.&#39;</span><span class="p">,</span> <span class="n">index</span> <span class="p">)</span>
        <span class="k">if</span> <span class="n">value</span> <span class="o">!=</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">index</span> <span class="o">!=</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">KeyError</span><span class="p">(</span> <span class="s1">&#39;Pop can remove an item by index or value but not&#39;</span>
                            <span class="s1">&#39; both.  Value specified: </span><span class="si">%s</span><span class="s1">, index specified: </span><span class="si">%d</span><span class="s1">.&#39;</span>
                            <span class="o">%</span> <span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="n">index</span><span class="p">)</span> <span class="p">)</span>
        <span class="k">if</span> <span class="n">index</span> <span class="o">!=</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">return</span><span class="p">(</span> <span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span> <span class="n">index</span> <span class="p">)</span> <span class="p">)</span>
        <span class="k">elif</span> <span class="n">value</span> <span class="o">!=</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">value</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">KeyError</span><span class="p">(</span> <span class="s1">&#39;`</span><span class="si">%s</span><span class="s1">` not in </span><span class="si">%s</span><span class="s1">.&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span> <span class="p">)</span>
            <span class="n">i</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">index</span><span class="p">(</span> <span class="n">value</span> <span class="p">)</span>
            <span class="k">return</span><span class="p">(</span> <span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span> <span class="n">i</span> <span class="p">)</span> <span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">KeyError</span><span class="p">(</span> <span class="s1">&#39;One of `index` or `value` must be specified by &#39;</span>
                            <span class="s1">&#39;keyword arguement when calling setList.pop( ).&#39;</span> <span class="p">)</span>

    <span class="k">def</span> <span class="nf">update</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">values</span> <span class="p">):</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span> <span class="n">values</span><span class="p">,</span> <span class="p">(</span><span class="nb">set</span><span class="p">,</span> <span class="nb">frozenset</span><span class="p">,</span> <span class="nb">type</span><span class="p">(</span> <span class="nb">dict</span><span class="p">(</span> <span class="p">)</span><span class="o">.</span><span class="n">keys</span><span class="p">(</span> <span class="p">)</span> <span class="p">))</span> <span class="p">):</span>
            <span class="n">values</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span> <span class="n">values</span> <span class="p">)</span>
            <span class="n">values</span><span class="o">.</span><span class="n">sort</span><span class="p">(</span> <span class="p">)</span>
        <span class="n">counter</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">for</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">values</span><span class="p">:</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">append</span><span class="p">(</span> <span class="n">v</span> <span class="p">)</span> <span class="o">==</span> <span class="kc">True</span><span class="p">:</span>
                <span class="n">counter</span> <span class="o">+=</span> <span class="mi">1</span>
        <span class="k">return</span><span class="p">(</span> <span class="n">counter</span> <span class="p">)</span>

    <span class="k">def</span> <span class="nf">difference</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span> <span class="p">):</span>
        <span class="n">new</span> <span class="o">=</span> <span class="n">setList</span><span class="p">(</span> <span class="p">)</span>
        <span class="k">for</span> <span class="n">value</span> <span class="ow">in</span> <span class="bp">self</span><span class="p">:</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">value</span> <span class="ow">in</span> <span class="n">other</span><span class="p">:</span>
                <span class="n">new</span><span class="o">.</span><span class="n">append</span><span class="p">(</span> <span class="n">value</span> <span class="p">)</span>
        <span class="k">return</span><span class="p">(</span> <span class="n">new</span> <span class="p">)</span>

    <span class="k">def</span> <span class="nf">union</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span> <span class="p">):</span>
        <span class="n">new</span> <span class="o">=</span> <span class="n">setList</span><span class="p">(</span> <span class="p">)</span>
        <span class="n">new</span><span class="o">.</span><span class="n">update</span><span class="p">(</span> <span class="bp">self</span> <span class="p">)</span>
        <span class="n">new</span><span class="o">.</span><span class="n">update</span><span class="p">(</span> <span class="n">other</span> <span class="p">)</span>
        <span class="k">return</span><span class="p">(</span> <span class="n">new</span> <span class="p">)</span>

    <span class="k">def</span> <span class="nf">intersection</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span> <span class="p">):</span>
        <span class="n">new</span> <span class="o">=</span> <span class="n">setList</span><span class="p">(</span> <span class="p">)</span>
        <span class="k">for</span> <span class="n">value</span> <span class="ow">in</span> <span class="bp">self</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">value</span> <span class="ow">in</span> <span class="n">other</span><span class="p">:</span>
                <span class="n">new</span><span class="o">.</span><span class="n">append</span><span class="p">(</span> <span class="n">value</span> <span class="p">)</span>
        <span class="k">return</span><span class="p">(</span> <span class="n">new</span> <span class="p">)</span>

    <span class="k">def</span> <span class="nf">issubset</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span> <span class="p">):</span>
        <span class="k">for</span> <span class="n">value</span> <span class="ow">in</span> <span class="bp">self</span><span class="p">:</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">value</span> <span class="ow">in</span> <span class="n">other</span><span class="p">:</span>
                <span class="k">return</span><span class="p">(</span> <span class="kc">False</span> <span class="p">)</span>
        <span class="k">return</span><span class="p">(</span> <span class="kc">True</span> <span class="p">)</span>

    <span class="k">def</span> <span class="nf">issuperset</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span> <span class="p">):</span>
        <span class="k">for</span> <span class="n">value</span> <span class="ow">in</span> <span class="n">other</span><span class="p">:</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">value</span> <span class="ow">in</span> <span class="bp">self</span><span class="p">:</span>
                <span class="k">return</span><span class="p">(</span> <span class="kc">False</span> <span class="p">)</span>
        <span class="k">return</span><span class="p">(</span> <span class="kc">True</span> <span class="p">)</span>

    <span class="k">def</span> <span class="nf">symmetric_difference</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span> <span class="p">):</span>
        <span class="n">new</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">difference</span><span class="p">(</span> <span class="n">other</span> <span class="p">)</span>
        <span class="k">for</span> <span class="n">value</span> <span class="ow">in</span> <span class="n">other</span><span class="p">:</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">value</span> <span class="ow">in</span> <span class="bp">self</span><span class="p">:</span>
                <span class="n">new</span><span class="o">.</span><span class="n">append</span><span class="p">(</span> <span class="n">value</span> <span class="p">)</span>
        <span class="k">return</span><span class="p">(</span> <span class="n">new</span> <span class="p">)</span>

    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">_re_sort</span><span class="p">(</span> <span class="n">item</span> <span class="p">):</span>
        <span class="c1">## Exists so that it can be replaced by assignment on specific</span>
        <span class="c1">## instances.</span>
        <span class="k">return</span><span class="p">(</span> <span class="n">item</span> <span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">as_fsets</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&#39;&#39;&#39;set( ) of frozenset( )s of the items in each setList( ) member.  The</span>
<span class="sd">        use of frozenset( )s enables the set( ) to contain otherwise non-</span>
<span class="sd">        hashable objects.  Useful for order-insensitive equality testing.</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="n">ret</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span> <span class="p">)</span>
        <span class="k">for</span> <span class="n">item</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="p">:</span>
            <span class="n">ret</span><span class="o">.</span><span class="n">add</span><span class="p">(</span> <span class="nb">frozenset</span><span class="p">(</span> <span class="bp">self</span><span class="o">.</span><span class="n">_re_sort</span><span class="p">(</span> <span class="n">item</span> <span class="p">)</span> <span class="p">)</span> <span class="p">)</span>
        <span class="k">return</span><span class="p">(</span> <span class="n">ret</span> <span class="p">)</span></div>

<div class="viewcode-block" id="typedDict"><a class="viewcode-back" href="../ParallelRegression.html#ParallelRegression.typedDict">[docs]</a><span class="k">class</span> <span class="nc">typedDict</span><span class="p">(</span><span class="nb">dict</span><span class="p">):</span>
    <span class="sd">&#39;&#39;&#39;dict( ) that is restricted to entries consisting of values of a</span>
<span class="sd">    specified type.</span>

<span class="sd">    typedDict also supports default values whereby new entries are created by</span>
<span class="sd">    deepcopy( )ing an object as opposed to creating a new instance of a class,</span>
<span class="sd">    and supports a write-once mode in which keys that have a value associated</span>
<span class="sd">    with them cannot be changed, but values that are mutable objects may still</span>
<span class="sd">    mutate.</span>

<span class="sd">    Each item has an integer key, and may also have a string key associated</span>
<span class="sd">    with it, but a string key is not required.  I.e., there is a (zero-or-one)-</span>
<span class="sd">    to-one relationship between string keys and dictionary entries, as well as</span>
<span class="sd">    a one-to-one relationship between integer keys and dictionary entries.</span>

<span class="sd">    Integer keys are not preserved when typedDict( ) is copied.</span>
<span class="sd">    &#39;&#39;&#39;</span>

<div class="viewcode-block" id="typedDict.__init__"><a class="viewcode-back" href="../ParallelRegression.html#ParallelRegression.typedDict.__init__">[docs]</a>    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">typeRequirement</span><span class="p">,</span> <span class="n">writeOnce</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">default</span><span class="o">=</span><span class="kc">None</span> <span class="p">):</span>
        <span class="sd">&#39;&#39;&#39;Creates a typedDict( ) instance.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        typeRequirement : type</span>
<span class="sd">            Dictionary entries will only be accepted if they satisfy</span>
<span class="sd">            `isinstance( obj, typeRequirement )`.</span>
<span class="sd">        writeOnce : bool</span>
<span class="sd">            If True, then once a dictionary entry has been created for a key,</span>
<span class="sd">            the dictionary entry cannot be changed.  If the entry consists of a</span>
<span class="sd">            mutable object, the object may still mutate.</span>
<span class="sd">        default : object of type `typeRequirement`, optional</span>
<span class="sd">            If set, then attempting to access a dictionary entry that does not</span>
<span class="sd">            yet exist will result in a deepcopy of this object being used to</span>
<span class="sd">            create an entry for the requested key.</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">typeRequirement</span> <span class="o">=</span> <span class="n">typeRequirement</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">writeOnce</span> <span class="o">=</span> <span class="n">writeOnce</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">strKeys</span> <span class="o">=</span> <span class="n">OrderedDict</span><span class="p">(</span> <span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_intAvail</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">if</span> <span class="n">default</span> <span class="o">!=</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span> <span class="n">default</span><span class="p">,</span> <span class="n">typeRequirement</span> <span class="p">):</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">default</span> <span class="o">=</span> <span class="n">default</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span> <span class="s1">&#39;The default item must be of the required &#39;</span>
                                 <span class="s1">&#39;type.&#39;</span> <span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">pickle</span> <span class="o">=</span> <span class="kc">False</span></div>

    <span class="k">def</span> <span class="nf">__deepcopy__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">memo_dict</span> <span class="p">):</span>
        <span class="k">if</span> <span class="s1">&#39;default&#39;</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">__dir__</span><span class="p">(</span> <span class="p">):</span>
            <span class="n">d</span> <span class="o">=</span> <span class="n">deepcopy</span><span class="p">(</span> <span class="bp">self</span><span class="o">.</span><span class="n">default</span><span class="p">,</span> <span class="n">memo_dict</span> <span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">d</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="n">new</span> <span class="o">=</span> <span class="n">typedDict</span><span class="p">(</span> <span class="bp">self</span><span class="o">.</span><span class="n">typeRequirement</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">writeOnce</span><span class="p">,</span> <span class="n">d</span> <span class="p">)</span>
        <span class="n">new</span><span class="o">.</span><span class="n">union_update</span><span class="p">(</span> <span class="bp">self</span> <span class="p">)</span>
        <span class="k">return</span><span class="p">(</span> <span class="n">new</span> <span class="p">)</span>

    <span class="k">def</span> <span class="nf">__setitem__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">key</span><span class="p">,</span> <span class="n">val</span> <span class="p">):</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="s1">&#39;pickle&#39;</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">__dir__</span><span class="p">(</span> <span class="p">):</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span> <span class="n">key</span><span class="p">,</span> <span class="nb">int</span> <span class="p">):</span>
                <span class="nb">dict</span><span class="o">.</span><span class="n">__setitem__</span><span class="p">(</span> <span class="bp">self</span><span class="p">,</span> <span class="n">key</span><span class="p">,</span> <span class="n">val</span> <span class="p">)</span>
                <span class="k">return</span><span class="p">(</span> <span class="n">key</span> <span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">KeyError</span><span class="p">(</span> <span class="s1">&#39;Only integer keys are supported during &#39;</span>
                                <span class="s1">&#39;unpickling.&#39;</span> <span class="p">)</span>
        <span class="c1">## Translate string keys into integer keys.</span>
        <span class="k">if</span> <span class="n">key</span> <span class="ow">in</span> <span class="bp">self</span><span class="p">:</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">writeOnce</span> <span class="o">==</span> <span class="kc">True</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">KeyError</span><span class="p">(</span> <span class="s1">&#39;This typedDict( ) is write-once.  The key, &#39;</span>
                                <span class="s1">&#39;`</span><span class="si">%s</span><span class="s1">`, has already been set.&#39;</span> <span class="o">%</span> <span class="n">key</span> <span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">intKey</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_int_key</span><span class="p">(</span> <span class="n">key</span> <span class="p">)</span>
        <span class="c1">## For new string keys: find an available integer key.</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span> <span class="n">key</span><span class="p">,</span> <span class="nb">str</span> <span class="p">)</span> <span class="ow">and</span> \
             <span class="nb">isinstance</span><span class="p">(</span> <span class="n">val</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">typeRequirement</span> <span class="p">):</span>
            <span class="k">while</span> <span class="bp">self</span><span class="o">.</span><span class="n">_intAvail</span> <span class="ow">in</span> <span class="bp">self</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_intAvail</span> <span class="o">+=</span> <span class="mi">1</span>
            <span class="n">intKey</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_intAvail</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">strKeys</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="n">intKey</span>
        <span class="c1">## Having ascertained the appropriate integer key, set the item.</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span> <span class="n">key</span><span class="p">,</span> <span class="nb">int</span> <span class="p">):</span>
            <span class="n">intKey</span> <span class="o">=</span> <span class="n">key</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span> <span class="n">val</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">typeRequirement</span> <span class="p">):</span>
            <span class="nb">dict</span><span class="o">.</span><span class="n">__setitem__</span><span class="p">(</span> <span class="bp">self</span><span class="p">,</span> <span class="n">intKey</span><span class="p">,</span> <span class="n">val</span> <span class="p">)</span>
            <span class="k">return</span><span class="p">(</span> <span class="n">intKey</span> <span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span> <span class="s1">&#39;This typedDict( ) has been configured to only &#39;</span>
                           <span class="s1">&#39;accept list items of type </span><span class="si">%s</span><span class="s1">.  Cannot accept a </span><span class="si">%s</span><span class="s1">.&#39;</span>
                           <span class="o">%</span> <span class="p">(</span><span class="nb">str</span><span class="p">(</span> <span class="bp">self</span><span class="o">.</span><span class="n">typeRequirement</span> <span class="p">),</span>
                              <span class="nb">str</span><span class="p">(</span> <span class="nb">type</span><span class="p">(</span> <span class="n">val</span> <span class="p">)</span> <span class="p">))</span> <span class="p">)</span>

    <span class="k">def</span> <span class="nf">__getitem__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">key</span> <span class="p">):</span>
        <span class="n">ik</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_int_key</span><span class="p">(</span> <span class="n">key</span> <span class="p">)</span>
        <span class="k">if</span> <span class="n">ik</span> <span class="o">==</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">return</span><span class="p">(</span> <span class="bp">self</span><span class="o">.</span><span class="n">__missing__</span><span class="p">(</span> <span class="n">key</span> <span class="p">)</span> <span class="p">)</span>
        <span class="k">return</span><span class="p">(</span> <span class="nb">dict</span><span class="o">.</span><span class="n">__getitem__</span><span class="p">(</span> <span class="bp">self</span><span class="p">,</span> <span class="n">ik</span> <span class="p">)</span> <span class="p">)</span>

    <span class="k">def</span> <span class="nf">__contains__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">key</span> <span class="p">):</span>
        <span class="n">key</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_int_key</span><span class="p">(</span> <span class="n">key</span> <span class="p">)</span>
        <span class="k">return</span><span class="p">(</span> <span class="nb">dict</span><span class="o">.</span><span class="n">__contains__</span><span class="p">(</span> <span class="bp">self</span><span class="p">,</span> <span class="n">key</span> <span class="p">)</span> <span class="p">)</span>

    <span class="k">def</span> <span class="nf">__missing__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">key</span> <span class="p">):</span>
        <span class="k">if</span> <span class="s1">&#39;default&#39;</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">__dir__</span><span class="p">(</span> <span class="p">)</span> <span class="ow">and</span> \
           <span class="nb">isinstance</span><span class="p">(</span> <span class="bp">self</span><span class="o">.</span><span class="n">default</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">typeRequirement</span> <span class="p">):</span>
            <span class="n">newObj</span> <span class="o">=</span> <span class="n">deepcopy</span><span class="p">(</span> <span class="bp">self</span><span class="o">.</span><span class="n">default</span> <span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">newObj</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">typeRequirement</span><span class="p">(</span> <span class="p">)</span>
        <span class="n">typedDict</span><span class="o">.</span><span class="n">__setitem__</span><span class="p">(</span> <span class="bp">self</span><span class="p">,</span> <span class="n">key</span><span class="p">,</span> <span class="n">newObj</span> <span class="p">)</span>
        <span class="k">return</span><span class="p">(</span> <span class="bp">self</span><span class="o">.</span><span class="n">__getitem__</span><span class="p">(</span> <span class="n">key</span> <span class="p">)</span> <span class="p">)</span>

<div class="viewcode-block" id="typedDict.itemLength"><a class="viewcode-back" href="../ParallelRegression.html#ParallelRegression.typedDict.itemLength">[docs]</a>    <span class="k">def</span> <span class="nf">itemLength</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">key</span> <span class="p">):</span>
        <span class="sd">&#39;&#39;&#39;Only checks the length of an entry if the entry already exists,</span>
<span class="sd">        otherwise returns 0.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        key : int or string</span>
<span class="sd">            A key for a dictionary entry that need not exist.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        int</span>
<span class="sd">            If there already exists a dictionary entry with the requested key,</span>
<span class="sd">            the length of the entry is returned.  If there is no dictionary</span>
<span class="sd">            entry already existing with the requested key, then 0 will be</span>
<span class="sd">            returned without creating an entry for the key.</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="k">if</span> <span class="n">key</span> <span class="ow">in</span> <span class="bp">self</span><span class="p">:</span>
            <span class="n">key</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_int_key</span><span class="p">(</span> <span class="n">key</span> <span class="p">)</span>
            <span class="k">return</span><span class="p">(</span> <span class="nb">len</span><span class="p">(</span> <span class="bp">self</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="p">)</span> <span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span><span class="p">(</span> <span class="mi">0</span> <span class="p">)</span></div>

    <span class="k">def</span> <span class="nf">__getstate__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">tR</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">typeRequirement</span>
        <span class="n">wO</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">writeOnce</span>
        <span class="n">strK</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">strKeys</span>
        <span class="n">_intA</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_intAvail</span>
        <span class="k">if</span> <span class="s1">&#39;default&#39;</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">__dir__</span><span class="p">(</span> <span class="p">):</span>
            <span class="n">d</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">default</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">d</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="n">dataDict</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">items</span><span class="p">(</span> <span class="p">):</span>
            <span class="n">dataDict</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">=</span> <span class="n">v</span>
        <span class="n">attrDict</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span> <span class="p">)</span>
        <span class="k">for</span> <span class="n">key</span><span class="p">,</span> <span class="n">value</span> <span class="ow">in</span> <span class="nb">vars</span><span class="p">(</span> <span class="bp">self</span> <span class="p">)</span><span class="o">.</span><span class="n">items</span><span class="p">(</span> <span class="p">):</span>
            <span class="k">if</span> <span class="n">key</span><span class="o">.</span><span class="n">startswith</span><span class="p">(</span> <span class="s1">&#39;_s_&#39;</span> <span class="p">):</span>
                <span class="n">attrDict</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="n">value</span>
        <span class="n">tple</span> <span class="o">=</span> <span class="p">(</span><span class="n">tR</span><span class="p">,</span> <span class="n">wO</span><span class="p">,</span> <span class="n">strK</span><span class="p">,</span> <span class="n">_intA</span><span class="p">,</span> <span class="n">d</span><span class="p">,</span> <span class="n">dataDict</span><span class="p">,</span> <span class="n">attrDict</span><span class="p">)</span>
        <span class="k">return</span><span class="p">(</span> <span class="n">tple</span> <span class="p">)</span>

    <span class="k">def</span> <span class="nf">__setstate__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">state</span> <span class="p">):</span>
        <span class="n">tR</span><span class="p">,</span> <span class="n">wO</span><span class="p">,</span> <span class="n">strK</span><span class="p">,</span> <span class="n">_intA</span><span class="p">,</span> <span class="n">d</span><span class="p">,</span> <span class="n">dataDict</span><span class="p">,</span> <span class="n">attrDict</span> <span class="o">=</span> <span class="n">state</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">typeRequirement</span> <span class="o">=</span> <span class="n">tR</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">writeOnce</span> <span class="o">=</span> <span class="n">wO</span>
        <span class="k">if</span> <span class="n">d</span> <span class="o">!=</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">default</span> <span class="o">=</span> <span class="n">d</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_intAvail</span> <span class="o">=</span> <span class="n">_intA</span>
        <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">dataDict</span><span class="o">.</span><span class="n">items</span><span class="p">(</span> <span class="p">):</span>
            <span class="bp">self</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">=</span> <span class="n">v</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">strKeys</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span> <span class="p">)</span>
        <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">strK</span><span class="o">.</span><span class="n">items</span><span class="p">(</span> <span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">strKeys</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">=</span> <span class="n">v</span>
        <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">attrDict</span><span class="o">.</span><span class="n">items</span><span class="p">(</span> <span class="p">):</span>
            <span class="k">if</span> <span class="n">k</span><span class="o">.</span><span class="n">startswith</span><span class="p">(</span> <span class="s1">&#39;_s_&#39;</span> <span class="p">):</span>
                <span class="nb">setattr</span><span class="p">(</span> <span class="bp">self</span><span class="p">,</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span> <span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">pickle</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="k">return</span><span class="p">(</span> <span class="p">)</span>

    <span class="k">def</span> <span class="nf">_int_key</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">key</span> <span class="p">):</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span> <span class="n">key</span><span class="p">,</span> <span class="nb">int</span> <span class="p">):</span>
            <span class="k">return</span><span class="p">(</span> <span class="n">key</span> <span class="p">)</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span> <span class="n">key</span><span class="p">,</span> <span class="nb">str</span> <span class="p">):</span>
            <span class="k">if</span> <span class="n">key</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">strKeys</span><span class="p">:</span>
                <span class="k">return</span><span class="p">(</span> <span class="bp">self</span><span class="o">.</span><span class="n">strKeys</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">KeyError</span><span class="p">(</span> <span class="s1">&#39;typedDict( ) only supports string keys and their &#39;</span>
                            <span class="s1">&#39;integer indexes.&#39;</span> <span class="p">)</span>

<div class="viewcode-block" id="typedDict.keys"><a class="viewcode-back" href="../ParallelRegression.html#ParallelRegression.typedDict.keys">[docs]</a>    <span class="k">def</span> <span class="nf">keys</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">key_type</span><span class="o">=</span><span class="kc">None</span> <span class="p">):</span>
        <span class="sd">&#39;&#39;&#39;Returns a setList( ) of keys for which there currently exists an</span>
<span class="sd">        entry.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        key_type : {None, &#39;integer&#39;, &#39;string&#39;, &#39;union&#39;}, optional</span>
<span class="sd">            The type of keys to return.  If `key_type==None` and at least one</span>
<span class="sd">            entry has a string key, then only string keys will be returned.</span>
<span class="sd">            Otherwise if `key_type==None`, integer keys will be returned.  If</span>
<span class="sd">            `key_type==&#39;union&#39;`, then a setList( ) consisting of both integer</span>
<span class="sd">            and string keys will be returned.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        setList( )</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="k">if</span> <span class="n">key_type</span> <span class="o">==</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span> <span class="bp">self</span><span class="o">.</span><span class="n">strKeys</span><span class="o">.</span><span class="n">keys</span><span class="p">(</span> <span class="p">)</span> <span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">key_type</span> <span class="o">=</span> <span class="s1">&#39;integer&#39;</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">key_type</span> <span class="o">=</span> <span class="s1">&#39;string&#39;</span>
        <span class="k">if</span> <span class="n">key_type</span> <span class="o">==</span> <span class="s1">&#39;string&#39;</span><span class="p">:</span>
            <span class="k">return</span><span class="p">(</span> <span class="n">setList</span><span class="p">(</span> <span class="bp">self</span><span class="o">.</span><span class="n">strKeys</span><span class="o">.</span><span class="n">keys</span><span class="p">(</span> <span class="p">)</span> <span class="p">)</span> <span class="p">)</span>
        <span class="k">elif</span> <span class="n">key_type</span> <span class="o">==</span> <span class="s1">&#39;integer&#39;</span><span class="p">:</span>
            <span class="k">return</span><span class="p">(</span> <span class="n">setList</span><span class="p">(</span> <span class="nb">dict</span><span class="o">.</span><span class="n">keys</span><span class="p">(</span> <span class="bp">self</span> <span class="p">)</span> <span class="p">)</span> <span class="p">)</span>
        <span class="k">elif</span> <span class="n">key_type</span> <span class="o">==</span> <span class="s1">&#39;union&#39;</span><span class="p">:</span>
            <span class="k">return</span><span class="p">(</span> <span class="n">setList</span><span class="p">(</span> <span class="bp">self</span><span class="o">.</span><span class="n">strKeys</span><span class="o">.</span><span class="n">keys</span><span class="p">(</span> <span class="p">)</span>
                            <span class="p">)</span><span class="o">.</span><span class="n">union</span><span class="p">(</span> <span class="nb">dict</span><span class="o">.</span><span class="n">keys</span><span class="p">(</span> <span class="bp">self</span> <span class="p">)</span> <span class="p">)</span> <span class="p">)</span></div>

<div class="viewcode-block" id="typedDict.pop"><a class="viewcode-back" href="../ParallelRegression.html#ParallelRegression.typedDict.pop">[docs]</a>    <span class="k">def</span> <span class="nf">pop</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">key</span> <span class="p">):</span>
        <span class="sd">&#39;&#39;&#39;Returns and removes the entry associated with the specified key.</span>
<span class="sd">        Accepts both integer and string keys.</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="n">ik</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_int_key</span><span class="p">(</span> <span class="n">key</span> <span class="p">)</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span> <span class="n">key</span><span class="p">,</span> <span class="nb">str</span> <span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">strKeys</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span> <span class="n">key</span> <span class="p">)</span>
        <span class="k">return</span><span class="p">(</span> <span class="nb">dict</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span> <span class="bp">self</span><span class="p">,</span> <span class="n">ik</span> <span class="p">)</span> <span class="p">)</span></div>

<div class="viewcode-block" id="typedDict.update"><a class="viewcode-back" href="../ParallelRegression.html#ParallelRegression.typedDict.update">[docs]</a>    <span class="k">def</span> <span class="nf">update</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span> <span class="p">):</span>
        <span class="sd">&#39;&#39;&#39;Copies entries in `other` into this typedDict( ), replacing existing</span>
<span class="sd">        entries that use the same key.</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="k">for</span> <span class="n">key</span> <span class="ow">in</span> <span class="n">other</span><span class="o">.</span><span class="n">keys</span><span class="p">(</span> <span class="p">):</span>
            <span class="n">n</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">__setitem__</span><span class="p">(</span> <span class="n">key</span><span class="p">,</span> <span class="n">other</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="p">)</span></div>

<div class="viewcode-block" id="typedDict.union_update"><a class="viewcode-back" href="../ParallelRegression.html#ParallelRegression.typedDict.union_update">[docs]</a>    <span class="k">def</span> <span class="nf">union_update</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span> <span class="p">):</span>
        <span class="sd">&#39;&#39;&#39;Similar to dict( ).update( other ) except that for keys with which</span>
<span class="sd">        an entry is associated in both this typedDict( ) and `other`, the new</span>
<span class="sd">        entry will be this typedDict[key].union( other[key] ).</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="n">sk</span> <span class="o">=</span> <span class="n">setList</span><span class="p">(</span> <span class="bp">self</span><span class="o">.</span><span class="n">strKeys</span><span class="o">.</span><span class="n">keys</span><span class="p">(</span> <span class="p">)</span> <span class="p">)</span>
        <span class="n">ok</span> <span class="o">=</span> <span class="n">setList</span><span class="p">(</span> <span class="n">other</span><span class="o">.</span><span class="n">keys</span><span class="p">(</span> <span class="p">)</span> <span class="p">)</span>
        <span class="k">for</span> <span class="n">key</span> <span class="ow">in</span> <span class="n">sk</span><span class="o">.</span><span class="n">union</span><span class="p">(</span> <span class="n">ok</span> <span class="p">):</span>
            <span class="bp">self</span><span class="p">[</span><span class="n">key</span><span class="p">]</span><span class="o">.</span><span class="n">update</span><span class="p">(</span> <span class="n">other</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="p">)</span>
        <span class="k">for</span> <span class="n">key</span> <span class="ow">in</span> <span class="n">ok</span><span class="o">.</span><span class="n">difference</span><span class="p">(</span> <span class="n">sk</span> <span class="p">):</span>
            <span class="bp">self</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="n">deepcopy</span><span class="p">(</span> <span class="n">other</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="p">)</span></div></div>

<div class="viewcode-block" id="categorizedSetDict"><a class="viewcode-back" href="../ParallelRegression.html#ParallelRegression.categorizedSetDict">[docs]</a><span class="k">class</span> <span class="nc">categorizedSetDict</span><span class="p">(</span><span class="n">typedDict</span><span class="p">):</span>
    <span class="sd">&#39;&#39;&#39;Ordered sets stored in a dict( ) in which each set and each set member</span>
<span class="sd">    potentially belongs to one or more category.</span>

<span class="sd">    Sets and set members can be retrieved by category.  Categories designated</span>
<span class="sd">    as mutually exclusive restrict category membership to sets and set members</span>
<span class="sd">    without conflicting categories.</span>

<span class="sd">    Attributes</span>
<span class="sd">    ----------</span>
<span class="sd">    mutually_exclusive : set</span>
<span class="sd">        set( ) of frozenset( )s of categories, where each category in a</span>
<span class="sd">        frozenset( ) and all other categories in the same frozenset( ) are are</span>
<span class="sd">        considered mutually exclusive.</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    Categories are assumed to be identified by strings, so the code is only</span>
<span class="sd">    tested using string-identified categories.  However, this is not strictly</span>
<span class="sd">    enforced.</span>
<span class="sd">    &#39;&#39;&#39;</span>
    <span class="k">def</span> <span class="nf">__new__</span><span class="p">(</span> <span class="n">cls</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span> <span class="p">):</span>
        <span class="n">obj</span> <span class="o">=</span> <span class="nb">super</span><span class="p">(</span> <span class="n">categorizedSetDict</span><span class="p">,</span> <span class="n">cls</span> <span class="p">)</span><span class="o">.</span><span class="n">__new__</span><span class="p">(</span> <span class="n">cls</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span> <span class="p">)</span>
        <span class="n">obj</span><span class="o">.</span><span class="n">_s_ctg_keys</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span> <span class="p">)</span>
        <span class="n">obj</span><span class="o">.</span><span class="n">_s_ctg_values</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span> <span class="p">)</span>
        <span class="n">obj</span><span class="o">.</span><span class="n">mutually_exclusive</span> <span class="o">=</span> <span class="n">setList</span><span class="p">(</span> <span class="p">)</span>
        <span class="n">typedDict</span><span class="o">.</span><span class="n">__init__</span><span class="p">(</span> <span class="n">obj</span><span class="p">,</span> <span class="n">setList</span> <span class="p">)</span>
        <span class="k">return</span><span class="p">(</span> <span class="n">obj</span> <span class="p">)</span>

<div class="viewcode-block" id="categorizedSetDict.__init__"><a class="viewcode-back" href="../ParallelRegression.html#ParallelRegression.categorizedSetDict.__init__">[docs]</a>    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">singular_category</span><span class="o">=</span><span class="kc">None</span> <span class="p">):</span>
        <span class="sd">&#39;&#39;&#39;Creates a categorizedSetDict( ) instance.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        singular_category : string, optional</span>
<span class="sd">            When a set is instantiated with a single item (as opposed to a</span>
<span class="sd">            sequence of one member), this category is assigned to the set.</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">singular_category</span> <span class="o">=</span> <span class="n">singular_category</span></div>

<div class="viewcode-block" id="categorizedSetDict.__setitem__"><a class="viewcode-back" href="../ParallelRegression.html#ParallelRegression.categorizedSetDict.__setitem__">[docs]</a>    <span class="k">def</span> <span class="nf">__setitem__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">key</span><span class="p">,</span> <span class="n">value</span> <span class="p">):</span>
        <span class="sd">&#39;&#39;&#39;Sets dict( ) entries.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        key : str</span>
<span class="sd">            String identifying a set.</span>
<span class="sd">        value : str or tuple (list-like : set members[, list-like : set member</span>
<span class="sd">        categories][, set : whole-set categories )</span>
<span class="sd">            list( ), set( ), or setList( ) of set members associated with the</span>
<span class="sd">            key, alone or combined with categories that apply to individual set</span>
<span class="sd">            members and/or categories that apply to the whole set.</span>

<span class="sd">        Raises</span>
<span class="sd">        ------</span>
<span class="sd">        CategoryError</span>
<span class="sd">            If an attempt is made to associate a set or set member with a</span>
<span class="sd">            category that is already associated with a mutually-exclusive</span>
<span class="sd">            category.  In this scenario, the entire .__setitem__( ) operation</span>
<span class="sd">            will fail and the categorizedSetDict( ) will not be altered.</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        &gt;&gt;&gt; c = categorizedSetDict( )</span>
<span class="sd">        &gt;&gt;&gt; c[&#39;vocab&#39;] = [&#39;apple&#39;, &#39;bee&#39;, &#39;cabin&#39;]</span>
<span class="sd">        &gt;&gt;&gt; c[&#39;vocab&#39;]</span>
<span class="sd">        [&#39;apple&#39;, &#39;bee&#39;, &#39;cabin&#39;]</span>
<span class="sd">        &gt;&gt;&gt; c.get_categories( key=&#39;vocab&#39;, value=&#39;apple&#39; )</span>
<span class="sd">        {None}</span>

<span class="sd">        &gt;&gt;&gt; c[&#39;vocab&#39;] = ([&#39;apple&#39;, &#39;bee&#39;, &#39;cabin&#39;],</span>
<span class="sd">        &gt;&gt;&gt;               {&#39;words&#39;})</span>
<span class="sd">        &gt;&gt;&gt; c.get_categories( key=&#39;vocab&#39;, value=&#39;apple&#39; )</span>
<span class="sd">        {&#39;words&#39;}</span>

<span class="sd">        &gt;&gt;&gt; c[&#39;vocab&#39;] = ([&#39;apple&#39;, &#39;bee&#39;, &#39;cabin&#39;],</span>
<span class="sd">        &gt;&gt;&gt;               [{&#39;food&#39;}, {&#39;animal&#39;}, {&#39;building&#39;}])</span>
<span class="sd">        &gt;&gt;&gt; c.get_categories( key=&#39;vocab&#39;, value=&#39;apple&#39; )</span>
<span class="sd">        {&#39;food&#39;}</span>

<span class="sd">        &gt;&gt;&gt; c[&#39;vocab&#39;] = ([&#39;apple&#39;, &#39;bee&#39;, &#39;cabin&#39;],</span>
<span class="sd">        &gt;&gt;&gt;               [{&#39;food&#39;}, {&#39;animal&#39;}, {&#39;building&#39;}],</span>
<span class="sd">        &gt;&gt;&gt;               {&#39;words&#39;})</span>
<span class="sd">        &gt;&gt;&gt; c.get_categories( key=&#39;vocab&#39;, value=&#39;apple&#39; )</span>
<span class="sd">        {&#39;food&#39;, &#39;words&#39;}</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="k">if</span> <span class="n">value</span> <span class="o">==</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">key</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">keys</span><span class="p">(</span> <span class="p">):</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">__delitem__</span><span class="p">(</span> <span class="n">key</span> <span class="p">)</span>
            <span class="k">return</span><span class="p">(</span> <span class="p">)</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span> <span class="n">value</span><span class="p">,</span> <span class="p">(</span><span class="nb">list</span><span class="p">,</span> <span class="nb">set</span><span class="p">)</span> <span class="p">):</span>
            <span class="n">value</span> <span class="o">=</span> <span class="n">setList</span><span class="p">(</span> <span class="n">value</span> <span class="p">)</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span> <span class="n">value</span><span class="p">,</span> <span class="nb">str</span> <span class="p">):</span>
            <span class="n">value</span> <span class="o">=</span> <span class="p">(</span><span class="n">setList</span><span class="p">(</span> <span class="p">[</span><span class="n">value</span><span class="p">]</span> <span class="p">),</span> <span class="p">[],</span> <span class="p">{</span><span class="bp">self</span><span class="o">.</span><span class="n">singular_category</span><span class="p">})</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span> <span class="n">value</span><span class="p">,</span> <span class="n">setList</span> <span class="p">):</span>
            <span class="n">value</span> <span class="o">=</span> <span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="p">[],</span> <span class="p">{</span><span class="kc">None</span><span class="p">,})</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span> <span class="n">value</span><span class="p">,</span> <span class="p">(</span><span class="nb">tuple</span><span class="p">,</span> <span class="nb">list</span><span class="p">)</span> <span class="p">)</span> <span class="ow">and</span> <span class="nb">len</span><span class="p">(</span> <span class="n">value</span> <span class="p">)</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span> <span class="n">value</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">setList</span> <span class="p">):</span>
                <span class="n">value</span> <span class="o">=</span> <span class="p">(</span><span class="n">setList</span><span class="p">(</span> <span class="n">value</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="p">),</span> <span class="n">value</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span> <span class="n">value</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="nb">list</span> <span class="p">):</span>
                <span class="n">value</span> <span class="o">=</span> <span class="p">(</span><span class="n">value</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">value</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="nb">set</span><span class="p">(</span> <span class="p">))</span>
            <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span> <span class="n">value</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="nb">set</span> <span class="p">):</span>
                <span class="n">value</span> <span class="o">=</span> <span class="p">(</span><span class="n">value</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="p">[],</span> <span class="n">value</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span> <span class="n">value</span><span class="p">,</span> <span class="nb">tuple</span> <span class="p">)</span> <span class="ow">and</span> <span class="nb">len</span><span class="p">(</span> <span class="n">value</span> <span class="p">)</span> <span class="o">==</span> <span class="mi">3</span><span class="p">:</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span> <span class="n">value</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="nb">list</span> <span class="p">):</span>
                <span class="n">value</span> <span class="o">=</span> <span class="p">(</span><span class="n">setList</span><span class="p">(</span> <span class="n">value</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="p">),</span> <span class="n">value</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">value</span><span class="p">[</span><span class="mi">2</span><span class="p">])</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span> <span class="n">value</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">setList</span> <span class="p">)</span> <span class="ow">and</span> \
               <span class="nb">isinstance</span><span class="p">(</span> <span class="n">value</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="nb">list</span> <span class="p">)</span> <span class="ow">and</span> \
               <span class="nb">isinstance</span><span class="p">(</span> <span class="n">value</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span> <span class="nb">set</span> <span class="p">):</span>
                <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span> <span class="n">value</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="nb">list</span> <span class="p">)</span> <span class="ow">and</span> \
                   <span class="nb">len</span><span class="p">(</span> <span class="n">value</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="p">)</span> <span class="o">&gt;</span> <span class="nb">len</span><span class="p">(</span> <span class="n">value</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="p">):</span>
                    <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span> <span class="s1">&#39;Categories list has a length of </span><span class="si">%d</span><span class="s1">.  &#39;</span>
                          <span class="s1">&#39;It cannot be longer than the items list, which has &#39;</span>
                          <span class="s1">&#39;a length of </span><span class="si">%d</span><span class="s1">.&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="nb">len</span><span class="p">(</span> <span class="n">values</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="p">),</span>
                                               <span class="nb">len</span><span class="p">(</span> <span class="n">values</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="p">))</span> <span class="p">)</span>
                <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span> <span class="nb">len</span><span class="p">(</span> <span class="n">value</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="p">)</span> <span class="p">):</span>
                    <span class="k">if</span> <span class="n">value</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="n">i</span><span class="p">]</span> <span class="o">==</span> <span class="kc">None</span><span class="p">:</span>
                        <span class="n">value</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span> <span class="p">)</span>
                    <span class="k">elif</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span> <span class="n">value</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="n">i</span><span class="p">],</span> <span class="p">(</span><span class="nb">set</span><span class="p">,</span> <span class="n">setList</span><span class="p">)</span> <span class="p">):</span>
                        <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span> <span class="s1">&#39;Items in the value category sequence&#39;</span>
                              <span class="s1">&#39; must be sets, not </span><span class="si">%s</span><span class="s1">.&#39;</span> <span class="o">%</span> <span class="nb">type</span><span class="p">(</span> <span class="n">value</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="n">i</span><span class="p">]</span> <span class="p">)</span> <span class="p">)</span>
                <span class="n">B_itm</span> <span class="o">=</span> <span class="n">deepcopy</span><span class="p">(</span> <span class="bp">self</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="p">)</span>
                <span class="k">if</span> <span class="n">key</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_s_ctg_keys</span><span class="p">:</span>
                    <span class="n">B_key</span> <span class="o">=</span> <span class="n">deepcopy</span><span class="p">(</span> <span class="bp">self</span><span class="o">.</span><span class="n">_s_ctg_keys</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">B_key</span> <span class="o">=</span> <span class="kc">None</span>
                <span class="k">if</span> <span class="n">key</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_s_ctg_values</span><span class="p">:</span>
                    <span class="n">B_val</span> <span class="o">=</span> <span class="n">deepcopy</span><span class="p">(</span> <span class="bp">self</span><span class="o">.</span><span class="n">_s_ctg_values</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">B_val</span> <span class="o">=</span> <span class="kc">None</span>
                <span class="k">try</span><span class="p">:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">__missing__</span><span class="p">(</span> <span class="n">key</span> <span class="p">)</span>
                    <span class="n">typedDict</span><span class="o">.</span><span class="n">__setitem__</span><span class="p">(</span> <span class="bp">self</span><span class="p">,</span> <span class="n">key</span><span class="p">,</span> <span class="n">value</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="p">)</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">set_categories</span><span class="p">(</span> <span class="o">*</span><span class="n">value</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span> <span class="n">key</span><span class="o">=</span><span class="n">key</span> <span class="p">)</span>
                    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span> <span class="nb">len</span><span class="p">(</span> <span class="n">value</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="p">)</span> <span class="p">):</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">set_categories</span><span class="p">(</span> <span class="o">*</span><span class="n">value</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="n">i</span><span class="p">],</span>
                                             <span class="n">key</span><span class="o">=</span><span class="n">key</span><span class="p">,</span>
                                             <span class="n">value</span><span class="o">=</span><span class="n">value</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="n">i</span><span class="p">]</span> <span class="p">)</span>
                <span class="k">except</span> <span class="n">CategoryError</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
                    <span class="n">typedDict</span><span class="o">.</span><span class="n">__setitem__</span><span class="p">(</span> <span class="bp">self</span><span class="p">,</span> <span class="n">key</span><span class="p">,</span> <span class="n">B_itm</span> <span class="p">)</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">_s_ctg_keys</span><span class="p">[</span><span class="n">key</span><span class="p">]</span>   <span class="o">=</span> <span class="n">B_key</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">_s_ctg_values</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="n">B_val</span>
                    <span class="k">raise</span> <span class="n">e</span>
                <span class="k">return</span><span class="p">(</span> <span class="p">)</span>
        <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span> <span class="s1">&#39;Value is not a supported type.  &#39;</span>
                         <span class="s1">&#39;Type: </span><span class="si">%s</span><span class="s1">, length: </span><span class="si">%d</span><span class="s1">.&#39;</span>
                         <span class="o">%</span> <span class="p">(</span><span class="nb">type</span><span class="p">(</span> <span class="n">value</span> <span class="p">),</span> <span class="nb">getattr</span><span class="p">(</span> <span class="n">value</span><span class="p">,</span> <span class="s1">&#39;__len__&#39;</span><span class="p">,</span> <span class="mi">0</span> <span class="p">))</span> <span class="p">)</span></div>

<div class="viewcode-block" id="categorizedSetDict.get_categories"><a class="viewcode-back" href="../ParallelRegression.html#ParallelRegression.categorizedSetDict.get_categories">[docs]</a>    <span class="k">def</span> <span class="nf">get_categories</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">key</span><span class="p">,</span> <span class="n">value</span><span class="o">=</span><span class="kc">None</span> <span class="p">):</span>
        <span class="sd">&#39;&#39;&#39;Returns the set of categories associated with the whole set or a</span>
<span class="sd">        particular member thereof.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        key : str</span>
<span class="sd">            The key associated with the set about which the inquiry is being</span>
<span class="sd">            made.</span>
<span class="sd">        value, optional</span>
<span class="sd">            If specified, the categories specifically associated with the</span>
<span class="sd">            specified set member are returned along with the categories</span>
<span class="sd">            associated with the whole set.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        categories : set</span>
<span class="sd">            The set of all categories associated with the specified key or with</span>
<span class="sd">            the specified key/value pair.  If there is a set identified by the</span>
<span class="sd">            key `key`, then the set of categories associated with it will be</span>
<span class="sd">            returned regardless of whether or not `value` is in the set `key`.</span>
<span class="sd">        None</span>
<span class="sd">            If there is no entry with `key`&#39;s value as its key.</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="k">if</span> <span class="n">key</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="p">:</span>
            <span class="k">return</span><span class="p">(</span> <span class="kc">None</span> <span class="p">)</span>
        <span class="k">if</span> <span class="n">value</span> <span class="o">==</span> <span class="kc">None</span> <span class="ow">or</span> <span class="n">value</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="ow">or</span> \
           <span class="bp">self</span><span class="p">[</span><span class="n">key</span><span class="p">]</span><span class="o">.</span><span class="n">index</span><span class="p">(</span> <span class="n">value</span> <span class="p">)</span> <span class="o">&gt;=</span> <span class="nb">len</span><span class="p">(</span> <span class="bp">self</span><span class="o">.</span><span class="n">_s_ctg_values</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="p">):</span>
            <span class="k">return</span><span class="p">(</span> <span class="bp">self</span><span class="o">.</span><span class="n">_s_ctg_keys</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span><span class="p">(</span> <span class="bp">self</span><span class="o">.</span><span class="n">_s_ctg_keys</span><span class="p">[</span><span class="n">key</span><span class="p">]</span><span class="o">.</span><span class="n">union</span><span class="p">(</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_s_ctg_values</span><span class="p">[</span><span class="n">key</span><span class="p">][</span><span class="bp">self</span><span class="p">[</span><span class="n">key</span><span class="p">]</span><span class="o">.</span><span class="n">index</span><span class="p">(</span> <span class="n">value</span> <span class="p">)]</span> <span class="p">)</span> <span class="p">)</span></div>

<div class="viewcode-block" id="categorizedSetDict.is_a"><a class="viewcode-back" href="../ParallelRegression.html#ParallelRegression.categorizedSetDict.is_a">[docs]</a>    <span class="k">def</span> <span class="nf">is_a</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">category</span><span class="p">,</span> <span class="n">key</span><span class="p">,</span> <span class="n">value</span><span class="o">=</span><span class="kc">None</span> <span class="p">):</span>
        <span class="sd">&#39;&#39;&#39;Returns True if the specified key or key/value pair is associated</span>
<span class="sd">        with `category`, or False otherwise, so long as there is an entry with</span>
<span class="sd">        `key`&#39;s value as its key.  If not, None is returned.  The set</span>
<span class="sd">        identified by `key` need not contain `value`.</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="n">categories</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_categories</span><span class="p">(</span> <span class="n">key</span><span class="p">,</span> <span class="n">value</span> <span class="p">)</span>
        <span class="k">if</span> <span class="n">categories</span> <span class="o">==</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">return</span><span class="p">(</span> <span class="kc">None</span> <span class="p">)</span>
        <span class="k">return</span><span class="p">(</span> <span class="n">category</span> <span class="ow">in</span> <span class="n">categories</span> <span class="p">)</span></div>

<div class="viewcode-block" id="categorizedSetDict.is_None"><a class="viewcode-back" href="../ParallelRegression.html#ParallelRegression.categorizedSetDict.is_None">[docs]</a>    <span class="k">def</span> <span class="nf">is_None</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">key</span><span class="p">,</span> <span class="n">value</span><span class="o">=</span><span class="kc">None</span> <span class="p">):</span>
        <span class="sd">&#39;&#39;&#39;Returns True if the specified key or key/value pair is not</span>
<span class="sd">        associated with any category, or False otherwise.  See .is_a( ) for</span>
<span class="sd">        handling of non-existant values.</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="n">categories</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_categories</span><span class="p">(</span> <span class="n">key</span><span class="o">=</span><span class="n">key</span><span class="p">,</span> <span class="n">value</span><span class="o">=</span><span class="n">value</span> <span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">categories</span> <span class="o">==</span> <span class="nb">set</span><span class="p">(</span> <span class="p">)</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">categories</span> <span class="o">==</span> <span class="nb">set</span><span class="p">(</span> <span class="p">[</span><span class="kc">None</span><span class="p">]</span> <span class="p">):</span>
            <span class="k">return</span><span class="p">(</span> <span class="kc">False</span> <span class="p">)</span>
        <span class="k">return</span><span class="p">(</span> <span class="kc">True</span> <span class="p">)</span></div>

<div class="viewcode-block" id="categorizedSetDict.set_category"><a class="viewcode-back" href="../ParallelRegression.html#ParallelRegression.categorizedSetDict.set_category">[docs]</a>    <span class="k">def</span> <span class="nf">set_category</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">category</span><span class="p">,</span> <span class="o">*</span><span class="p">,</span> <span class="n">key</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">value</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                                        <span class="n">keys</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                                        <span class="n">items</span><span class="o">=</span><span class="kc">None</span> <span class="p">):</span>
        <span class="sd">&#39;&#39;&#39;Associates key(s) and/or key/value pairs with the specified</span>
<span class="sd">        category.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        category : string</span>
<span class="sd">            The category to associate with the key(s) and/or key/value pairs.</span>
<span class="sd">        key : str, optional</span>
<span class="sd">            If key but not value is specified, then this key will be associated</span>
<span class="sd">            with the specified category.</span>
<span class="sd">        value, optional</span>
<span class="sd">            If key and value are both specified, then this key/value pair will</span>
<span class="sd">            be associated with the specified category.</span>
<span class="sd">        keys : Sequence</span>
<span class="sd">            The keys in this sequence will be associated with the specified</span>
<span class="sd">            category.</span>
<span class="sd">        items : dict</span>
<span class="sd">            The key/value pairs in this dict( ) will be associated with the</span>
<span class="sd">            specified category.  Each value in this dict( ) can be either a</span>
<span class="sd">            single set member or a sequence of set members to associate with</span>
<span class="sd">            the specified category.</span>

<span class="sd">        Raises</span>
<span class="sd">        ------</span>
<span class="sd">        CategoryError</span>
<span class="sd">            If the category specified and one or more categories already</span>
<span class="sd">            associated with one or more of the specified key(s) or key/value</span>
<span class="sd">            pairs are considered mutually exclusive.</span>
<span class="sd">        KeyError</span>
<span class="sd">            If a specified key/value pair does not identify an existing set</span>
<span class="sd">            member.  Note that assigning a category to a key for which there is</span>
<span class="sd">            no pre-existing entry results in the creation of a default entry</span>
<span class="sd">            instead of of a KeyError.</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="k">def</span> <span class="nf">set_key</span><span class="p">(</span> <span class="n">key</span><span class="p">,</span> <span class="n">category</span> <span class="p">):</span>
            <span class="k">if</span> <span class="n">key</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">keys</span><span class="p">(</span> <span class="p">):</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">__missing__</span><span class="p">(</span> <span class="n">key</span> <span class="p">)</span>
            <span class="k">for</span> <span class="n">ctgset</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">mutually_exclusive</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">category</span> <span class="ow">in</span> <span class="n">ctgset</span><span class="p">:</span>
                    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span> <span class="n">ctgset</span><span class="o">.</span><span class="n">intersection</span><span class="p">(</span> <span class="bp">self</span><span class="o">.</span><span class="n">_s_ctg_keys</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="p">)</span>\
                                  <span class="o">.</span><span class="n">difference</span><span class="p">(</span> <span class="nb">set</span><span class="p">(</span> <span class="p">[</span><span class="n">category</span><span class="p">]</span> <span class="p">)</span> <span class="p">)</span> <span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                        <span class="k">raise</span> <span class="n">CategoryError</span><span class="p">(</span> <span class="s2">&quot;Cannot add category &#39;</span><span class="si">%s</span><span class="s2">&#39; to &quot;</span>
                              <span class="s2">&quot;[&#39;</span><span class="si">%s</span><span class="s2">&#39;] because it already has a mutually &quot;</span>
                              <span class="s2">&quot;exclusive category.&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="n">category</span><span class="p">,</span> <span class="n">key</span><span class="p">)</span> <span class="p">)</span>
                    <span class="k">for</span> <span class="n">val</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_s_ctg_values</span><span class="p">[</span><span class="n">key</span><span class="p">]:</span>
                        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span> <span class="n">ctgset</span><span class="o">.</span><span class="n">intersection</span><span class="p">(</span> <span class="n">val</span> <span class="p">)</span>\
                                      <span class="o">.</span><span class="n">difference</span><span class="p">(</span> <span class="nb">set</span><span class="p">(</span> <span class="p">[</span><span class="n">category</span><span class="p">]</span> <span class="p">)</span> <span class="p">)</span> <span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                            <span class="k">raise</span> <span class="n">CategoryError</span><span class="p">(</span> <span class="s2">&quot;Cannot add category &#39;</span><span class="si">%s</span><span class="s2">&#39; to &quot;</span>
                                  <span class="s2">&quot;[&#39;</span><span class="si">%s</span><span class="s2">&#39;] because one or more values already &quot;</span>
                                  <span class="s2">&quot;has a mutually exclusive category.&quot;</span>
                                  <span class="o">%</span> <span class="p">(</span><span class="n">category</span><span class="p">,</span> <span class="n">key</span><span class="p">),</span> <span class="n">ctgset</span> <span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_s_ctg_keys</span><span class="p">[</span><span class="n">key</span><span class="p">]</span><span class="o">.</span><span class="n">add</span><span class="p">(</span> <span class="n">category</span> <span class="p">)</span>
        <span class="k">def</span> <span class="nf">set_val</span><span class="p">(</span> <span class="n">key</span><span class="p">,</span> <span class="n">val</span><span class="p">,</span> <span class="n">category</span> <span class="p">):</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="n">index</span> <span class="o">=</span> <span class="n">typedDict</span><span class="o">.</span><span class="n">__getitem__</span><span class="p">(</span> <span class="bp">self</span><span class="p">,</span> <span class="n">key</span> <span class="p">)</span><span class="o">.</span><span class="n">index</span><span class="p">(</span> <span class="n">val</span> <span class="p">)</span>
            <span class="k">except</span> <span class="ne">ValueError</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">KeyError</span><span class="p">(</span> <span class="s2">&quot;Set identified by key &#39;</span><span class="si">%s</span><span class="s2">&#39; has no value &#39;</span><span class="si">%s</span><span class="s2">&#39;.&quot;</span>
                      <span class="s2">&quot;  It has: </span><span class="si">%s</span><span class="s2">.&quot;</span>
                      <span class="o">%</span> <span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="n">val</span><span class="p">,</span> <span class="n">typedDict</span><span class="o">.</span><span class="n">__getitem__</span><span class="p">(</span> <span class="bp">self</span><span class="p">,</span> <span class="n">key</span> <span class="p">))</span> <span class="p">)</span>
            <span class="k">while</span> <span class="nb">len</span><span class="p">(</span> <span class="bp">self</span><span class="o">.</span><span class="n">_s_ctg_values</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="p">)</span> <span class="o">&lt;=</span> <span class="n">index</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_s_ctg_values</span><span class="p">[</span><span class="n">key</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span> <span class="nb">set</span><span class="p">(</span> <span class="p">)</span> <span class="p">)</span>
            <span class="k">for</span> <span class="n">ctgset</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">mutually_exclusive</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">category</span> <span class="ow">in</span> <span class="n">ctgset</span><span class="p">:</span>
                    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span> <span class="n">ctgset</span><span class="o">.</span><span class="n">intersection</span><span class="p">(</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_categories</span><span class="p">(</span> <span class="n">key</span><span class="o">=</span><span class="n">key</span><span class="p">,</span>
                                                                 <span class="n">value</span><span class="o">=</span><span class="n">val</span> <span class="p">)</span> <span class="p">)</span>\
                                  <span class="o">.</span><span class="n">difference</span><span class="p">(</span> <span class="nb">set</span><span class="p">(</span> <span class="p">[</span><span class="n">category</span><span class="p">]</span> <span class="p">)</span> <span class="p">)</span> <span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                        <span class="k">raise</span> <span class="n">CategoryError</span><span class="p">(</span> <span class="s2">&quot;Cannot add category &#39;</span><span class="si">%s</span><span class="s2">&#39; to &quot;</span>
                              <span class="s2">&quot;[&#39;</span><span class="si">%s</span><span class="s2">&#39;]&#39;</span><span class="si">%s</span><span class="s2">&#39; because it and an existing category &quot;</span>
                              <span class="s2">&quot;are mutually exclusive.&quot;</span>
                              <span class="o">%</span> <span class="p">(</span><span class="n">category</span><span class="p">,</span> <span class="n">key</span><span class="p">,</span> <span class="n">val</span><span class="p">),</span> <span class="n">ctgset</span> <span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_s_ctg_values</span><span class="p">[</span><span class="n">key</span><span class="p">][</span><span class="n">index</span><span class="p">]</span><span class="o">.</span><span class="n">add</span><span class="p">(</span> <span class="n">category</span> <span class="p">)</span>
        <span class="c1">#######################################################################</span>
        <span class="c1">## Body of method starts here:</span>
        <span class="k">if</span> <span class="n">key</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">value</span><span class="p">:</span>
                <span class="n">set_val</span><span class="p">(</span> <span class="n">key</span><span class="p">,</span> <span class="n">value</span><span class="p">,</span> <span class="n">category</span> <span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">set_key</span><span class="p">(</span> <span class="n">key</span><span class="p">,</span> <span class="n">category</span> <span class="p">)</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span> <span class="n">keys</span><span class="p">,</span> <span class="n">Sequence</span> <span class="p">)</span> <span class="ow">and</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span> <span class="n">keys</span><span class="p">,</span> <span class="nb">str</span> <span class="p">):</span>
            <span class="k">for</span> <span class="n">key</span> <span class="ow">in</span> <span class="n">keys</span><span class="p">:</span>
                <span class="n">set_key</span><span class="p">(</span> <span class="n">key</span><span class="p">,</span> <span class="n">category</span> <span class="p">)</span>
        <span class="k">elif</span> <span class="n">keys</span> <span class="o">!=</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">KeyError</span><span class="p">(</span> <span class="s1">&#39;`keys` must be a non-string Sequence.  Use the &#39;</span>
                            <span class="s1">&#39;singular `key` to set the category for one key.&#39;</span> <span class="p">)</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span> <span class="n">items</span><span class="p">,</span> <span class="nb">dict</span> <span class="p">):</span>
            <span class="k">for</span> <span class="n">key</span><span class="p">,</span> <span class="n">values</span> <span class="ow">in</span> <span class="n">items</span><span class="o">.</span><span class="n">items</span><span class="p">(</span> <span class="p">):</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span> <span class="n">values</span><span class="p">,</span> <span class="n">Sequence</span> <span class="p">)</span> <span class="ow">or</span> \
                   <span class="nb">isinstance</span><span class="p">(</span> <span class="n">values</span><span class="p">,</span> <span class="nb">str</span> <span class="p">):</span>
                    <span class="n">values</span> <span class="o">=</span> <span class="p">[</span><span class="n">values</span><span class="p">]</span>
                <span class="k">for</span> <span class="n">value</span> <span class="ow">in</span> <span class="n">values</span><span class="p">:</span>
                    <span class="n">set_val</span><span class="p">(</span> <span class="n">key</span><span class="p">,</span> <span class="n">value</span><span class="p">,</span> <span class="n">category</span> <span class="p">)</span>
        <span class="k">elif</span> <span class="n">items</span> <span class="o">!=</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">KeyError</span><span class="p">(</span> <span class="s1">&#39;`items` must be a dict( ).&#39;</span> <span class="p">)</span></div>

<div class="viewcode-block" id="categorizedSetDict.set_categories"><a class="viewcode-back" href="../ParallelRegression.html#ParallelRegression.categorizedSetDict.set_categories">[docs]</a>    <span class="k">def</span> <span class="nf">set_categories</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">categories</span><span class="p">,</span> <span class="n">key</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">value</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                                          <span class="n">keys</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                                          <span class="n">items</span><span class="o">=</span><span class="kc">None</span> <span class="p">):</span>
        <span class="sd">&#39;&#39;&#39;Associates key(s) and/or key/value pairs with each of the specified</span>
<span class="sd">        categories.</span>

<span class="sd">        .set_categories( ) makes a separate call to .set_category( ) for each</span>
<span class="sd">        category.  As such, calls to .set_categories( ) are not atomic.  For</span>
<span class="sd">        atomic behavior, use .__setitem__( ) instead of .set_categories( ).</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        positional arguments</span>
<span class="sd">            Categories to associate with the key(s) and/or key/value pairs.</span>
<span class="sd">        key : str, optional</span>
<span class="sd">            If key but not value is specified, then this key will be associated</span>
<span class="sd">            with the specified category.</span>
<span class="sd">        value, optional</span>
<span class="sd">            If key and value are both specified, then this key/value pair will</span>
<span class="sd">            be associated with the specified category.</span>
<span class="sd">        keys : Sequence</span>
<span class="sd">            The keys in this sequence will be associated with the specified</span>
<span class="sd">            category.</span>
<span class="sd">        items : dict</span>
<span class="sd">            The key/value pairs in this dict( ) will be associated with the</span>
<span class="sd">            specified category.  Each value in this dict( ) can be either a</span>
<span class="sd">            single set member or a sequence of set members to associate with</span>
<span class="sd">            the specified category.</span>

<span class="sd">        Raises</span>
<span class="sd">        ------</span>
<span class="sd">        CategoryError</span>
<span class="sd">            If the category specified and one or more categories already</span>
<span class="sd">            associated with one or more of the specified key(s) or key/value</span>
<span class="sd">            pairs are considered mutually exclusive.</span>
<span class="sd">        KeyError</span>
<span class="sd">            If a specified key/value pair does not identify an existing set</span>
<span class="sd">            member.  Note that assigning a category to a key for which there is</span>
<span class="sd">            no pre-existing entry results in the creation of a default entry</span>
<span class="sd">            instead of of a KeyError.</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="n">categories</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">set_category</span><span class="p">(</span> <span class="n">c</span><span class="p">,</span> <span class="n">key</span><span class="o">=</span><span class="n">key</span><span class="p">,</span> <span class="n">value</span><span class="o">=</span><span class="n">value</span><span class="p">,</span>
                                  <span class="n">keys</span><span class="o">=</span><span class="n">keys</span><span class="p">,</span>
                                  <span class="n">items</span><span class="o">=</span><span class="n">items</span> <span class="p">)</span></div>

<div class="viewcode-block" id="categorizedSetDict.del_category"><a class="viewcode-back" href="../ParallelRegression.html#ParallelRegression.categorizedSetDict.del_category">[docs]</a>    <span class="k">def</span> <span class="nf">del_category</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">category</span><span class="p">,</span> <span class="o">*</span><span class="p">,</span> <span class="n">key</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">value</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                                        <span class="n">keys</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                                        <span class="n">items</span><span class="o">=</span><span class="kc">None</span> <span class="p">):</span>
        <span class="sd">&#39;&#39;&#39;Disassociates the specified category from the specified key(s) and/</span>
<span class="sd">        or key/value pairs.  See .set_category( ) documentation for usage.</span>

<span class="sd">        If there is no existing association between `category` and a specified</span>
<span class="sd">        key and/or key/value pair, no Exception is raised.</span>

<span class="sd">        Raises</span>
<span class="sd">        ------</span>
<span class="sd">        CategoryError</span>
<span class="sd">            If an attempt is made to disassociate an individual set member with</span>
<span class="sd">            a category that is associated with the whole set.</span>
<span class="sd">        KeyError</span>
<span class="sd">            If a specified key/value pair does not identify an existing set</span>
<span class="sd">            member.</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="k">def</span> <span class="nf">del_key</span><span class="p">(</span> <span class="n">key</span><span class="p">,</span> <span class="n">category</span> <span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_s_ctg_keys</span><span class="p">[</span><span class="n">key</span><span class="p">]</span><span class="o">.</span><span class="n">discard</span><span class="p">(</span> <span class="n">category</span> <span class="p">)</span>
        <span class="k">def</span> <span class="nf">del_val</span><span class="p">(</span> <span class="n">key</span><span class="p">,</span> <span class="n">val</span><span class="p">,</span> <span class="n">category</span> <span class="p">):</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="n">index</span> <span class="o">=</span> <span class="n">typedDict</span><span class="o">.</span><span class="n">__getitem__</span><span class="p">(</span> <span class="bp">self</span><span class="p">,</span> <span class="n">key</span> <span class="p">)</span><span class="o">.</span><span class="n">index</span><span class="p">(</span> <span class="n">val</span> <span class="p">)</span>
            <span class="k">except</span> <span class="ne">ValueError</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">KeyError</span><span class="p">(</span> <span class="s2">&quot;Set identified by key &#39;</span><span class="si">%s</span><span class="s2">&#39; has no value &#39;</span><span class="si">%s</span><span class="s2">&#39;.&quot;</span>
                                <span class="s2">&quot;  It has: </span><span class="si">%s</span><span class="s2">.&quot;</span>
                                <span class="o">%</span> <span class="p">(</span><span class="n">key</span><span class="p">,</span>
                                   <span class="n">val</span><span class="p">,</span>
                                   <span class="n">typedDict</span><span class="o">.</span><span class="n">__getitem__</span><span class="p">(</span> <span class="bp">self</span><span class="p">,</span> <span class="n">key</span> <span class="p">))</span> <span class="p">)</span>
            <span class="k">while</span> <span class="nb">len</span><span class="p">(</span> <span class="bp">self</span><span class="o">.</span><span class="n">_s_ctg_values</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="p">)</span> <span class="o">&lt;=</span> <span class="n">index</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_s_ctg_values</span><span class="p">[</span><span class="n">key</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span> <span class="nb">set</span><span class="p">(</span> <span class="p">)</span> <span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_s_ctg_values</span><span class="p">[</span><span class="n">key</span><span class="p">][</span><span class="n">index</span><span class="p">]</span><span class="o">.</span><span class="n">discard</span><span class="p">(</span> <span class="n">category</span> <span class="p">)</span>
        <span class="c1">#######################################################################</span>
        <span class="c1">## Body of method starts here:</span>
        <span class="k">if</span> <span class="n">key</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">value</span><span class="p">:</span>
                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_a</span><span class="p">(</span> <span class="n">category</span><span class="p">,</span> <span class="n">key</span><span class="o">=</span><span class="n">key</span> <span class="p">):</span>
                    <span class="k">raise</span> <span class="n">CategoryError</span><span class="p">(</span> <span class="s2">&quot;Attempted disassociation of [&#39;</span><span class="si">%s</span><span class="s2">&#39;]</span><span class="si">%s</span><span class="s2">&quot;</span>
                          <span class="s2">&quot; and category &#39;</span><span class="si">%s</span><span class="s2">&#39; when said category is associated&quot;</span>
                          <span class="s2">&quot; with the whole set [&#39;</span><span class="si">%s</span><span class="s2">&#39;].&quot;</span>
                          <span class="o">%</span> <span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="n">value</span><span class="p">,</span> <span class="n">category</span><span class="p">,</span> <span class="n">key</span><span class="p">)</span> <span class="p">)</span>
                <span class="n">del_val</span><span class="p">(</span> <span class="n">key</span><span class="p">,</span> <span class="n">value</span><span class="p">,</span> <span class="n">category</span> <span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">del_key</span><span class="p">(</span> <span class="n">key</span><span class="p">,</span> <span class="n">category</span> <span class="p">)</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span> <span class="n">keys</span><span class="p">,</span> <span class="n">Sequence</span> <span class="p">)</span> <span class="ow">and</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span> <span class="n">keys</span><span class="p">,</span> <span class="nb">str</span> <span class="p">):</span>
            <span class="k">for</span> <span class="n">key</span> <span class="ow">in</span> <span class="n">keys</span><span class="p">:</span>
                <span class="n">del_key</span><span class="p">(</span> <span class="n">key</span><span class="p">,</span> <span class="n">category</span> <span class="p">)</span>
        <span class="k">elif</span> <span class="n">keys</span> <span class="o">!=</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">KeyError</span><span class="p">(</span> <span class="s1">&#39;`keys` must be a non-string Sequence.  Use the &#39;</span>
                  <span class="s1">&#39;singular `key` to disassociate the category for one key.&#39;</span> <span class="p">)</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span> <span class="n">items</span><span class="p">,</span> <span class="nb">dict</span> <span class="p">):</span>
            <span class="k">for</span> <span class="n">key</span><span class="p">,</span> <span class="n">value</span> <span class="ow">in</span> <span class="n">items</span><span class="o">.</span><span class="n">items</span><span class="p">(</span> <span class="p">):</span>
                <span class="n">del_val</span><span class="p">(</span> <span class="n">key</span><span class="p">,</span> <span class="n">value</span><span class="p">,</span> <span class="n">category</span> <span class="p">)</span>
        <span class="k">elif</span> <span class="n">items</span> <span class="o">!=</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">KeyError</span><span class="p">(</span> <span class="s1">&#39;`items` must be a dict( ).&#39;</span> <span class="p">)</span></div>

<div class="viewcode-block" id="categorizedSetDict.keys_categorized"><a class="viewcode-back" href="../ParallelRegression.html#ParallelRegression.categorizedSetDict.keys_categorized">[docs]</a>    <span class="k">def</span> <span class="nf">keys_categorized</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">category</span> <span class="p">):</span>
        <span class="sd">&#39;&#39;&#39;Returns the keys that are associated with the specified category.&#39;&#39;&#39;</span>
        <span class="k">if</span> <span class="n">category</span> <span class="o">==</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">return</span><span class="p">(</span> <span class="bp">self</span><span class="o">.</span><span class="n">_keys_categorized_none</span><span class="p">(</span> <span class="p">)</span> <span class="p">)</span>
        <span class="n">ret</span> <span class="o">=</span> <span class="n">setList</span><span class="p">(</span> <span class="p">)</span>
        <span class="k">for</span> <span class="n">key</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">keys</span><span class="p">(</span> <span class="p">):</span>
            <span class="k">if</span> <span class="n">category</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_s_ctg_keys</span><span class="p">[</span><span class="n">key</span><span class="p">]:</span>
                <span class="n">ret</span><span class="o">.</span><span class="n">append</span><span class="p">(</span> <span class="n">key</span> <span class="p">)</span>
        <span class="k">return</span><span class="p">(</span> <span class="n">ret</span> <span class="p">)</span></div>

<div class="viewcode-block" id="categorizedSetDict.items_categorized"><a class="viewcode-back" href="../ParallelRegression.html#ParallelRegression.categorizedSetDict.items_categorized">[docs]</a>    <span class="k">def</span> <span class="nf">items_categorized</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">category</span> <span class="p">):</span>
        <span class="sd">&#39;&#39;&#39;Returns the key/value pairs consisting of keys associated with the</span>
<span class="sd">        specified category with all of their set members, as well as set</span>
<span class="sd">        members that are individually associated with the specified category</span>
<span class="sd">        (along with their keys).&#39;&#39;&#39;</span>
        <span class="k">if</span> <span class="n">category</span> <span class="o">==</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">return</span><span class="p">(</span> <span class="bp">self</span><span class="o">.</span><span class="n">_items_categorized_none</span><span class="p">(</span> <span class="p">)</span> <span class="p">)</span>
        <span class="n">ret</span> <span class="o">=</span> <span class="n">typedDict</span><span class="p">(</span> <span class="n">setList</span> <span class="p">)</span>
        <span class="k">for</span> <span class="n">key</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">keys</span><span class="p">(</span> <span class="p">):</span>
            <span class="k">if</span> <span class="n">key</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_s_ctg_keys</span><span class="o">.</span><span class="n">keys</span><span class="p">(</span> <span class="p">):</span>
                <span class="k">if</span> <span class="n">category</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_s_ctg_keys</span><span class="p">[</span><span class="n">key</span><span class="p">]:</span>
                    <span class="n">ret</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="n">typedDict</span><span class="o">.</span><span class="n">__getitem__</span><span class="p">(</span> <span class="bp">self</span><span class="p">,</span> <span class="n">key</span> <span class="p">)</span>
                <span class="k">if</span> <span class="n">key</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_s_ctg_values</span><span class="o">.</span><span class="n">keys</span><span class="p">(</span> <span class="p">):</span>
                    <span class="k">if</span> <span class="n">key</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">ret</span><span class="o">.</span><span class="n">keys</span><span class="p">(</span> <span class="p">):</span>
                        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span> <span class="nb">len</span><span class="p">(</span> <span class="bp">self</span><span class="o">.</span><span class="n">_s_ctg_values</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="p">)</span> <span class="p">):</span>
                            <span class="k">if</span> <span class="n">category</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_s_ctg_values</span><span class="p">[</span><span class="n">key</span><span class="p">][</span><span class="n">i</span><span class="p">]:</span>
                                <span class="n">ret</span><span class="p">[</span><span class="n">key</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span> <span class="n">typedDict</span><span class="o">.</span><span class="n">__getitem__</span><span class="p">(</span> <span class="bp">self</span><span class="p">,</span>
                                                                     <span class="n">key</span> <span class="p">)[</span><span class="n">i</span><span class="p">]</span> <span class="p">)</span>
        <span class="k">return</span><span class="p">(</span> <span class="n">ret</span> <span class="p">)</span></div>

<div class="viewcode-block" id="categorizedSetDict.values_categorized"><a class="viewcode-back" href="../ParallelRegression.html#ParallelRegression.categorizedSetDict.values_categorized">[docs]</a>    <span class="k">def</span> <span class="nf">values_categorized</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">category</span> <span class="p">):</span>
        <span class="sd">&#39;&#39;&#39;Returns set members from all sets where either the set member or the</span>
<span class="sd">        set is associated with the specified category.&#39;&#39;&#39;</span>
        <span class="n">items</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">items_categorized</span><span class="p">(</span> <span class="n">category</span> <span class="p">)</span>
        <span class="n">ret</span> <span class="o">=</span> <span class="n">setList</span><span class="p">(</span> <span class="p">)</span>
        <span class="k">for</span> <span class="n">value</span> <span class="ow">in</span> <span class="n">items</span><span class="o">.</span><span class="n">values</span><span class="p">(</span> <span class="p">):</span>
            <span class="n">ret</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span> <span class="n">value</span> <span class="p">)</span>
        <span class="k">return</span><span class="p">(</span> <span class="n">ret</span> <span class="p">)</span></div>

<div class="viewcode-block" id="categorizedSetDict.make_mutually_exclusive"><a class="viewcode-back" href="../ParallelRegression.html#ParallelRegression.categorizedSetDict.make_mutually_exclusive">[docs]</a>    <span class="k">def</span> <span class="nf">make_mutually_exclusive</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">categories</span> <span class="p">):</span>
        <span class="sd">&#39;&#39;&#39;Designates the specified set of categories as mutually exclusive.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        categories : set or Sequence</span>
<span class="sd">            The set of categories to be considered mutually exclusive.  If this</span>
<span class="sd">            is a superset of an existing set of mutually exclusive categories,</span>
<span class="sd">            it will replace the existing subset.  If an existing set is a</span>
<span class="sd">            superset of this one, then no action is taken.</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="n">categories</span> <span class="o">=</span> <span class="nb">frozenset</span><span class="p">(</span> <span class="n">categories</span> <span class="p">)</span>
        <span class="k">for</span> <span class="n">ctgset</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">mutually_exclusive</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">categories</span><span class="o">.</span><span class="n">issuperset</span><span class="p">(</span> <span class="n">ctgset</span> <span class="p">):</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">mutually_exclusive</span><span class="o">.</span><span class="n">remove</span><span class="p">(</span> <span class="n">ctgset</span> <span class="p">)</span>
            <span class="k">elif</span> <span class="n">ctgset</span><span class="o">.</span><span class="n">issuperset</span><span class="p">(</span> <span class="n">categories</span> <span class="p">):</span>
                <span class="k">return</span><span class="p">(</span> <span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">mutually_exclusive</span><span class="o">.</span><span class="n">add</span><span class="p">(</span> <span class="n">categories</span> <span class="p">)</span></div>

    <span class="k">def</span> <span class="nf">_keys_categorized_none</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">items_none</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_items_categorized_none</span><span class="p">(</span> <span class="p">)</span>
        <span class="k">return</span><span class="p">(</span> <span class="n">items_none</span><span class="o">.</span><span class="n">keys</span><span class="p">(</span> <span class="p">)</span> <span class="p">)</span>

    <span class="k">def</span> <span class="nf">_values_categorized_none</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">ret</span> <span class="o">=</span> <span class="n">setList</span><span class="p">(</span> <span class="p">)</span>
        <span class="k">for</span> <span class="n">key</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">keys</span><span class="p">(</span> <span class="p">):</span>
            <span class="k">if</span> <span class="n">key</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_s_ctg_keys</span><span class="o">.</span><span class="n">keys</span><span class="p">(</span> <span class="p">)</span> <span class="ow">or</span> \
               <span class="bp">self</span><span class="o">.</span><span class="n">_s_ctg_keys</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="o">==</span> <span class="kc">None</span> <span class="ow">or</span> \
               <span class="nb">len</span><span class="p">(</span> <span class="bp">self</span><span class="o">.</span><span class="n">_s_ctg_keys</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span> <span class="nb">len</span><span class="p">(</span> <span class="n">typedDict</span><span class="o">.</span><span class="n">__getitem__</span><span class="p">(</span> <span class="bp">self</span><span class="p">,</span> <span class="n">key</span> <span class="p">)</span> <span class="p">)</span> <span class="p">):</span>
                    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span> <span class="bp">self</span><span class="o">.</span><span class="n">_s_ctg_values</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="p">)</span> <span class="o">&lt;=</span> <span class="n">i</span> <span class="ow">or</span> \
                       <span class="bp">self</span><span class="o">.</span><span class="n">_s_ctg_values</span><span class="p">[</span><span class="n">key</span><span class="p">][</span><span class="n">i</span><span class="p">]</span> <span class="o">==</span> <span class="kc">None</span> <span class="ow">or</span> \
                       <span class="nb">len</span><span class="p">(</span> <span class="bp">self</span><span class="o">.</span><span class="n">_s_ctg_values</span><span class="p">[</span><span class="n">key</span><span class="p">][</span><span class="n">i</span><span class="p">]</span> <span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                        <span class="n">ret</span><span class="o">.</span><span class="n">append</span><span class="p">(</span> <span class="n">typedDict</span><span class="o">.</span><span class="n">__getitem__</span><span class="p">(</span> <span class="bp">self</span><span class="p">,</span> <span class="n">key</span> <span class="p">)[</span><span class="n">i</span><span class="p">]</span> <span class="p">)</span>
        <span class="k">return</span><span class="p">(</span> <span class="n">ret</span> <span class="p">)</span>

    <span class="k">def</span> <span class="nf">_items_categorized_none</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">ret</span> <span class="o">=</span> <span class="n">typedDict</span><span class="p">(</span> <span class="n">setList</span> <span class="p">)</span>
        <span class="k">for</span> <span class="n">key</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">keys</span><span class="p">(</span> <span class="p">):</span>
            <span class="k">if</span> <span class="n">key</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_s_ctg_keys</span><span class="o">.</span><span class="n">keys</span><span class="p">(</span> <span class="p">)</span> <span class="ow">or</span> \
               <span class="bp">self</span><span class="o">.</span><span class="n">_s_ctg_keys</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="o">==</span> <span class="p">{</span><span class="kc">None</span><span class="p">,}</span> <span class="ow">or</span> \
               <span class="nb">len</span><span class="p">(</span> <span class="bp">self</span><span class="o">.</span><span class="n">_s_ctg_keys</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span> <span class="nb">len</span><span class="p">(</span> <span class="n">typedDict</span><span class="o">.</span><span class="n">__getitem__</span><span class="p">(</span> <span class="bp">self</span><span class="p">,</span> <span class="n">key</span> <span class="p">)</span> <span class="p">)</span> <span class="p">):</span>
                    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span> <span class="bp">self</span><span class="o">.</span><span class="n">_s_ctg_values</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="p">)</span> <span class="o">&lt;=</span> <span class="n">i</span> <span class="ow">or</span> \
                       <span class="bp">self</span><span class="o">.</span><span class="n">_s_ctg_values</span><span class="p">[</span><span class="n">key</span><span class="p">][</span><span class="n">i</span><span class="p">]</span> <span class="o">==</span> <span class="kc">None</span> <span class="ow">or</span> \
                       <span class="nb">len</span><span class="p">(</span> <span class="bp">self</span><span class="o">.</span><span class="n">_s_ctg_values</span><span class="p">[</span><span class="n">key</span><span class="p">][</span><span class="n">i</span><span class="p">]</span> <span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                        <span class="n">ret</span><span class="p">[</span><span class="n">key</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span> <span class="n">typedDict</span><span class="o">.</span><span class="n">__getitem__</span><span class="p">(</span> <span class="bp">self</span><span class="p">,</span>
                                                                <span class="n">key</span> <span class="p">)[</span><span class="n">i</span><span class="p">]</span> <span class="p">)</span>
        <span class="k">return</span><span class="p">(</span> <span class="n">ret</span> <span class="p">)</span>

<div class="viewcode-block" id="categorizedSetDict.pop"><a class="viewcode-back" href="../ParallelRegression.html#ParallelRegression.categorizedSetDict.pop">[docs]</a>    <span class="k">def</span> <span class="nf">pop</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">key</span> <span class="p">):</span>
        <span class="sd">&#39;&#39;&#39;Removes and returns the setList( ) associated with the provided key</span>
<span class="sd">        and deletes category information.</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="k">if</span> <span class="n">key</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">KeyError</span><span class="p">(</span> <span class="s1">&#39;Invalid key: `</span><span class="si">%s</span><span class="s1">`.&#39;</span> <span class="o">%</span> <span class="n">key</span> <span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_s_ctg_keys</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span> <span class="n">key</span> <span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_s_ctg_values</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span> <span class="n">key</span> <span class="p">)</span>
        <span class="k">return</span><span class="p">(</span> <span class="n">typedDict</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span> <span class="bp">self</span><span class="p">,</span> <span class="n">key</span> <span class="p">)</span> <span class="p">)</span></div>

    <span class="k">def</span> <span class="nf">__delitem__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">key</span> <span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span> <span class="n">key</span> <span class="p">)</span>

    <span class="k">def</span> <span class="nf">__missing__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">key</span> <span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_s_ctg_keys</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span> <span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_s_ctg_values</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span> <span class="p">)</span>
        <span class="k">return</span><span class="p">(</span> <span class="n">typedDict</span><span class="o">.</span><span class="n">__missing__</span><span class="p">(</span> <span class="bp">self</span><span class="p">,</span> <span class="n">key</span> <span class="p">)</span> <span class="p">)</span></div>

<div class="viewcode-block" id="termSet"><a class="viewcode-back" href="../ParallelRegression.html#ParallelRegression.termSet">[docs]</a><span class="k">class</span> <span class="nc">termSet</span><span class="p">(</span><span class="n">categorizedSetDict</span><span class="p">):</span>
    <span class="sd">&#39;&#39;&#39;Manages a set of terms, each of which might have multiple</span>
<span class="sd">    representations.</span>

<span class="sd">    Categories</span>
<span class="sd">    ----------</span>
<span class="sd">    dummy</span>
<span class="sd">        &quot;Dummy&quot; terms or representations of terms in which there are only two</span>
<span class="sd">        values.</span>
<span class="sd">    Y</span>
<span class="sd">        Terms that are used on the LHS of formulas instead of the RHS.  Terms</span>
<span class="sd">        that are sometimes used on the LHS and sometimes used on the RHS are</span>
<span class="sd">        not supported.  (However, there is no need to make use of the &#39;Y&#39;</span>
<span class="sd">        category in order to make full use of mathDict( ).)</span>
<span class="sd">    required_X</span>
<span class="sd">        Terms that must be included on the RHS of all formulas derived from</span>
<span class="sd">        this termSet( ).</span>
<span class="sd">    T</span>
<span class="sd">        RHS term(s) representing time/trend.</span>
<span class="sd">    &#39;&#39;&#39;</span>
<div class="viewcode-block" id="termSet.__init__"><a class="viewcode-back" href="../ParallelRegression.html#ParallelRegression.termSet.__init__">[docs]</a>    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="n">interactions</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">expand</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span> <span class="p">):</span>
        <span class="sd">&#39;&#39;&#39;Creates a termSet( ) instance.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        formulas : Iterable of formula strings</span>
<span class="sd">            Iterable of a formula strings from which to extract the terms and</span>
<span class="sd">            their forms.  Ex: [&#39;y ~ x**2 + x&#39;, &#39;ln(y) ~ ln(x)&#39;].</span>
<span class="sd">        *or*</span>
<span class="sd">        terms : dict</span>
<span class="sd">            Dictionary in which each term is represented by a key for which the</span>
<span class="sd">            value is a sequence of forms in which the term might occur.  Ex:</span>
<span class="sd">            {&#39;X&#39;: [&#39;X&#39;, &#39;ln(X)&#39;]}.  Entries for which the value is a single</span>
<span class="sd">            string, e.g. {&#39;d&#39;: &#39;d&#39;},  will be treated as dummy terms.  To avoid</span>
<span class="sd">            this when a term has only one form, enclose the string in a list,</span>
<span class="sd">            e.g. {&#39;X&#39;: [&#39;X&#39;]}.</span>
<span class="sd">        T : string, optional</span>
<span class="sd">            String identifying a single term that represents time/trend.</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="n">categorizedSetDict</span><span class="o">.</span><span class="n">__init__</span><span class="p">(</span> <span class="bp">self</span><span class="p">,</span> <span class="n">singular_category</span><span class="o">=</span><span class="s1">&#39;dummy&#39;</span> <span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">make_mutually_exclusive</span><span class="p">(</span> <span class="p">[</span><span class="s1">&#39;Y&#39;</span><span class="p">,</span> <span class="s1">&#39;required_X&#39;</span><span class="p">]</span> <span class="p">)</span>
        <span class="k">if</span> <span class="s1">&#39;terms&#39;</span> <span class="ow">in</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">keys</span><span class="p">(</span> <span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_init_from_terms</span><span class="p">(</span> <span class="o">**</span><span class="n">kwargs</span> <span class="p">)</span>
        <span class="k">elif</span> <span class="s1">&#39;formulas&#39;</span> <span class="ow">in</span> <span class="n">kwargs</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_init_from_formulas</span><span class="p">(</span> <span class="o">**</span><span class="n">kwargs</span> <span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_init_from_terms</span><span class="p">(</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span> <span class="p">)</span></div>

    <span class="k">def</span> <span class="nf">_init_from_formulas</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">formulas</span> <span class="p">):</span>
        <span class="k">def</span> <span class="nf">get_term_vars</span><span class="p">(</span> <span class="n">formula</span> <span class="p">):</span>
            <span class="n">patsySet</span> <span class="o">=</span> <span class="n">_patsy_terms</span><span class="p">(</span> <span class="n">formula</span><span class="p">,</span> <span class="n">reduce_to_vars</span><span class="o">=</span><span class="kc">True</span> <span class="p">)</span>
            <span class="n">ret</span> <span class="o">=</span> <span class="n">setList</span><span class="p">(</span> <span class="p">)</span>
            <span class="k">for</span> <span class="n">patsyTerm</span> <span class="ow">in</span> <span class="n">patsySet</span><span class="p">:</span>
                <span class="k">for</span> <span class="n">var</span> <span class="ow">in</span> <span class="n">patsyTerm</span><span class="p">:</span>
                    <span class="n">ret</span><span class="o">.</span><span class="n">add</span><span class="p">(</span> <span class="n">var</span> <span class="p">)</span>
            <span class="k">return</span><span class="p">(</span> <span class="n">ret</span> <span class="p">)</span>
        <span class="k">def</span> <span class="nf">get_term_reps</span><span class="p">(</span> <span class="n">formula</span> <span class="p">):</span>
            <span class="n">patsySet</span> <span class="o">=</span> <span class="n">_patsy_terms</span><span class="p">(</span> <span class="n">formula</span> <span class="p">)</span>
            <span class="n">ret</span> <span class="o">=</span> <span class="n">typedDict</span><span class="p">(</span> <span class="n">setList</span> <span class="p">)</span>
            <span class="k">for</span> <span class="n">patsyTerm</span> <span class="ow">in</span> <span class="n">patsySet</span><span class="p">:</span>
                <span class="k">for</span> <span class="n">factor</span> <span class="ow">in</span> <span class="n">patsyTerm</span><span class="p">:</span>
                    <span class="k">for</span> <span class="n">var</span> <span class="ow">in</span> <span class="n">_vars_in_factor</span><span class="p">(</span> <span class="n">factor</span> <span class="p">):</span>
                        <span class="n">ret</span><span class="p">[</span><span class="n">var</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span> <span class="n">factor</span> <span class="p">)</span>
            <span class="k">return</span><span class="p">(</span> <span class="n">ret</span> <span class="p">)</span>
        <span class="c1">#######################################################################</span>
        <span class="c1">## Body of method starts here:</span>
        <span class="n">Y</span> <span class="o">=</span> <span class="n">setList</span><span class="p">(</span> <span class="p">)</span>
        <span class="k">for</span> <span class="n">formula</span> <span class="ow">in</span> <span class="n">formulas</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">union_update</span><span class="p">(</span> <span class="n">get_term_reps</span><span class="p">(</span> <span class="n">formula</span> <span class="p">)</span> <span class="p">)</span>
            <span class="n">sides</span> <span class="o">=</span> <span class="n">formula</span><span class="o">.</span><span class="n">split</span><span class="p">(</span> <span class="s1">&#39;~&#39;</span> <span class="p">)</span>
            <span class="n">Y</span> <span class="o">=</span> <span class="n">Y</span><span class="o">.</span><span class="n">union</span><span class="p">(</span> <span class="n">get_term_vars</span><span class="p">(</span> <span class="n">sides</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="p">)</span> <span class="p">)</span>
        <span class="k">for</span> <span class="n">y</span> <span class="ow">in</span> <span class="n">Y</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">set_category</span><span class="p">(</span> <span class="s1">&#39;Y&#39;</span><span class="p">,</span> <span class="n">key</span><span class="o">=</span><span class="n">y</span> <span class="p">)</span>

    <span class="k">def</span> <span class="nf">_init_from_terms</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">terms</span><span class="p">,</span> <span class="n">dterms</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">T</span><span class="o">=</span><span class="kc">None</span> <span class="p">):</span>
        <span class="n">DEPRECATED_PARAMETER</span> <span class="o">=</span> <span class="s1">&#39;&#39;&#39;</span>
<span class="s1">        dterms : Iterable, optional</span>
<span class="s1">            Iterable of dummy terms that only occur in one form.  Dummy terms</span>
<span class="s1">            listed in `dterms` need not also be listed in `terms`.</span>

<span class="s1">        The `dterms` parameter is deprecated as of the first release of</span>
<span class="s1">        Parallel Regression.  It exists to support code that predates</span>
<span class="s1">        categorizedSetDict( ) and will be removed in a subsequent release.  Use</span>
<span class="s1">        entries in the `terms` dict( ) for which the value is a single string</span>
<span class="s1">        to identify single-form dummy terms at initialization time.</span>
<span class="s1">        &#39;&#39;&#39;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span> <span class="n">terms</span><span class="p">,</span> <span class="nb">dict</span> <span class="p">):</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span> <span class="s1">&#39;The set of real terms must be a dictionary.&#39;</span> <span class="p">)</span>
        <span class="k">if</span> <span class="n">dterms</span> <span class="o">!=</span> <span class="kc">None</span> <span class="ow">and</span> \
           <span class="p">((</span><span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span> <span class="n">dterms</span><span class="p">,</span> <span class="n">abc</span><span class="o">.</span><span class="n">Iterable</span> <span class="p">))</span> <span class="ow">or</span> \
            <span class="nb">isinstance</span><span class="p">(</span> <span class="n">dterms</span><span class="p">,</span> <span class="nb">str</span> <span class="p">)):</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span> <span class="s1">&#39;The set of dummy variables must be a non-string&#39;</span>
                             <span class="s1">&#39; iterable.&#39;</span> <span class="p">)</span>
        <span class="k">if</span> <span class="p">(</span><span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span> <span class="n">T</span><span class="p">,</span> <span class="nb">str</span> <span class="p">))</span> <span class="ow">and</span> <span class="n">T</span> <span class="o">!=</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span> <span class="s1">&#39;The time index term must be identified by a &#39;</span>
                  <span class="s1">&#39;string not in the set of dummy terms and not used as a key &#39;</span>
                  <span class="s1">&#39;in the dictionary of real terms.&#39;</span> <span class="p">)</span>
        <span class="k">for</span> <span class="n">term</span> <span class="ow">in</span> <span class="n">dterms</span><span class="p">:</span>
            <span class="bp">self</span><span class="p">[</span><span class="n">term</span><span class="p">]</span> <span class="o">=</span> <span class="n">term</span>
        <span class="k">if</span> <span class="n">T</span><span class="p">:</span>
            <span class="bp">self</span><span class="p">[</span><span class="n">T</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">T</span><span class="p">,</span> <span class="p">{</span><span class="s1">&#39;T&#39;</span><span class="p">,})</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">update</span><span class="p">(</span> <span class="n">terms</span> <span class="p">)</span>

<div class="viewcode-block" id="termSet.changeT"><a class="viewcode-back" href="../ParallelRegression.html#ParallelRegression.termSet.changeT">[docs]</a>    <span class="k">def</span> <span class="nf">changeT</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">T</span> <span class="p">):</span>
        <span class="sd">&#39;&#39;&#39;Disassociates any term(s) currently associated with the category &#39;T&#39;</span>
<span class="sd">        and associates `T` with the category &#39;T&#39;.</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="n">old_T</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">keys_categorized</span><span class="p">(</span> <span class="s1">&#39;T&#39;</span> <span class="p">)</span>
        <span class="k">for</span> <span class="n">key</span> <span class="ow">in</span> <span class="n">old_T</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">del_category</span><span class="p">(</span> <span class="s1">&#39;T&#39;</span><span class="p">,</span> <span class="n">key</span><span class="o">=</span><span class="n">key</span> <span class="p">)</span>
        <span class="k">if</span> <span class="n">T</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">T</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">keys</span><span class="p">(</span> <span class="p">):</span>
                <span class="bp">self</span><span class="p">[</span><span class="n">T</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">T</span><span class="p">,</span> <span class="p">{</span><span class="s1">&#39;T&#39;</span><span class="p">,})</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">set_category</span><span class="p">(</span> <span class="s1">&#39;T&#39;</span><span class="p">,</span> <span class="n">key</span><span class="o">=</span><span class="n">T</span> <span class="p">)</span></div>

<div class="viewcode-block" id="termSet.require"><a class="viewcode-back" href="../ParallelRegression.html#ParallelRegression.termSet.require">[docs]</a>    <span class="k">def</span> <span class="nf">require</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="n">make</span><span class="o">=</span><span class="kc">True</span> <span class="p">):</span>
        <span class="sd">&#39;&#39;&#39;Associates keys listed in *args with the category &#39;required_x&#39; if</span>
<span class="sd">        `make` is True, or disassociates them if `make` is False.</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span> <span class="n">args</span><span class="p">,</span> <span class="nb">str</span> <span class="p">):</span>
                <span class="k">if</span> <span class="n">make</span><span class="p">:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">set_category</span><span class="p">(</span> <span class="s1">&#39;required_X&#39;</span><span class="p">,</span> <span class="n">key</span><span class="o">=</span><span class="n">args</span> <span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">del_category</span><span class="p">(</span> <span class="s1">&#39;required_X&#39;</span><span class="p">,</span> <span class="n">key</span><span class="o">=</span><span class="n">args</span> <span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">for</span> <span class="n">key</span> <span class="ow">in</span> <span class="n">args</span><span class="p">:</span>
                    <span class="k">if</span> <span class="n">make</span><span class="p">:</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">set_category</span><span class="p">(</span> <span class="s1">&#39;required_X&#39;</span><span class="p">,</span> <span class="n">key</span><span class="o">=</span><span class="n">key</span> <span class="p">)</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">del_category</span><span class="p">(</span> <span class="s1">&#39;required_X&#39;</span><span class="p">,</span> <span class="n">key</span><span class="o">=</span><span class="n">key</span> <span class="p">)</span>
        <span class="k">except</span> <span class="n">CategoryError</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">KeyError</span><span class="p">(</span> <span class="s1">&#39;That key is already in Y.  It cannot be used on &#39;</span>
                            <span class="s1">&#39;the LHS and required on the RHS.&#39;</span> <span class="p">)</span></div>

<div class="viewcode-block" id="termSet.Y"><a class="viewcode-back" href="../ParallelRegression.html#ParallelRegression.termSet.Y">[docs]</a>    <span class="k">def</span> <span class="nf">Y</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">key</span><span class="p">,</span> <span class="n">value</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">make</span><span class="o">=</span><span class="kc">True</span> <span class="p">):</span>
        <span class="sd">&#39;&#39;&#39; Associates the specified term with the category &#39;Y&#39; if `make` is</span>
<span class="sd">        True, or disassociates it if `make` is False.</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="k">if</span> <span class="n">key</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">keys</span><span class="p">(</span> <span class="p">):</span>
            <span class="bp">self</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="n">key</span><span class="p">]</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">make</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">set_category</span><span class="p">(</span> <span class="s1">&#39;Y&#39;</span><span class="p">,</span> <span class="n">key</span><span class="o">=</span><span class="n">key</span><span class="p">,</span> <span class="n">value</span><span class="o">=</span><span class="n">value</span> <span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">del_category</span><span class="p">(</span> <span class="s1">&#39;Y&#39;</span><span class="p">,</span> <span class="n">key</span><span class="o">=</span><span class="n">key</span><span class="p">,</span> <span class="n">value</span><span class="o">=</span><span class="n">value</span> <span class="p">)</span>
        <span class="k">except</span> <span class="n">CategoryError</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">KeyError</span><span class="p">(</span> <span class="s1">&#39;That key is already required on the RHS.  It &#39;</span>
                 <span class="s1">&#39;cannot be used on the LHS while it is required on the RHS.&#39;</span> <span class="p">)</span></div>

<div class="viewcode-block" id="termSet.dummy"><a class="viewcode-back" href="../ParallelRegression.html#ParallelRegression.termSet.dummy">[docs]</a>    <span class="k">def</span> <span class="nf">dummy</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">key</span><span class="p">,</span> <span class="n">value</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">make</span><span class="o">=</span><span class="kc">True</span> <span class="p">):</span>
        <span class="sd">&#39;&#39;&#39; Associates the specified term with the category &#39;dummy&#39; if `make`</span>
<span class="sd">        is True, or disassociates it if `make` is False.</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="k">if</span> <span class="n">make</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">set_category</span><span class="p">(</span> <span class="s1">&#39;dummy&#39;</span><span class="p">,</span> <span class="n">key</span><span class="o">=</span><span class="n">key</span><span class="p">,</span> <span class="n">value</span><span class="o">=</span><span class="n">value</span> <span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">del_category</span><span class="p">(</span> <span class="s1">&#39;dummy&#39;</span><span class="p">,</span> <span class="n">key</span><span class="o">=</span><span class="n">key</span><span class="p">,</span> <span class="n">value</span><span class="o">=</span><span class="n">value</span> <span class="p">)</span></div>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">W_term_set</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span><span class="p">(</span> <span class="bp">self</span><span class="o">.</span><span class="n">keys</span><span class="p">(</span> <span class="p">)</span> <span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">Y_term_set</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span><span class="p">(</span> <span class="bp">self</span><span class="o">.</span><span class="n">keys_categorized</span><span class="p">(</span> <span class="s1">&#39;Y&#39;</span> <span class="p">)</span> <span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">X_required_set</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span><span class="p">(</span> <span class="bp">self</span><span class="o">.</span><span class="n">keys_categorized</span><span class="p">(</span> <span class="s1">&#39;required_X&#39;</span> <span class="p">)</span> <span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">dummy_term_set</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span><span class="p">(</span> <span class="bp">self</span><span class="o">.</span><span class="n">keys_categorized</span><span class="p">(</span> <span class="s1">&#39;dummy&#39;</span> <span class="p">)</span> <span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">real_term_set</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span><span class="p">(</span> <span class="bp">self</span><span class="o">.</span><span class="n">keys</span><span class="p">(</span> <span class="p">)</span><span class="o">.</span><span class="n">difference</span><span class="p">(</span> <span class="bp">self</span><span class="o">.</span><span class="n">keys_categorized</span><span class="p">(</span> <span class="s1">&#39;dummy&#39;</span> <span class="p">)</span> <span class="p">)</span> <span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">other_terms</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span><span class="p">(</span> <span class="bp">self</span><span class="o">.</span><span class="n">keys</span><span class="p">(</span> <span class="p">)</span><span class="o">.</span><span class="n">difference</span><span class="p">(</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">keys_categorized</span><span class="p">(</span> <span class="s1">&#39;Y&#39;</span> <span class="p">)</span><span class="o">.</span><span class="n">union</span><span class="p">(</span> <span class="bp">self</span><span class="o">.</span><span class="n">keys_categorized</span><span class="p">(</span> <span class="s1">&#39;required_X&#39;</span>
                                                                        <span class="p">)</span> <span class="p">)</span> <span class="p">)</span> <span class="p">)</span></div>

<span class="n">PR_BYTESIZE</span> <span class="o">=</span> <span class="mi">8</span>
<span class="n">PR_NP_INT</span> <span class="o">=</span> <span class="s1">&#39;i8&#39;</span>
<span class="n">PR_PY_INT</span> <span class="o">=</span> <span class="s1">&#39;q&#39;</span>
<span class="n">PR_NP_FLT</span> <span class="o">=</span> <span class="s1">&#39;f8&#39;</span>
<span class="n">PR_PY_FLT</span> <span class="o">=</span> <span class="s1">&#39;d&#39;</span>

<div class="viewcode-block" id="mathDataStore"><a class="viewcode-back" href="../ParallelRegression.html#ParallelRegression.mathDataStore">[docs]</a><span class="k">class</span> <span class="nc">mathDataStore</span><span class="p">(</span><span class="nb">dict</span><span class="p">):</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">mathDict</span><span class="o">=</span><span class="kc">None</span> <span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">mathDict</span> <span class="o">=</span> <span class="n">mathDict</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">key_list</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&#39;&#39;&#39;Returns the list of columns currently in this data store in sorted</span>
<span class="sd">        list form.</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="n">l</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span> <span class="bp">self</span><span class="o">.</span><span class="n">keys</span><span class="p">(</span> <span class="p">)</span> <span class="p">)</span>
        <span class="n">l</span><span class="o">.</span><span class="n">sort</span><span class="p">(</span> <span class="p">)</span>
        <span class="k">return</span><span class="p">(</span> <span class="n">l</span> <span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">rows</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&#39;&#39;&#39;Returns the number of rows that the matrix of original columns has</span>
<span class="sd">        or will have, as determined by the first column provided to</span>
<span class="sd">        mathDictMaker( ).  All subsequent columns must have the same number of</span>
<span class="sd">        rows.  Returns None before the first column is stored.</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">mathDict</span><span class="p">:</span>
            <span class="k">return</span><span class="p">(</span> <span class="bp">self</span><span class="o">.</span><span class="n">mathDict</span><span class="o">.</span><span class="n">rows</span> <span class="p">)</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span> <span class="bp">self</span> <span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">return</span><span class="p">(</span> <span class="kc">None</span> <span class="p">)</span>
        <span class="k">return</span><span class="p">(</span> <span class="nb">len</span><span class="p">(</span> <span class="bp">self</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">key_list</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span> <span class="p">)</span> <span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">max_lag</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">mathDict</span><span class="p">:</span>
            <span class="k">return</span><span class="p">(</span> <span class="bp">self</span><span class="o">.</span><span class="n">mathDict</span><span class="o">.</span><span class="n">max_lag</span> <span class="p">)</span>
        <span class="k">return</span><span class="p">(</span> <span class="mi">0</span> <span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">itemsize</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&#39;&#39;&#39;Returns the bytes-per-cell.  Currently hard-coded at eight bytes.&#39;&#39;&#39;</span>
        <span class="k">return</span><span class="p">(</span> <span class="n">PR_BYTESIZE</span> <span class="p">)</span>

    <span class="k">def</span> <span class="nf">__setitem__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">key</span><span class="p">,</span> <span class="n">value</span> <span class="p">):</span>
        <span class="sd">&#39;&#39;&#39;See mathDictMaker( ) documentation.&#39;&#39;&#39;</span>
        <span class="k">if</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">mathDict</span> <span class="ow">and</span> <span class="n">key</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">mathDict</span><span class="o">.</span><span class="n">_column_names</span><span class="p">)</span> <span class="ow">or</span> \
           <span class="n">key</span> <span class="o">==</span> <span class="s1">&#39;Intercept&#39;</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">KeyError</span><span class="p">(</span> <span class="s1">&#39;The shared data array already has a column named &#39;</span>
                            <span class="s1">&#39;</span><span class="si">%s</span><span class="s1">.  The shared data array cannot be modified.&#39;</span>
                            <span class="o">%</span> <span class="n">key</span> <span class="p">)</span>
        <span class="k">if</span> <span class="n">value</span> <span class="o">==</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">return</span><span class="p">(</span> <span class="bp">self</span><span class="o">.</span><span class="n">__delitem__</span><span class="p">(</span> <span class="n">key</span> <span class="p">)</span> <span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span> <span class="n">key</span><span class="p">,</span> <span class="nb">str</span> <span class="p">):</span>
            <span class="k">raise</span> <span class="ne">KeyError</span><span class="p">(</span> <span class="s1">&#39;Keys must be strings because they will be used as&#39;</span>
                            <span class="s1">&#39; column names.&#39;</span> <span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span> <span class="n">value</span><span class="p">,</span> <span class="p">(</span><span class="n">Sequence</span><span class="p">,</span> <span class="n">array</span><span class="o">.</span><span class="n">array</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">)</span> <span class="p">)</span> <span class="ow">or</span> \
           <span class="nb">isinstance</span><span class="p">(</span> <span class="n">value</span><span class="p">,</span> <span class="nb">str</span> <span class="p">):</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span> <span class="s1">&#39;All values must be non-string sequences of the &#39;</span>
                             <span class="s1">&#39;same length.&#39;</span><span class="p">,</span> <span class="nb">type</span><span class="p">(</span> <span class="n">value</span> <span class="p">)</span> <span class="p">)</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span> <span class="n">value</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="p">(</span><span class="nb">float</span><span class="p">)</span> <span class="p">):</span>
            <span class="k">for</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">value</span><span class="p">:</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span> <span class="n">v</span><span class="p">,</span> <span class="p">(</span><span class="nb">int</span><span class="p">,</span> <span class="nb">float</span><span class="p">)</span> <span class="p">):</span>
                    <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span> <span class="s1">&#39;One or more values in column </span><span class="si">%s</span><span class="s1"> is &#39;</span>
                                     <span class="s1">&#39;neither an integer nor a float.&#39;</span> <span class="o">%</span> <span class="n">key</span> <span class="p">)</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span> <span class="n">value</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="nb">int</span> <span class="p">):</span>
            <span class="k">for</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">value</span><span class="p">:</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span> <span class="n">v</span><span class="p">,</span> <span class="nb">int</span> <span class="p">):</span>
                    <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span> <span class="s1">&#39;One or more values in column </span><span class="si">%s</span><span class="s1"> is not &#39;</span>
                                     <span class="s1">&#39;an integer.&#39;</span> <span class="o">%</span> <span class="n">key</span> <span class="p">)</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span> <span class="n">value</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span> <span class="p">):</span>
            <span class="k">pass</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span> <span class="s2">&quot;All values must be ndarrays, sequences of ints, &quot;</span>
                             <span class="s2">&quot;or sequences of numbers that start with a float.&quot;</span>
                             <span class="s2">&quot;  </span><span class="si">%s</span><span class="s2"> starts with neither an int nor a float.  &quot;</span>
                             <span class="s2">&quot;&#39;</span><span class="si">%s</span><span class="s2">&#39; is a </span><span class="si">%s</span><span class="s2">.&quot;</span>
                             <span class="o">%</span> <span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="nb">str</span><span class="p">(</span> <span class="n">value</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="p">),</span> <span class="nb">type</span><span class="p">(</span> <span class="n">value</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="p">))</span> <span class="p">)</span>
        <span class="n">mobj</span> <span class="o">=</span> <span class="n">varpattern</span><span class="o">.</span><span class="n">fullmatch</span><span class="p">(</span> <span class="n">mask_brackets</span><span class="p">(</span> <span class="n">key</span> <span class="p">)</span> <span class="p">)</span>
        <span class="k">if</span> <span class="n">mobj</span> <span class="o">==</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">KeyError</span><span class="p">(</span> <span class="s2">&quot;Keys must be valid Python variable names, alone &quot;</span>
                            <span class="s2">&quot;or immediately followed by brackets.  &quot;</span>
                            <span class="s2">&quot;&#39;</span><span class="si">%s</span><span class="s2">&#39; is not.&quot;</span> <span class="o">%</span> <span class="n">key</span> <span class="p">)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">rows</span> <span class="o">==</span> <span class="kc">None</span><span class="p">:</span>
            <span class="nb">dict</span><span class="o">.</span><span class="n">__setitem__</span><span class="p">(</span> <span class="bp">self</span><span class="p">,</span> <span class="n">key</span><span class="p">,</span> <span class="n">value</span> <span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span> <span class="n">value</span> <span class="p">)</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">rows</span><span class="p">:</span>
                <span class="nb">dict</span><span class="o">.</span><span class="n">__setitem__</span><span class="p">(</span> <span class="bp">self</span><span class="p">,</span> <span class="n">key</span><span class="p">,</span> <span class="n">value</span> <span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span> <span class="s1">&#39;The sequence you are trying to add has a &#39;</span>
                                  <span class="s1">&#39;different length, </span><span class="si">%d</span><span class="s1">, than existing &#39;</span>
                                  <span class="s1">&#39;sequence(s), </span><span class="si">%d</span><span class="s1">.&#39;</span>
                                  <span class="o">%</span> <span class="p">(</span><span class="nb">len</span><span class="p">(</span> <span class="n">value</span> <span class="p">),</span>
                                     <span class="nb">len</span><span class="p">(</span> <span class="bp">self</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">key_list</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span> <span class="p">))</span> <span class="p">)</span>

    <span class="k">def</span> <span class="nf">__delitem__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">key</span> <span class="p">):</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">mathDict</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">mathDict</span><span class="o">.</span><span class="n">local_mask</span><span class="o">.</span><span class="n">discard</span><span class="p">(</span> <span class="n">key</span> <span class="p">)</span>
        <span class="k">return</span><span class="p">(</span> <span class="nb">dict</span><span class="o">.</span><span class="n">__delitem__</span><span class="p">(</span> <span class="bp">self</span><span class="p">,</span> <span class="n">key</span> <span class="p">)</span> <span class="p">)</span>

    <span class="k">def</span> <span class="nf">_toNDArray</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">key</span><span class="p">,</span> <span class="n">lag</span><span class="o">=</span><span class="mi">0</span> <span class="p">):</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span> <span class="bp">self</span><span class="p">[</span><span class="n">key</span><span class="p">][</span><span class="mi">0</span><span class="p">],</span> <span class="nb">int</span> <span class="p">):</span>
            <span class="n">column_datatype</span> <span class="o">=</span> <span class="n">PR_NP_INT</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">column_datatype</span> <span class="o">=</span> <span class="n">PR_NP_FLT</span>
        <span class="n">ret</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span> <span class="bp">self</span><span class="p">[</span><span class="n">key</span><span class="p">],</span> <span class="n">column_datatype</span> <span class="p">)</span>
        <span class="k">return</span><span class="p">(</span> <span class="n">ret</span> <span class="p">)</span>

    <span class="k">def</span> <span class="nf">_toBytes</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">key</span><span class="p">,</span> <span class="n">lag</span><span class="o">=</span><span class="mi">0</span> <span class="p">):</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span> <span class="bp">self</span><span class="p">[</span><span class="n">key</span><span class="p">][</span><span class="mi">0</span><span class="p">],</span> <span class="nb">int</span> <span class="p">):</span>
            <span class="n">column_datatype</span> <span class="o">=</span> <span class="n">PR_PY_INT</span>
            <span class="n">np_datatype</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">dtype</span><span class="p">(</span> <span class="n">PR_NP_INT</span> <span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">column_datatype</span> <span class="o">=</span> <span class="n">PR_PY_FLT</span>
            <span class="n">np_datatype</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">dtype</span><span class="p">(</span> <span class="n">PR_NP_FLT</span> <span class="p">)</span>
        <span class="n">ret</span> <span class="o">=</span> <span class="n">array</span><span class="o">.</span><span class="n">array</span><span class="p">(</span> <span class="n">column_datatype</span><span class="p">,</span> <span class="bp">self</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="p">)</span>
        <span class="n">ret</span> <span class="o">=</span> <span class="n">ret</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">max_lag</span><span class="o">-</span><span class="n">lag</span><span class="p">:</span><span class="bp">self</span><span class="o">.</span><span class="n">rows</span><span class="o">-</span><span class="n">lag</span><span class="p">]</span>
        <span class="k">return</span><span class="p">(</span> <span class="n">ret</span><span class="o">.</span><span class="n">tobytes</span><span class="p">(</span> <span class="p">),</span> <span class="n">np_datatype</span> <span class="p">)</span></div>

<div class="viewcode-block" id="mathDictMaker"><a class="viewcode-back" href="../ParallelRegression.html#ParallelRegression.mathDictMaker">[docs]</a><span class="k">class</span> <span class="nc">mathDictMaker</span><span class="p">(</span><span class="n">mathDataStore</span><span class="p">):</span>
    <span class="sd">&#39;&#39;&#39;To provide a column for inclusion in the matrix of original columns,</span>
<span class="sd">    simply add it as if adding to a dict( ).</span>

<span class="sd">    Error checking is relatively thorough because this is intended for use</span>
<span class="sd">    while setting up a large batch of calculations that might take a long time</span>
<span class="sd">    to perform, and mistakes might not otherwise be caught until after-the-</span>
<span class="sd">    fact.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    key : str</span>
<span class="sd">        The key is used as the column name, and must either be a valid Python</span>
<span class="sd">        variable name, or be a valid Python variable name immediately followed</span>
<span class="sd">        by brackets.  The string enclosed in the brackets is not restricted.</span>
<span class="sd">    value : sequence of numerical values</span>
<span class="sd">        The sequence represents the column cells.  The data type for the column</span>
<span class="sd">        is determined by the first value in the sequence, so if the first value</span>
<span class="sd">        is a float then all values will be treated as floats.  If the first</span>
<span class="sd">        value is an integer, than all values must be integers.</span>

<span class="sd">    Raises</span>
<span class="sd">    ------</span>
<span class="sd">    TypeError</span>
<span class="sd">        If the value is not a sequence, or if the value is a string.</span>
<span class="sd">        If the first item in the sequence is an integer but one or more</span>
<span class="sd">        subsequent values is not.</span>
<span class="sd">        If the first item in the sequence is a float but one or more subsequent</span>
<span class="sd">        values is neither an integer nor a float.</span>
<span class="sd">        If the first item in the sequence is neither a float nor an integer.</span>
<span class="sd">    KeyError</span>
<span class="sd">        If the key is not a string.</span>
<span class="sd">        If the key is a string but is not a valid Python variable name.</span>
<span class="sd">    ValueError</span>
<span class="sd">        If the length of the sequence does not match the length of the existing</span>
<span class="sd">        column(s).</span>
<span class="sd">    &#39;&#39;&#39;</span>

    <span class="k">def</span> <span class="nf">_crossproducts</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&#39;&#39;&#39;(for internal use): Pre-calculates the crossproducts of all columns.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        RA_length : int</span>
<span class="sd">            Length of space, in bytes, needed in the shared data array to store</span>
<span class="sd">            the pre-calculated crossproducts.</span>
<span class="sd">        RA : multiprocessing.sharedctypes.RawArray of bytes</span>
<span class="sd">            Sequence of bytes consisting of the pre-calculated crossproduct</span>
<span class="sd">            columns to be stored in the shared data array.</span>
<span class="sd">        cp_dtypes : list of numpy dtype strings</span>
<span class="sd">            Data types of the pre-calculated crossproduct columns.</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="n">cp_count</span> <span class="o">=</span> <span class="n">math</span><span class="o">.</span><span class="n">factorial</span><span class="p">(</span> <span class="nb">len</span><span class="p">(</span> <span class="bp">self</span> <span class="p">)</span> <span class="p">)</span> \
                   <span class="o">//</span> <span class="mi">2</span> \
                   <span class="o">//</span> <span class="n">math</span><span class="o">.</span><span class="n">factorial</span><span class="p">(</span> <span class="nb">len</span><span class="p">(</span> <span class="bp">self</span> <span class="p">)</span> <span class="o">-</span> <span class="mi">2</span> <span class="p">)</span>
        <span class="n">indices</span> <span class="o">=</span> <span class="p">[</span><span class="n">i</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span> <span class="nb">len</span><span class="p">(</span> <span class="bp">self</span> <span class="p">)</span> <span class="p">)]</span>
        <span class="n">indices</span> <span class="o">=</span> <span class="p">[</span><span class="n">i</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">itertools</span><span class="o">.</span><span class="n">combinations</span><span class="p">(</span> <span class="n">indices</span><span class="p">,</span> <span class="mi">2</span> <span class="p">)]</span>
        <span class="n">RA_length</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">rows</span><span class="o">*</span><span class="n">cp_count</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">itemsize</span>
        <span class="n">RA</span> <span class="o">=</span> <span class="n">sharedctypes</span><span class="o">.</span><span class="n">RawArray</span><span class="p">(</span> <span class="s1">&#39;b&#39;</span><span class="p">,</span> <span class="n">RA_length</span> <span class="p">)</span>
        <span class="n">cp_dtypes</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span> <span class="p">)</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span> <span class="n">cp_count</span> <span class="p">):</span>
            <span class="n">a</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">rows</span><span class="o">*</span><span class="n">i</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">itemsize</span>
            <span class="n">t</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">rows</span><span class="o">*</span><span class="p">(</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">itemsize</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span> <span class="bp">self</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">key_list</span><span class="p">[</span><span class="n">indices</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">0</span><span class="p">]]][</span><span class="mi">0</span><span class="p">],</span> <span class="nb">float</span> <span class="p">)</span> <span class="ow">or</span> \
               <span class="nb">isinstance</span><span class="p">(</span> <span class="bp">self</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">key_list</span><span class="p">[</span><span class="n">indices</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">1</span><span class="p">]]][</span><span class="mi">0</span><span class="p">],</span> <span class="nb">float</span> <span class="p">):</span>
                <span class="n">dt</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">dtype</span><span class="p">(</span> <span class="n">PR_NP_FLT</span> <span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">dt</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">dtype</span><span class="p">(</span> <span class="n">PR_NP_INT</span> <span class="p">)</span>
            <span class="n">arr</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span> <span class="bp">self</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">key_list</span><span class="p">[</span><span class="n">indices</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">0</span><span class="p">]]],</span> <span class="n">dtype</span><span class="o">=</span><span class="n">dt</span> <span class="p">)</span> \
                <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span> <span class="bp">self</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">key_list</span><span class="p">[</span><span class="n">indices</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">1</span><span class="p">]]],</span> <span class="n">dtype</span><span class="o">=</span><span class="n">dt</span> <span class="p">)</span>
            <span class="n">RA</span><span class="p">[</span><span class="n">a</span><span class="p">:</span><span class="n">t</span><span class="p">]</span> <span class="o">=</span> <span class="n">arr</span><span class="o">.</span><span class="n">tobytes</span><span class="p">(</span> <span class="p">)</span>
            <span class="n">cp_dtypes</span><span class="o">.</span><span class="n">append</span><span class="p">(</span> <span class="n">dt</span> <span class="p">)</span>
        <span class="k">return</span><span class="p">(</span> <span class="n">RA_length</span><span class="p">,</span> <span class="n">RA</span><span class="p">,</span> <span class="n">cp_dtypes</span> <span class="p">)</span>

    <span class="k">def</span> <span class="nf">_powers</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">powers</span> <span class="p">):</span>
        <span class="sd">&#39;&#39;&#39;(for internal use): Pre-calculates powers two through `powers` of</span>
<span class="sd">        all columns.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        RA_length : int</span>
<span class="sd">            Length of space, in bytes, needed in the shared data array to store</span>
<span class="sd">            the pre-calculated column powers.</span>
<span class="sd">        RA : multiprocessing.sharedctypes.RawArray of bytes</span>
<span class="sd">            Sequence of bytes consisting of the pre-calculated column powers to</span>
<span class="sd">            be stored in the shared data array.</span>
<span class="sd">        pwr_dtypes : list of numpy dtype strings</span>
<span class="sd">            Data types of the columns of pre-calculated columns.</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="n">RA_length</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">rows</span><span class="o">*</span><span class="nb">len</span><span class="p">(</span> <span class="bp">self</span> <span class="p">)</span><span class="o">*</span><span class="p">(</span> <span class="n">powers</span> <span class="o">-</span> <span class="mi">1</span> <span class="p">)</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">itemsize</span>
        <span class="n">RA</span> <span class="o">=</span> <span class="n">sharedctypes</span><span class="o">.</span><span class="n">RawArray</span><span class="p">(</span> <span class="s1">&#39;b&#39;</span><span class="p">,</span> <span class="n">RA_length</span> <span class="p">)</span>
        <span class="n">pwr_dtypes</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span> <span class="p">)</span>
        <span class="k">for</span> <span class="n">pwr</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span> <span class="n">powers</span> <span class="o">-</span> <span class="mi">1</span> <span class="p">):</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span> <span class="nb">len</span><span class="p">(</span> <span class="bp">self</span> <span class="p">)</span> <span class="p">):</span>
                <span class="n">a</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">rows</span><span class="o">*</span><span class="n">pwr</span><span class="o">*</span><span class="nb">len</span><span class="p">(</span> <span class="bp">self</span><span class="o">.</span><span class="n">key_list</span> <span class="p">)</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">itemsize</span>
                <span class="n">a</span> <span class="o">+=</span> <span class="bp">self</span><span class="o">.</span><span class="n">rows</span><span class="o">*</span><span class="n">i</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">itemsize</span>
                <span class="n">t</span> <span class="o">=</span> <span class="n">a</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">rows</span><span class="o">*</span><span class="mi">1</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">itemsize</span>
                <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span> <span class="bp">self</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">key_list</span><span class="p">[</span><span class="n">i</span><span class="p">]][</span><span class="mi">0</span><span class="p">],</span> <span class="nb">float</span> <span class="p">):</span>
                    <span class="n">dt</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">dtype</span><span class="p">(</span> <span class="n">PR_NP_FLT</span> <span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">dt</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">dtype</span><span class="p">(</span> <span class="n">PR_NP_INT</span> <span class="p">)</span>
                <span class="n">arr</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span> <span class="bp">self</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">key_list</span><span class="p">[</span><span class="n">i</span><span class="p">]],</span> <span class="n">dtype</span><span class="o">=</span><span class="n">dt</span> <span class="p">)</span> \
                      <span class="o">**</span> <span class="p">(</span><span class="n">pwr</span> <span class="o">+</span> <span class="mi">2</span><span class="p">)</span>
                <span class="n">RA</span><span class="p">[</span><span class="n">a</span><span class="p">:</span><span class="n">t</span><span class="p">]</span> <span class="o">=</span> <span class="n">arr</span><span class="o">.</span><span class="n">tobytes</span><span class="p">(</span> <span class="p">)</span>
                <span class="n">pwr_dtypes</span><span class="o">.</span><span class="n">append</span><span class="p">(</span> <span class="n">dt</span> <span class="p">)</span>
        <span class="k">return</span><span class="p">(</span> <span class="n">RA_length</span><span class="p">,</span> <span class="n">RA</span><span class="p">,</span> <span class="n">pwr_dtypes</span> <span class="p">)</span>

<div class="viewcode-block" id="mathDictMaker.make"><a class="viewcode-back" href="../ParallelRegression.html#ParallelRegression.mathDictMaker.make">[docs]</a>    <span class="k">def</span> <span class="nf">make</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">cache_crossproducts</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">cache_powers</span><span class="o">=</span><span class="mi">1</span> <span class="p">):</span>
        <span class="sd">&#39;&#39;&#39;Assembles the shared data array and mathDict( ) matrix</span>
<span class="sd">        representation.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        cache_crossproducts : boolean, optional</span>
<span class="sd">            If True, then the crossproducts of all combinations of columns</span>
<span class="sd">            (without replacement) will be pre-calculated and stored along with</span>
<span class="sd">            the matrix of original columns.  To pre-calculate the product of a</span>
<span class="sd">            column and itself, set cache_powers to a number greater than or</span>
<span class="sd">            equal to two.</span>
<span class="sd">        cache_powers : int, optional</span>
<span class="sd">            If an integer greater than one, then powers of all columns from two</span>
<span class="sd">            to this number will be pre-calculated and stored with the matrix of</span>
<span class="sd">            original columns.  Numbers less than or equal to one will be</span>
<span class="sd">            ignored.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        RA : multiprocessing.sharedctypes.RawArray</span>
<span class="sd">            The shared data array in which the matrix of original columns and</span>
<span class="sd">            any pre-calculated columns will be stored.</span>
<span class="sd">        MD : mathDict( )</span>
<span class="sd">            The mathDict( ) representation of a matrix initially consisting of</span>
<span class="sd">            the same columns as the matrix of original columns.  The</span>
<span class="sd">            mathDict( ) object can then be used to mask some columns and/or</span>
<span class="sd">            append calculated columns to the matrix represented by the</span>
<span class="sd">            mathDict( ).  Local columns can then be appended to copies of the</span>
<span class="sd">            mathDict( ) object in other processes.</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="n">RA_length</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">rows</span><span class="o">*</span><span class="nb">len</span><span class="p">(</span> <span class="bp">self</span> <span class="p">)</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">itemsize</span>
        <span class="k">if</span> <span class="n">cache_crossproducts</span><span class="p">:</span>
            <span class="n">cp_ra_len</span><span class="p">,</span> <span class="n">CP</span><span class="p">,</span> <span class="n">cp_dtypes</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_crossproducts</span><span class="p">(</span> <span class="p">)</span>
            <span class="n">RA_length</span> <span class="o">+=</span> <span class="n">cp_ra_len</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">cp_ra_len</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">if</span> <span class="n">cache_powers</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">pwr_ra_len</span><span class="p">,</span> <span class="n">PWR</span><span class="p">,</span> <span class="n">pwr_dtypes</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_powers</span><span class="p">(</span> <span class="n">cache_powers</span> <span class="p">)</span>
            <span class="n">RA_length</span> <span class="o">+=</span> <span class="n">pwr_ra_len</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">pwr_ra_len</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="n">RA</span> <span class="o">=</span> <span class="n">sharedctypes</span><span class="o">.</span><span class="n">RawArray</span><span class="p">(</span> <span class="s1">&#39;b&#39;</span><span class="p">,</span> <span class="n">RA_length</span> <span class="p">)</span>
        <span class="n">dtypes</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span> <span class="p">)</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span> <span class="nb">len</span><span class="p">(</span> <span class="bp">self</span> <span class="p">)</span> <span class="p">):</span>
            <span class="n">a</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">rows</span><span class="o">*</span><span class="n">i</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">itemsize</span>
            <span class="n">t</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">rows</span><span class="o">*</span><span class="p">(</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">itemsize</span>
            <span class="n">RA</span><span class="p">[</span><span class="n">a</span><span class="p">:</span><span class="n">t</span><span class="p">],</span> <span class="n">dt_np</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_toBytes</span><span class="p">(</span> <span class="bp">self</span><span class="o">.</span><span class="n">key_list</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="p">)</span>
            <span class="n">dtypes</span><span class="o">.</span><span class="n">append</span><span class="p">(</span> <span class="n">dt_np</span> <span class="p">)</span>
        <span class="k">if</span> <span class="n">cache_crossproducts</span><span class="p">:</span>
            <span class="n">a</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">rows</span><span class="o">*</span><span class="nb">len</span><span class="p">(</span> <span class="bp">self</span> <span class="p">)</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">itemsize</span>
            <span class="n">t</span> <span class="o">=</span> <span class="n">a</span> <span class="o">+</span> <span class="n">cp_ra_len</span>
            <span class="n">RA</span><span class="p">[</span><span class="n">a</span><span class="p">:</span><span class="n">t</span><span class="p">]</span> <span class="o">=</span> <span class="n">CP</span><span class="p">[:]</span>
            <span class="n">dtypes</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span> <span class="n">cp_dtypes</span> <span class="p">)</span>
        <span class="k">if</span> <span class="n">cache_powers</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">a</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">rows</span><span class="o">*</span><span class="nb">len</span><span class="p">(</span> <span class="bp">self</span> <span class="p">)</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">itemsize</span> <span class="o">+</span> <span class="n">cp_ra_len</span>
            <span class="n">t</span> <span class="o">=</span> <span class="n">a</span> <span class="o">+</span> <span class="n">pwr_ra_len</span>
            <span class="n">RA</span><span class="p">[</span><span class="n">a</span><span class="p">:</span><span class="n">t</span><span class="p">]</span> <span class="o">=</span> <span class="n">PWR</span><span class="p">[:]</span>
            <span class="n">dtypes</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span> <span class="n">pwr_dtypes</span> <span class="p">)</span>
        <span class="n">MD</span> <span class="o">=</span> <span class="n">mathDict</span><span class="p">(</span> <span class="n">RA</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">rows</span><span class="o">*</span><span class="nb">len</span><span class="p">(</span> <span class="bp">self</span> <span class="p">),</span> <span class="bp">self</span><span class="o">.</span><span class="n">key_list</span><span class="p">,</span>
                       <span class="n">dtypes</span><span class="o">=</span><span class="n">dtypes</span><span class="p">,</span>
                       <span class="n">cache_crossproducts</span><span class="o">=</span><span class="n">cache_crossproducts</span><span class="p">,</span>
                       <span class="n">cache_powers</span><span class="o">=</span><span class="n">cache_powers</span> <span class="p">)</span>
        <span class="k">return</span><span class="p">(</span> <span class="n">RA</span><span class="p">,</span> <span class="n">MD</span> <span class="p">)</span></div>

    <span class="nd">@staticmethod</span>
<div class="viewcode-block" id="mathDictMaker.fromMatrix"><a class="viewcode-back" href="../ParallelRegression.html#ParallelRegression.mathDictMaker.fromMatrix">[docs]</a>    <span class="k">def</span> <span class="nf">fromMatrix</span><span class="p">(</span> <span class="n">matrix</span><span class="p">,</span> <span class="n">integer</span><span class="o">=</span><span class="kc">False</span> <span class="p">):</span>
        <span class="sd">&#39;&#39;&#39;Creates a SharedDataArray and mathDict( ) representation from an</span>
<span class="sd">        existing two-dimensional matrix.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        matrix : 2-dimensional array</span>
<span class="sd">            An existing Numpy matrix or 2-dimensional Numpy array.</span>
<span class="sd">        integer : bool</span>
<span class="sd">            If True, the matrix in the SharedDataArray will consist of</span>
<span class="sd">            integers.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        SharedDataArray : multiprocessing.sharedctypes.RawArray</span>
<span class="sd">            The shared data array in which the matrix will be stored.</span>
<span class="sd">        mathDict( ) : mathDict( )</span>
<span class="sd">            The mathDict( ) representation of a matrix.</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="k">if</span> <span class="n">integer</span><span class="p">:</span>
            <span class="n">np_datatype</span> <span class="o">=</span> <span class="n">PR_NP_INT</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">np_datatype</span> <span class="o">=</span> <span class="n">PR_NP_FLT</span>
        <span class="n">r</span><span class="p">,</span> <span class="n">c</span> <span class="o">=</span> <span class="n">matrix</span><span class="o">.</span><span class="n">shape</span>
        <span class="n">items</span> <span class="o">=</span> <span class="n">r</span> <span class="o">*</span> <span class="n">c</span>
        <span class="n">RA_length</span> <span class="o">=</span> <span class="n">items</span> <span class="o">*</span> <span class="n">mathDictMaker</span><span class="p">(</span> <span class="p">)</span><span class="o">.</span><span class="n">itemsize</span>
        <span class="n">column_names</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;x</span><span class="si">%d</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="n">i</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span> <span class="n">c</span> <span class="p">)]</span>
        <span class="n">SharedDataArray</span> <span class="o">=</span> <span class="n">sharedctypes</span><span class="o">.</span><span class="n">RawArray</span><span class="p">(</span> <span class="s1">&#39;b&#39;</span><span class="p">,</span> <span class="n">RA_length</span> <span class="p">)</span>
        <span class="n">SharedDataArray</span><span class="p">[:]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span> <span class="n">matrix</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np_datatype</span>
                                        <span class="p">)</span><span class="o">.</span><span class="n">tobytes</span><span class="p">(</span> <span class="n">order</span><span class="o">=</span><span class="s1">&#39;F&#39;</span> <span class="p">)</span>
        <span class="k">return</span><span class="p">(</span> <span class="n">SharedDataArray</span><span class="p">,</span> <span class="n">mathDict</span><span class="p">(</span> <span class="n">SharedDataArray</span><span class="o">=</span><span class="n">SharedDataArray</span><span class="p">,</span>
                                           <span class="n">items</span><span class="o">=</span><span class="n">items</span><span class="p">,</span>
                                           <span class="n">column_names</span><span class="o">=</span><span class="n">column_names</span><span class="p">,</span>
                                           <span class="n">mask</span><span class="o">=</span><span class="p">[</span><span class="kc">True</span><span class="p">],</span>
                                           <span class="n">dtypes</span><span class="o">=</span><span class="n">np_datatype</span><span class="p">)</span> <span class="p">)</span></div></div>

<div class="viewcode-block" id="mathDictHypothesis"><a class="viewcode-back" href="../ParallelRegression.html#ParallelRegression.mathDictHypothesis">[docs]</a><span class="k">class</span> <span class="nc">mathDictHypothesis</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="sd">&#39;&#39;&#39;Generates testable hypotheses about a mathDict( ) matrix in the form of</span>
<span class="sd">    linear constraints (for use in regression analysis).</span>

<span class="sd">    An &#39;X&#39; matrix representing the regressors (RHS, or &#39;independent&#39; variables)</span>
<span class="sd">    for a linear model for testing the hypothesis is generated.  The columns in</span>
<span class="sd">    the matrix will be the union of all columns in the matrix represented by</span>
<span class="sd">    the mathDict( ) object and all columns in the hypothesis, including</span>
<span class="sd">    calculated columns.</span>

<span class="sd">    An &#39;R&#39; matrix with the same number of columns as the &#39;X&#39; matrix and one row</span>
<span class="sd">    for each column in the hypothesis, as well as an &#39;r&#39; column vector/vertical</span>
<span class="sd">    array with one row/cell for each column in the hypothesis will also be</span>
<span class="sd">    generated.  These can then be used for either an F or a Wald test.</span>

<span class="sd">    &#39;&#39;&#39;</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">mathDict</span> <span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">mathDict</span> <span class="o">=</span> <span class="n">mathDict</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">hypothesis</span> <span class="o">=</span> <span class="n">OrderedDict</span><span class="p">(</span> <span class="p">)</span>

<div class="viewcode-block" id="mathDictHypothesis.add"><a class="viewcode-back" href="../ParallelRegression.html#ParallelRegression.mathDictHypothesis.add">[docs]</a>    <span class="k">def</span> <span class="nf">add</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">column</span><span class="p">,</span> <span class="n">hypothesis</span><span class="o">=</span><span class="mi">0</span> <span class="p">):</span>
        <span class="sd">&#39;&#39;&#39;Adds a column to the hypothesis, and to the resulting X matrix if</span>
<span class="sd">        not included in the matrix represented by the mathDict( ).</span>

<span class="sd">        Raises</span>
<span class="sd">        ------</span>
<span class="sd">        RankError</span>
<span class="sd">            If an attempt to square a dummy variable is made.</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="k">def</span> <span class="nf">checkRank</span><span class="p">(</span> <span class="n">termRep</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">column</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">all_term_keys</span><span class="o">=</span><span class="kc">None</span> <span class="p">):</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">mathDict</span><span class="o">.</span><span class="n">terms</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">all_term_keys</span><span class="p">:</span>
                    <span class="n">term_keys</span> <span class="o">=</span> <span class="n">all_term_keys</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">term_keys</span> <span class="o">=</span> <span class="n">_vars_in_factor</span><span class="p">(</span> <span class="n">termRep</span> <span class="p">)</span>
                <span class="k">for</span> <span class="n">key</span> <span class="ow">in</span> <span class="n">term_keys</span><span class="p">:</span>
                    <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">mathDict</span><span class="o">.</span><span class="n">terms</span><span class="o">.</span><span class="n">is_a</span><span class="p">(</span> <span class="s1">&#39;dummy&#39;</span><span class="p">,</span>
                                                 <span class="n">key</span><span class="o">=</span><span class="n">key</span><span class="p">,</span>
                                                 <span class="n">value</span><span class="o">=</span><span class="n">termRep</span> <span class="p">):</span>
                        <span class="k">if</span> <span class="n">all_term_keys</span><span class="p">:</span>
                            <span class="k">continue</span>
                        <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">mathDict</span><span class="o">.</span><span class="n">columns</span><span class="p">:</span>
                            <span class="k">if</span> <span class="n">has_term</span><span class="p">(</span> <span class="n">c</span><span class="p">,</span> <span class="n">key</span> <span class="p">):</span>
                                <span class="k">raise</span> <span class="n">RankError</span><span class="p">(</span> <span class="s1">&#39;Cannot square dummy &#39;</span>
                                      <span class="s1">&#39;variables in hypotheses.  The column &#39;</span>
                                      <span class="s1">&#39;`</span><span class="si">%s</span><span class="s1">` contains a squared dummy variable.&#39;</span>
                                      <span class="o">%</span> <span class="n">column</span> <span class="p">)</span>
                    <span class="k">elif</span> <span class="n">all_term_keys</span><span class="p">:</span>
                        <span class="k">return</span><span class="p">(</span> <span class="kc">False</span> <span class="p">)</span>
                <span class="k">if</span> <span class="n">all_term_keys</span><span class="p">:</span>
                    <span class="k">return</span><span class="p">(</span> <span class="kc">True</span> <span class="p">)</span>
        <span class="c1">#######################################################################</span>
        <span class="c1">## Body of method starts here:</span>
        <span class="k">if</span> <span class="n">column</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">mathDict</span><span class="o">.</span><span class="n">columns</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">hypothesis</span><span class="p">[</span><span class="n">column</span><span class="p">]</span> <span class="o">=</span> <span class="n">hypothesis</span>
            <span class="k">return</span><span class="p">(</span> <span class="p">)</span>
        <span class="n">masked_column</span> <span class="o">=</span> <span class="n">mask_brackets</span><span class="p">(</span> <span class="n">column</span> <span class="p">)</span>
        <span class="n">mobj</span> <span class="o">=</span> <span class="n">cross_Aor_power</span><span class="o">.</span><span class="n">fullmatch</span><span class="p">(</span> <span class="n">masked_column</span> <span class="p">)</span>
        <span class="n">raising</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="k">if</span> <span class="n">mobj</span> <span class="o">!=</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">mobjDict</span> <span class="o">=</span> <span class="n">masked_dict</span><span class="p">(</span> <span class="n">column</span><span class="p">,</span> <span class="n">mobj</span> <span class="p">)</span>
            <span class="k">if</span> <span class="n">mobjDict</span><span class="p">[</span><span class="s1">&#39;column_a&#39;</span><span class="p">]</span> <span class="o">==</span> <span class="n">mobjDict</span><span class="p">[</span><span class="s1">&#39;column_b&#39;</span><span class="p">]:</span>
                <span class="k">if</span> <span class="n">mobjDict</span><span class="p">[</span><span class="s1">&#39;power_a&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">isdigit</span><span class="p">(</span> <span class="p">):</span>
                    <span class="n">powers</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span> <span class="n">mobjDict</span><span class="p">[</span><span class="s1">&#39;power_a&#39;</span><span class="p">]</span> <span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">powers</span> <span class="o">=</span> <span class="mi">1</span>
                <span class="k">if</span> <span class="n">mobjDict</span><span class="p">[</span><span class="s1">&#39;power_b&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">isdigit</span><span class="p">(</span> <span class="p">):</span>
                    <span class="n">powers</span> <span class="o">+=</span> <span class="nb">int</span><span class="p">(</span> <span class="n">mobjDict</span><span class="p">[</span><span class="s1">&#39;power_b&#39;</span><span class="p">]</span> <span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">powers</span> <span class="o">+=</span> <span class="mi">1</span>
                <span class="n">col_name</span> <span class="o">=</span> <span class="s1">&#39;</span><span class="si">%s</span><span class="s1">**</span><span class="si">%d</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="n">mobjDict</span><span class="p">[</span><span class="s1">&#39;column_a&#39;</span><span class="p">],</span> <span class="n">powers</span><span class="p">)</span>
                <span class="n">col_name</span><span class="p">,</span> <span class="n">boolchk</span> <span class="o">=</span> <span class="n">_soft_in</span><span class="p">(</span> <span class="n">col_name</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">mathDict</span><span class="o">.</span><span class="n">columns</span> <span class="p">)</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="n">boolchk</span><span class="p">:</span>
                    <span class="n">checkRank</span><span class="p">(</span> <span class="n">col_name</span><span class="p">,</span> <span class="n">column</span> <span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">hypothesis</span><span class="p">[</span><span class="n">col_name</span><span class="p">]</span> <span class="o">=</span> <span class="n">hypothesis</span>
                <span class="k">return</span><span class="p">(</span> <span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">fznCl</span>   <span class="o">=</span> <span class="nb">frozenset</span><span class="p">(</span> <span class="n">_vars_in_factor</span><span class="p">(</span> <span class="n">mobjDict</span><span class="p">[</span><span class="s1">&#39;column_a&#39;</span><span class="p">]</span> <span class="p">)</span> <span class="p">)</span>
                <span class="n">fznCl_b</span> <span class="o">=</span> <span class="nb">frozenset</span><span class="p">(</span> <span class="n">_vars_in_factor</span><span class="p">(</span> <span class="n">mobjDict</span><span class="p">[</span><span class="s1">&#39;column_b&#39;</span><span class="p">]</span> <span class="p">)</span> <span class="p">)</span>
                <span class="k">if</span> <span class="n">fznCl</span> <span class="o">==</span> <span class="n">fznCl_b</span><span class="p">:</span>
                    <span class="k">if</span> <span class="n">checkRank</span><span class="p">(</span> <span class="n">all_term_keys</span><span class="o">=</span><span class="n">fznCl</span> <span class="p">):</span>
                        <span class="k">for</span> <span class="n">col</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">mathDict</span><span class="o">.</span><span class="n">columns</span><span class="p">:</span>
                            <span class="k">if</span> <span class="n">fznCl</span> <span class="o">==</span> <span class="nb">frozenset</span><span class="p">(</span> <span class="n">_vars_in_factor</span><span class="p">(</span> <span class="n">col</span> <span class="p">)</span> <span class="p">):</span>
                                <span class="k">if</span> <span class="n">mobjDict</span><span class="p">[</span><span class="s1">&#39;power_a&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">isdigit</span><span class="p">(</span> <span class="p">):</span>
                                    <span class="n">pa</span> <span class="o">=</span> <span class="s1">&#39;**&#39;</span> <span class="o">+</span> <span class="n">mobjDict</span><span class="p">[</span><span class="s1">&#39;power_a&#39;</span><span class="p">]</span>
                                <span class="k">else</span><span class="p">:</span>
                                    <span class="n">pa</span> <span class="o">=</span> <span class="s1">&#39;&#39;</span>
                                <span class="k">if</span> <span class="n">mobjDict</span><span class="p">[</span><span class="s1">&#39;power_b&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">isdigit</span><span class="p">(</span> <span class="p">):</span>
                                    <span class="n">pb</span> <span class="o">=</span> <span class="s1">&#39;**&#39;</span> <span class="o">+</span> <span class="n">mobjDict</span><span class="p">[</span><span class="s1">&#39;power_b&#39;</span><span class="p">]</span>
                                <span class="k">else</span><span class="p">:</span>
                                    <span class="n">pb</span> <span class="o">=</span> <span class="s1">&#39;&#39;</span>
                                <span class="k">raise</span> <span class="n">RankError</span><span class="p">(</span> <span class="s1">&#39;`</span><span class="si">%s%s</span><span class="s1">` and `</span><span class="si">%s%s</span><span class="s1">` consist of&#39;</span>
                                      <span class="s1">&#39; the same set of dummy terms.  The &#39;</span>
                                      <span class="s1">&#39;mathDict( ) matrix already has `</span><span class="si">%s</span><span class="s1">`, &#39;</span>
                                      <span class="s1">&#39;which also consists of the same dummy &#39;</span>
                                      <span class="s1">&#39;terms.&#39;</span>
                                      <span class="o">%</span> <span class="p">(</span><span class="n">mobjDict</span><span class="p">[</span><span class="s1">&#39;column_a&#39;</span><span class="p">],</span> <span class="n">pa</span><span class="p">,</span>
                                         <span class="n">mobjDict</span><span class="p">[</span><span class="s1">&#39;column_b&#39;</span><span class="p">],</span> <span class="n">pb</span><span class="p">,</span>
                                         <span class="n">col</span><span class="p">)</span> <span class="p">)</span>
            <span class="k">for</span> <span class="n">l</span> <span class="ow">in</span> <span class="p">[</span><span class="s1">&#39;a&#39;</span><span class="p">,</span> <span class="s1">&#39;b&#39;</span><span class="p">]:</span>
                <span class="k">if</span> <span class="n">mobjDict</span><span class="p">[</span><span class="s1">&#39;power_&#39;</span><span class="o">+</span><span class="n">l</span><span class="p">]</span><span class="o">.</span><span class="n">isdigit</span><span class="p">(</span> <span class="p">)</span> <span class="ow">and</span> \
                   <span class="nb">int</span><span class="p">(</span> <span class="n">mobjDict</span><span class="p">[</span><span class="s1">&#39;power_&#39;</span><span class="o">+</span><span class="n">l</span><span class="p">]</span> <span class="p">)</span> <span class="o">&gt;=</span> <span class="mi">2</span><span class="p">:</span>
                    <span class="n">checkRank</span><span class="p">(</span> <span class="n">mobjDict</span><span class="p">[</span><span class="s1">&#39;column_&#39;</span><span class="o">+</span><span class="n">l</span><span class="p">],</span> <span class="n">column</span> <span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">hypothesis</span><span class="p">[</span><span class="n">column</span><span class="p">]</span> <span class="o">=</span> <span class="n">hypothesis</span></div>

<div class="viewcode-block" id="mathDictHypothesis.make"><a class="viewcode-back" href="../ParallelRegression.html#ParallelRegression.mathDictHypothesis.make">[docs]</a>    <span class="k">def</span> <span class="nf">make</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&#39;&#39;&#39;Returns a tuple consisting of the X matrix, R matrix, and r column</span>
<span class="sd">        vector/vertical array, each in the form of a two-dimensional numpy</span>
<span class="sd">        array.</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="n">X</span><span class="p">,</span> <span class="n">R</span><span class="p">,</span> <span class="n">r</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_make</span><span class="p">(</span> <span class="p">)</span>
        <span class="k">return</span><span class="p">(</span> <span class="n">X</span><span class="p">[:],</span> <span class="n">R</span><span class="p">,</span> <span class="n">r</span> <span class="p">)</span></div>

    <span class="k">def</span> <span class="nf">_get_X</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">X</span><span class="p">,</span> <span class="n">R</span><span class="p">,</span> <span class="n">r</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_make</span><span class="p">(</span> <span class="p">)</span>
        <span class="k">return</span><span class="p">(</span> <span class="n">X</span> <span class="p">)</span>

    <span class="k">def</span> <span class="nf">_make</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">superset_only</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span> <span class="p">)</span>
        <span class="n">rt_orig</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span> <span class="p">)</span>
        <span class="n">rt_superset_only</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span> <span class="p">)</span>
        <span class="k">for</span> <span class="n">key</span><span class="p">,</span> <span class="n">val</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">hypothesis</span><span class="o">.</span><span class="n">items</span><span class="p">(</span> <span class="p">):</span>
            <span class="k">if</span> <span class="n">key</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">mathDict</span><span class="o">.</span><span class="n">columns</span><span class="p">:</span>
                <span class="n">rt_orig</span><span class="o">.</span><span class="n">append</span><span class="p">(</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">mathDict</span><span class="o">.</span><span class="n">columns</span><span class="o">.</span><span class="n">index</span><span class="p">(</span> <span class="n">key</span> <span class="p">),</span> <span class="n">val</span><span class="p">)</span> <span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">rt_superset_only</span><span class="o">.</span><span class="n">append</span><span class="p">(</span> <span class="p">(</span><span class="nb">len</span><span class="p">(</span> <span class="n">superset_only</span> <span class="p">),</span> <span class="n">val</span><span class="p">)</span> <span class="p">)</span>
                <span class="k">if</span> <span class="n">key</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">mathDict</span><span class="o">.</span><span class="n">_column_names</span><span class="p">:</span>    <span class="c1">#</span>
                    <span class="c1">###########################################################</span>
                    <span class="c1">## `**1` so that it extends the matrix to the right with  #</span>
                    <span class="c1">##  the calculated columns, instead of getting inserted   #</span>
                    <span class="n">superset_only</span><span class="o">.</span><span class="n">append</span><span class="p">(</span> <span class="s1">&#39;</span><span class="si">%s</span><span class="s1">**1&#39;</span> <span class="o">%</span> <span class="n">key</span> <span class="p">)</span> <span class="c1">## in the middle.   #</span>
                <span class="k">else</span><span class="p">:</span> <span class="c1">#########################################################</span>
                    <span class="n">superset_only</span><span class="o">.</span><span class="n">append</span><span class="p">(</span> <span class="n">key</span> <span class="p">)</span>
        <span class="c1"># Build X</span>
        <span class="n">X</span> <span class="o">=</span> <span class="n">mathDict</span><span class="p">(</span> <span class="bp">self</span><span class="o">.</span><span class="n">mathDict</span><span class="o">.</span><span class="n">buffer</span><span class="p">,</span>
                      <span class="bp">self</span><span class="o">.</span><span class="n">mathDict</span><span class="o">.</span><span class="n">items</span><span class="p">,</span>
                      <span class="bp">self</span><span class="o">.</span><span class="n">mathDict</span><span class="o">.</span><span class="n">_column_names</span><span class="p">,</span>
                      <span class="bp">self</span><span class="o">.</span><span class="n">mathDict</span><span class="o">.</span><span class="n">_mask</span><span class="p">,</span>
                      <span class="bp">self</span><span class="o">.</span><span class="n">mathDict</span><span class="o">.</span><span class="n">dtypes</span><span class="p">,</span>
                      <span class="bp">self</span><span class="o">.</span><span class="n">mathDict</span><span class="o">.</span><span class="n">calculated_columns</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span> <span class="p">),</span>
                      <span class="bp">self</span><span class="o">.</span><span class="n">mathDict</span><span class="o">.</span><span class="n">cache_crossproducts</span><span class="p">,</span>
                      <span class="bp">self</span><span class="o">.</span><span class="n">mathDict</span><span class="o">.</span><span class="n">cache_powers</span><span class="p">,</span>
                      <span class="n">max_lag</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">mathDict</span><span class="o">.</span><span class="n">max_lag</span> <span class="p">)</span>
        <span class="n">X</span><span class="o">.</span><span class="n">local_mask</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">mathDict</span><span class="o">.</span><span class="n">local_mask</span>
        <span class="n">X</span><span class="o">.</span><span class="n">local</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">mathDict</span><span class="o">.</span><span class="n">local</span>
        <span class="n">X</span><span class="o">.</span><span class="n">calculated_columns</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span> <span class="n">superset_only</span> <span class="p">)</span>
        <span class="c1"># Build R, r</span>
        <span class="n">Z</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">mathDict</span><span class="o">.</span><span class="n">columns</span><span class="p">)</span> <span class="o">+</span> <span class="nb">len</span><span class="p">(</span> <span class="n">superset_only</span> <span class="p">)),</span>
                       <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">dtype</span><span class="p">(</span> <span class="n">PR_NP_INT</span> <span class="p">)</span> <span class="p">)</span>
        <span class="n">R</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros_like</span><span class="p">(</span> <span class="n">Z</span> <span class="p">)</span>
        <span class="n">r</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span> <span class="p">(</span><span class="nb">len</span><span class="p">(</span> <span class="n">rt_orig</span> <span class="p">)</span> <span class="o">+</span> <span class="nb">len</span><span class="p">(</span> <span class="n">rt_superset_only</span> <span class="p">)),</span>
                      <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">dtype</span><span class="p">(</span> <span class="n">PR_NP_INT</span> <span class="p">)</span> <span class="p">)</span>
        <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span> <span class="nb">len</span><span class="p">(</span> <span class="n">rt_orig</span> <span class="p">)</span> <span class="p">):</span>
            <span class="n">RX</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros_like</span><span class="p">(</span> <span class="n">Z</span> <span class="p">)</span>
            <span class="n">i</span><span class="p">,</span> <span class="n">v</span> <span class="o">=</span> <span class="n">rt_orig</span><span class="p">[</span><span class="n">j</span><span class="p">]</span>
            <span class="n">RX</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>
            <span class="n">R</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">(</span> <span class="p">(</span><span class="n">R</span><span class="p">,</span> <span class="n">RX</span><span class="p">)</span> <span class="p">)</span>
            <span class="n">r</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">v</span>
        <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span> <span class="nb">len</span><span class="p">(</span> <span class="n">rt_superset_only</span> <span class="p">)</span> <span class="p">):</span>
            <span class="n">RX</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros_like</span><span class="p">(</span> <span class="n">Z</span> <span class="p">)</span>
            <span class="n">i</span><span class="p">,</span> <span class="n">v</span> <span class="o">=</span> <span class="n">rt_superset_only</span><span class="p">[</span><span class="n">j</span><span class="p">]</span>
            <span class="n">RX</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="bp">self</span><span class="o">.</span><span class="n">mathDict</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>
            <span class="n">R</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">(</span> <span class="p">(</span><span class="n">R</span><span class="p">,</span> <span class="n">RX</span><span class="p">)</span> <span class="p">)</span>
            <span class="n">r</span><span class="p">[</span><span class="nb">len</span><span class="p">(</span> <span class="n">rt_orig</span> <span class="p">)</span> <span class="o">+</span> <span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">v</span>
        <span class="k">return</span><span class="p">(</span> <span class="n">X</span><span class="p">,</span> <span class="n">R</span><span class="p">[</span><span class="mi">1</span><span class="p">:,:],</span> <span class="n">r</span> <span class="p">)</span></div>

<div class="viewcode-block" id="mathDictConfig"><a class="viewcode-back" href="../ParallelRegression.html#ParallelRegression.mathDictConfig">[docs]</a><span class="k">class</span> <span class="nc">mathDictConfig</span><span class="p">(</span><span class="nb">dict</span><span class="p">):</span>
<div class="viewcode-block" id="mathDictConfig.rebuild"><a class="viewcode-back" href="../ParallelRegression.html#ParallelRegression.mathDictConfig.rebuild">[docs]</a>    <span class="k">def</span> <span class="nf">rebuild</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">SharedDataArray</span> <span class="p">):</span>
        <span class="sd">&#39;&#39;&#39;Recreates the mathDict( ) object whose configuration is stored in</span>
<span class="sd">        this dict( ).  Requires that the shared data array is provided as a</span>
<span class="sd">        parameter.</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="n">MD</span> <span class="o">=</span> <span class="n">mathDict</span><span class="p">(</span> <span class="n">SharedDataArray</span><span class="o">=</span><span class="n">SharedDataArray</span><span class="p">,</span>
                       <span class="n">items</span><span class="o">=</span><span class="bp">self</span><span class="p">[</span><span class="s1">&#39;items&#39;</span><span class="p">],</span>
                       <span class="n">column_names</span><span class="o">=</span><span class="bp">self</span><span class="p">[</span><span class="s1">&#39;_column_names&#39;</span><span class="p">],</span>
                       <span class="n">mask</span><span class="o">=</span><span class="n">deepcopy</span><span class="p">(</span> <span class="bp">self</span><span class="p">[</span><span class="s1">&#39;mask&#39;</span><span class="p">]</span> <span class="p">),</span>
                       <span class="n">dtypes</span><span class="o">=</span><span class="bp">self</span><span class="p">[</span><span class="s1">&#39;dtypes&#39;</span><span class="p">],</span>
                       <span class="n">calculated_columns</span><span class="o">=</span><span class="n">deepcopy</span><span class="p">(</span>
                                                  <span class="bp">self</span><span class="p">[</span><span class="s1">&#39;calculated_columns&#39;</span><span class="p">]</span> <span class="p">),</span>
                       <span class="n">cache_crossproducts</span><span class="o">=</span><span class="bp">self</span><span class="p">[</span><span class="s1">&#39;cache_crossproducts&#39;</span><span class="p">],</span>
                       <span class="n">cache_powers</span><span class="o">=</span><span class="bp">self</span><span class="p">[</span><span class="s1">&#39;cache_powers&#39;</span><span class="p">],</span>
                       <span class="n">max_lag</span><span class="o">=</span><span class="bp">self</span><span class="p">[</span><span class="s1">&#39;max_lag&#39;</span><span class="p">],</span>
                       <span class="n">terms</span><span class="o">=</span><span class="bp">self</span><span class="p">[</span><span class="s1">&#39;terms&#39;</span><span class="p">]</span> <span class="p">)</span>
        <span class="k">return</span><span class="p">(</span> <span class="n">MD</span> <span class="p">)</span></div></div>


<div class="viewcode-block" id="mathDict"><a class="viewcode-back" href="../ParallelRegression.html#ParallelRegression.mathDict">[docs]</a><span class="k">class</span> <span class="nc">mathDict</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
<div class="viewcode-block" id="mathDict.__init__"><a class="viewcode-back" href="../ParallelRegression.html#ParallelRegression.mathDict.__init__">[docs]</a>    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">SharedDataArray</span><span class="p">,</span> <span class="n">items</span><span class="p">,</span> <span class="n">column_names</span><span class="p">,</span>
                 <span class="n">mask</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                 <span class="n">dtypes</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                 <span class="n">calculated_columns</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                 <span class="n">cache_crossproducts</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                 <span class="n">cache_powers</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span>
                 <span class="n">max_lag</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span>
                 <span class="n">terms</span> <span class="o">=</span> <span class="kc">None</span> <span class="p">):</span>
        <span class="sd">&#39;&#39;&#39;dict( )-like interface to a shared-memory, two-dimensional array of</span>
<span class="sd">        heterogenous numeric data-typed columns that builds linear constraints/</span>
<span class="sd">        hypotheses and pre-calculates powers and cross-products of columns.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        SharedDataArray : multiprocessing.sharedctypes.RawArray or comparable</span>
<span class="sd">            The shared-memory byte array in which the columns and pre-</span>
<span class="sd">            calculated manipulations thereof are stored.  See the note</span>
<span class="sd">            regarding array length.</span>
<span class="sd">        items : int</span>
<span class="sd">            The number of cells in the matrix of original columns, not</span>
<span class="sd">            including the intercept column or calculated columns.  All columns</span>
<span class="sd">            must be supplied to mathDict( ) with the same number of rows.</span>
<span class="sd">        column_names : sequence of strings</span>
<span class="sd">            The names of the original columns, not including the intercept</span>
<span class="sd">            column or calculated columns.  There must be exactly one string in</span>
<span class="sd">            column_name for each column in the matrix of original columns.</span>
<span class="sd">        mask : sequence of booleans, optional</span>
<span class="sd">            Columns with an associated mask boolean of True are hidden.  The</span>
<span class="sd">            first boolean in the sequence is associated with the intercept</span>
<span class="sd">            column, resulting in a column of ones at index 0 if set to False.</span>
<span class="sd">            After that, the value at mask[1] corresponds to column_name[0], and</span>
<span class="sd">            so on.  If the mask sequence is shorter than the sequence of</span>
<span class="sd">            column_names, than columns without an associated mask value are</span>
<span class="sd">            unmasked.</span>
<span class="sd">        dtypes : string or Sequence, optional</span>
<span class="sd">            If a sequence, there must be one value for each column,</span>
<span class="sd">            representing the numpy data type of the cells in that column.  If a</span>
<span class="sd">            single string, then all columns must consist of cells of that data</span>
<span class="sd">            type.  Currently only 8-byte-per-item data types (&#39;i8&#39;, &#39;f8&#39;) are</span>
<span class="sd">            suported.</span>
<span class="sd">        calculated_columns : sequence of strings</span>
<span class="sd">            Each string represents a column that extends the matrix represented</span>
<span class="sd">            by the mathDict( ) beyond the matrix of original columns with a</span>
<span class="sd">            column calculated therefrom using operations supported by</span>
<span class="sd">            mathDict( ).  Currently limited to crossproducts, powers, and lags.</span>
<span class="sd">        cache_crossproducts : boolean, optional</span>
<span class="sd">            If True, then the crossproducts of each combination (without</span>
<span class="sd">            replacement) of columns in the matrix of original columns has been</span>
<span class="sd">            pre-calculated and appended to the shared data array after the</span>
<span class="sd">            original columns.  Use mathDictMaker( ) to pre-calculate these</span>
<span class="sd">            values.</span>
<span class="sd">        cache_powers : int, optional</span>
<span class="sd">            If set to an integer greater than 1, then the powers of each</span>
<span class="sd">            original column ranging from 2 through this value (inclusive) have</span>
<span class="sd">            been pre-calculated and appended to the shared data array after the</span>
<span class="sd">            original columns and cached crossproducts (if present).  Use</span>
<span class="sd">            mathDictMaker( ) to pre-calculate these values.</span>
<span class="sd">        max_lag : int, optional</span>
<span class="sd">            Sets the maximum number of lags to be supported.  Rows zero through</span>
<span class="sd">            `max_lag` - 1 will be hidden in order to provide the data for the</span>
<span class="sd">            lags.</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        Size of `SharedDataArray`: The shared-memory array identified by the</span>
<span class="sd">        shared data array parameter stores each column in the matrix of</span>
<span class="sd">        original columns, in column-major order, followed by each pre-</span>
<span class="sd">        calculated crossproduct column (if present) and pre-calculated power</span>
<span class="sd">        column (if present).  With 8-byte-per-item data types, the matrix of</span>
<span class="sd">        original columns alone requires 8*[row count]*[column count].</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">buffer</span> <span class="o">=</span> <span class="n">SharedDataArray</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">items</span> <span class="o">=</span> <span class="n">items</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_column_names</span> <span class="o">=</span> <span class="n">column_names</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">cache_crossproducts</span> <span class="o">=</span> <span class="n">cache_crossproducts</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">cache_powers</span> <span class="o">=</span> <span class="n">cache_powers</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">itemsize</span> <span class="o">=</span> <span class="n">PR_BYTESIZE</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">hypothesis</span> <span class="o">=</span> <span class="n">mathDictHypothesis</span><span class="p">(</span> <span class="bp">self</span> <span class="p">)</span>
        <span class="c1">#######################################################################</span>
        <span class="c1">## Setting self.local to dict( ) before setting it to mathDataStore( )#</span>
        <span class="c1">## avoids an error that would otherwise result from a chicken-or-the- #</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">local</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span> <span class="p">)</span> <span class="c1">## egg problem.                                  #</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">local</span> <span class="o">=</span> <span class="n">mathDataStore</span><span class="p">(</span> <span class="n">mathDict</span><span class="o">=</span><span class="bp">self</span> <span class="p">)</span>                           <span class="c1">#</span>
        <span class="c1">#######################################################################</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">local_mask</span> <span class="o">=</span> <span class="n">setList</span><span class="p">(</span> <span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">max_lag</span> <span class="o">=</span> <span class="n">max_lag</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">terms</span> <span class="o">=</span> <span class="n">terms</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">strings_checked</span> <span class="o">=</span> <span class="n">setList</span><span class="p">(</span> <span class="p">)</span>
        <span class="k">if</span> <span class="n">calculated_columns</span> <span class="o">==</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">calculated_columns</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">calculated_columns</span> <span class="o">=</span> <span class="n">calculated_columns</span>
        <span class="k">if</span> <span class="n">mask</span> <span class="o">==</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">mask</span> <span class="o">=</span> <span class="p">[</span><span class="kc">False</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_mask</span> <span class="o">=</span> <span class="n">mask</span>
        <span class="k">if</span> <span class="n">dtypes</span> <span class="o">==</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">dtypes</span> <span class="o">=</span> <span class="n">PR_NP_FLT</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span> <span class="n">dtypes</span><span class="p">,</span> <span class="nb">str</span> <span class="p">):</span>
            <span class="n">dtypes</span> <span class="o">=</span> <span class="p">[</span><span class="n">dtypes</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">column_names</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">dtypes</span> <span class="o">=</span> <span class="n">dtypes</span></div>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">columns</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&#39;&#39;&#39;list of strings: Lists the name of each column in the matrix</span>
<span class="sd">        represented by the mathDict( ), starting with the Intercept column</span>
<span class="sd">        unless masked, followed by columns in the matrix of original columns</span>
<span class="sd">        that are not masked, by local columns, and finally by calculated</span>
<span class="sd">        columns.</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="n">ret</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span> <span class="p">)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_mask</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="kc">False</span><span class="p">:</span>
            <span class="n">ret</span><span class="o">.</span><span class="n">append</span><span class="p">(</span> <span class="s1">&#39;Intercept&#39;</span> <span class="p">)</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span> <span class="nb">len</span><span class="p">(</span> <span class="bp">self</span><span class="o">.</span><span class="n">_column_names</span> <span class="p">)</span> <span class="p">):</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span> <span class="o">&lt;</span> <span class="nb">len</span><span class="p">(</span> <span class="bp">self</span><span class="o">.</span><span class="n">_mask</span> <span class="p">)</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">_mask</span><span class="p">[</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="kc">False</span><span class="p">)</span> <span class="ow">or</span> \
               <span class="n">i</span><span class="o">+</span><span class="mi">1</span> <span class="o">&gt;=</span> <span class="nb">len</span><span class="p">(</span> <span class="bp">self</span><span class="o">.</span><span class="n">_mask</span> <span class="p">):</span>
                <span class="n">ret</span><span class="o">.</span><span class="n">append</span><span class="p">(</span> <span class="bp">self</span><span class="o">.</span><span class="n">_column_names</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="p">)</span>
        <span class="k">for</span> <span class="n">key</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">local</span><span class="o">.</span><span class="n">key_list</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">key</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">local_mask</span><span class="p">:</span>
                <span class="n">ret</span><span class="o">.</span><span class="n">append</span><span class="p">(</span> <span class="n">key</span> <span class="p">)</span>
        <span class="n">ret</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span> <span class="bp">self</span><span class="o">.</span><span class="n">calculated_columns</span> <span class="p">)</span>
        <span class="k">return</span><span class="p">(</span> <span class="n">ret</span> <span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">rows</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&#39;&#39;&#39;The number of rows in the matrix of original columns.&#39;&#39;&#39;</span>
        <span class="k">return</span><span class="p">(</span> <span class="bp">self</span><span class="o">.</span><span class="n">items</span> <span class="o">//</span> <span class="nb">len</span><span class="p">(</span> <span class="bp">self</span><span class="o">.</span><span class="n">_column_names</span> <span class="p">)</span> <span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">shape</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&#39;&#39;&#39;tuple(effective row count, column count): The effective row count</span>
<span class="sd">        will be listed even if all columns are masked, resulting in an (n, 0)</span>
<span class="sd">        tuple.</span>

<span class="sd">        Effective row count: The number of rows in the matrix of original</span>
<span class="sd">        columns, less the maximum lag that the mathDict( ) has been configured</span>
<span class="sd">        to support.</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="n">r</span>  <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">rows</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">max_lag</span>
        <span class="n">c</span>  <span class="o">=</span> <span class="nb">len</span><span class="p">(</span> <span class="bp">self</span><span class="o">.</span><span class="n">_column_names</span> <span class="p">)</span> <span class="o">+</span> <span class="mi">1</span>
        <span class="n">c</span> <span class="o">-=</span> <span class="nb">sum</span><span class="p">(</span> <span class="bp">self</span><span class="o">.</span><span class="n">_mask</span> <span class="p">)</span>
        <span class="n">c</span> <span class="o">+=</span> <span class="nb">len</span><span class="p">(</span> <span class="bp">self</span><span class="o">.</span><span class="n">calculated_columns</span> <span class="p">)</span>
        <span class="n">c</span> <span class="o">+=</span> <span class="nb">len</span><span class="p">(</span> <span class="bp">self</span><span class="o">.</span><span class="n">local</span> <span class="p">)</span>
        <span class="n">c</span> <span class="o">-=</span> <span class="nb">len</span><span class="p">(</span> <span class="bp">self</span><span class="o">.</span><span class="n">local_mask</span> <span class="p">)</span>
        <span class="k">return</span><span class="p">(</span> <span class="n">r</span><span class="p">,</span> <span class="n">c</span> <span class="p">)</span>

<div class="viewcode-block" id="mathDict.__getitem__"><a class="viewcode-back" href="../ParallelRegression.html#ParallelRegression.mathDict.__getitem__">[docs]</a>    <span class="k">def</span> <span class="nf">__getitem__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">index</span><span class="p">,</span> <span class="n">vector</span><span class="o">=</span><span class="s1">&#39;column&#39;</span> <span class="p">):</span>
        <span class="sd">&#39;&#39;&#39;Returns the matrix represented by the mathDict( ) or a portion</span>
<span class="sd">        thereof.</span>

<span class="sd">        **Supported Notation**</span>

<span class="sd">        ------------------</span>
<span class="sd">        str -&gt; returns one vertical array</span>
<span class="sd">            A string can be the name of one column or the formula for one</span>
<span class="sd">            column that can be calculated from the original columns.  No check</span>
<span class="sd">            is performed to ensure that referenced columns are unmasked.</span>
<span class="sd">        int -&gt; returns one vertical array</span>
<span class="sd">            A single integer will return the corresponding column in the matrix</span>
<span class="sd">            represented by the mathDict( ) object.</span>
<span class="sd">        int(m):int(n) slice -&gt; returns a matrix with `n` - `m` columns.</span>
<span class="sd">            A slice with start and or stop specified will return the</span>
<span class="sd">            corresponding column in the matrix represented by the mathDict( ).</span>
<span class="sd">            A slice with neither specified will return the entire matrix</span>
<span class="sd">            represented by the mathDict( ).  This includes local columns and</span>
<span class="sd">            calculated_columns listed in the calculated_columns attribute, but</span>
<span class="sd">            does not include masked columns.</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        str : &#39;a&#39;</span>
<span class="sd">            Returns column &#39;a&#39;.</span>
<span class="sd">        str : &#39;a * b&#39;</span>
<span class="sd">            Returns a column in which each row i is &#39;a&#39;[i] * &#39;b&#39;[i].</span>
<span class="sd">        str : &#39;L2@a&#39;</span>
<span class="sd">            Returns the second lag of column &#39;a&#39;.  (Case sensitive.)</span>
<span class="sd">        int : 0</span>
<span class="sd">            If the first value in the mask sequence is False, this will return</span>
<span class="sd">            a column of ones.  The data type of cells in the Intercept column</span>
<span class="sd">            will match the first column in the matrix of original columns.</span>
<span class="sd">        slice : [:]</span>
<span class="sd">            This will return the Intercept column of ones unless masked,</span>
<span class="sd">            unmasked columns in the matrix of original columns, unmasked local</span>
<span class="sd">            columns, and finally calculated columns.</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="n">INTERNAL_NOTES</span>  <span class="o">=</span> <span class="s1">&#39;&#39;&#39;</span>
<span class="s1">        Parameters</span>
<span class="s1">        ----------</span>
<span class="s1">        index : int, slice, or str</span>
<span class="s1">            See above.</span>
<span class="s1">        vector : {&#39;column&#39;, &#39;row&#39;}, optional</span>
<span class="s1">            Passed on to column retrieval methods when used by ._mat( ) to get</span>
<span class="s1">            calculated columns.</span>

<span class="s1">        Notes</span>
<span class="s1">        -----</span>
<span class="s1">        All logic translating column numbers in the matrix represented by the</span>
<span class="s1">        mathDict( ) to index numbers/keys of stored columns is contained here.</span>
<span class="s1">        &#39;&#39;&#39;</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span> <span class="n">index</span><span class="p">,</span> <span class="nb">str</span> <span class="p">):</span>
            <span class="n">masked_index</span> <span class="o">=</span> <span class="n">mask_brackets</span><span class="p">(</span> <span class="n">index</span> <span class="p">)</span>
            <span class="n">mobj_cross_simple</span> <span class="o">=</span> <span class="n">crosspattern</span><span class="o">.</span><span class="n">fullmatch</span><span class="p">(</span> <span class="n">masked_index</span> <span class="p">)</span>
            <span class="k">if</span> <span class="n">mobj_cross_simple</span> <span class="o">!=</span> <span class="kc">None</span><span class="p">:</span>
                <span class="k">return</span><span class="p">(</span> <span class="bp">self</span><span class="o">.</span><span class="n">crossproduct</span><span class="p">(</span> <span class="n">vector</span><span class="o">=</span><span class="n">vector</span><span class="p">,</span>
                                  <span class="o">**</span><span class="n">masked_dict</span><span class="p">(</span> <span class="n">index</span><span class="p">,</span> <span class="n">mobj_cross_simple</span> <span class="p">)</span> <span class="p">)</span> <span class="p">)</span>
            <span class="n">mobj_cross</span> <span class="o">=</span> <span class="n">crosspower</span><span class="o">.</span><span class="n">fullmatch</span><span class="p">(</span> <span class="n">masked_index</span> <span class="p">)</span>
            <span class="k">if</span> <span class="n">mobj_cross</span> <span class="o">!=</span> <span class="kc">None</span><span class="p">:</span>
                <span class="k">return</span><span class="p">(</span> <span class="bp">self</span><span class="o">.</span><span class="n">crosspower</span><span class="p">(</span> <span class="n">vector</span><span class="o">=</span><span class="n">vector</span><span class="p">,</span>
                                         <span class="o">**</span><span class="n">masked_dict</span><span class="p">(</span> <span class="n">index</span><span class="p">,</span> <span class="n">mobj_cross</span> <span class="p">)</span> <span class="p">)</span> <span class="p">)</span>
            <span class="n">mobj_power</span> <span class="o">=</span> <span class="n">powerpattern</span><span class="o">.</span><span class="n">fullmatch</span><span class="p">(</span> <span class="n">masked_index</span> <span class="p">)</span>
            <span class="k">if</span> <span class="n">mobj_power</span> <span class="o">!=</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">mobj_dict</span> <span class="o">=</span> <span class="n">masked_dict</span><span class="p">(</span> <span class="n">index</span><span class="p">,</span> <span class="n">mobj_power</span> <span class="p">)</span>
                <span class="k">if</span> <span class="n">mobj_dict</span><span class="p">[</span><span class="s1">&#39;lag&#39;</span><span class="p">]</span> <span class="ow">not</span> <span class="ow">in</span> <span class="p">{</span><span class="kc">None</span><span class="p">,</span> <span class="s1">&#39;&#39;</span><span class="p">}:</span>
                    <span class="n">mobj_dict</span><span class="p">[</span><span class="s1">&#39;lag&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span> <span class="n">mobj_dict</span><span class="p">[</span><span class="s1">&#39;lag&#39;</span><span class="p">]</span> <span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">mobj_dict</span><span class="p">[</span><span class="s1">&#39;lag&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>
                <span class="k">if</span> <span class="n">mobj_dict</span><span class="p">[</span><span class="s1">&#39;power&#39;</span><span class="p">]</span> <span class="ow">in</span> <span class="p">{</span><span class="kc">None</span><span class="p">,</span> <span class="s1">&#39;&#39;</span><span class="p">}:</span>
                    <span class="k">return</span><span class="p">(</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_column</span><span class="p">(</span> <span class="n">mobj_dict</span><span class="p">[</span><span class="s1">&#39;column_name&#39;</span><span class="p">],</span>
                                             <span class="n">lag</span><span class="o">=</span><span class="n">mobj_dict</span><span class="p">[</span><span class="s1">&#39;lag&#39;</span><span class="p">],</span>
                                             <span class="n">vector</span><span class="o">=</span><span class="n">vector</span> <span class="p">)</span> <span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="k">return</span><span class="p">(</span> <span class="bp">self</span><span class="o">.</span><span class="n">power</span><span class="p">(</span> <span class="n">vector</span><span class="o">=</span><span class="n">vector</span><span class="p">,</span> <span class="o">**</span><span class="n">mobj_dict</span> <span class="p">)</span> <span class="p">)</span>
            <span class="k">raise</span> <span class="n">mathDictKeyError</span><span class="p">(</span>  <span class="s1">&#39;</span><span class="si">%s</span><span class="s1"> is not a valid key.&#39;</span> <span class="o">%</span> <span class="n">index</span>  <span class="p">)</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span> <span class="n">index</span><span class="p">,</span> <span class="nb">int</span> <span class="p">):</span>
            <span class="k">if</span> <span class="n">index</span> <span class="o">==</span> <span class="mi">0</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">_mask</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="kc">False</span><span class="p">:</span>
                <span class="k">return</span><span class="p">(</span> <span class="bp">self</span><span class="o">.</span><span class="n">power</span><span class="p">(</span> <span class="bp">self</span><span class="o">.</span><span class="n">_column_names</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="mi">0</span><span class="p">,</span> <span class="n">vector</span><span class="o">=</span><span class="n">vector</span> <span class="p">)</span> <span class="p">)</span>
            <span class="n">index</span> <span class="o">=</span> <span class="nb">slice</span><span class="p">(</span> <span class="n">index</span><span class="p">,</span> <span class="n">index</span><span class="o">+</span><span class="mi">1</span> <span class="p">)</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span> <span class="n">index</span><span class="p">,</span> <span class="nb">slice</span> <span class="p">):</span>
            <span class="k">if</span> <span class="n">index</span><span class="o">.</span><span class="n">step</span> <span class="o">!=</span> <span class="kc">None</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">KeyError</span><span class="p">(</span> <span class="s1">&#39;Steps are not supported&#39;</span> <span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">xes</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span> <span class="p">)</span> <span class="c1">#.................... xes = list of all colums to</span>
                                                  <span class="c1"># return as part of the slice</span>
                <span class="n">ind</span> <span class="o">=</span> <span class="mi">0</span> <span class="c1">#.......................... ind = index of the column</span>
                                                  <span class="c1"># in the matrix represented</span>
                                                  <span class="c1"># by the mathDict( ) object</span>
                                                  <span class="c1"># that is currently being</span>
                                                  <span class="c1"># identified</span>
                <span class="c1">## val_if_present( ) replaces None with the default, whereas</span>
                <span class="c1">## getattr( ) does not.</span>
                <span class="n">start</span> <span class="o">=</span> <span class="n">val_if_present</span><span class="p">(</span> <span class="n">index</span><span class="p">,</span> <span class="s1">&#39;start&#39;</span><span class="p">,</span> <span class="mi">0</span> <span class="p">)</span>
                <span class="n">stop</span> <span class="o">=</span> <span class="n">val_if_present</span><span class="p">(</span> <span class="n">index</span><span class="p">,</span> <span class="s1">&#39;stop&#39;</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="p">)</span>
                <span class="k">if</span> <span class="n">stop</span> <span class="o">&gt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]:</span>
                    <span class="k">raise</span> <span class="ne">IndexError</span><span class="p">(</span> <span class="s1">&#39;Outer-bound of slice, </span><span class="si">%d</span><span class="s1">, exceeds the &#39;</span>
                                      <span class="s1">&#39;number of columns, </span><span class="si">%d</span><span class="s1">.&#39;</span>
                                      <span class="o">%</span> <span class="p">(</span><span class="n">stop</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span> <span class="p">)</span>
                <span class="c1">###############################################################</span>
                <span class="c1">## Except here, ind is incremented when a column is determined#</span>
                <span class="c1">## to be part of the matrix.  ind = n after original matrix   #</span>
                <span class="c1">## columns 0, 1, ..., n-1 if all are unmasked.  If there are  #</span>
                <span class="c1">## n+1 columns including the Intercept, then ind = n is the   #</span>
                <span class="c1">## correct stopping point, and the Intercept column still has #</span>
                <span class="c1">## to get included.                                           #</span>
                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_mask</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="kc">False</span><span class="p">:</span>                                   <span class="c1">##</span>
                    <span class="n">stop</span> <span class="o">-=</span> <span class="mi">1</span>                                                <span class="c1">##</span>
                    <span class="k">if</span> <span class="n">start</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>                                           <span class="c1">##</span>
                        <span class="n">xes</span><span class="o">.</span><span class="n">append</span><span class="p">(</span> <span class="o">-</span><span class="mi">1</span> <span class="p">)</span>                                     <span class="c1">##</span>
                    <span class="k">else</span><span class="p">:</span>                                                    <span class="c1">##</span>
                        <span class="n">start</span> <span class="o">-=</span> <span class="mi">1</span>                                           <span class="c1">##</span>
                <span class="c1">###############################################################</span>
                <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span> <span class="nb">len</span><span class="p">(</span> <span class="bp">self</span><span class="o">.</span><span class="n">_column_names</span> <span class="p">)</span> <span class="p">):</span>
                    <span class="c1"># i = index of the original matrix column currently being</span>
                    <span class="c1"># considered</span>
                    <span class="k">if</span> <span class="n">i</span><span class="o">+</span><span class="mi">1</span> <span class="o">&gt;=</span> <span class="nb">len</span><span class="p">(</span> <span class="bp">self</span><span class="o">.</span><span class="n">_mask</span> <span class="p">)</span> <span class="ow">or</span> <span class="bp">self</span><span class="o">.</span><span class="n">_mask</span><span class="p">[</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="kc">False</span><span class="p">:</span>
                        <span class="k">if</span> <span class="n">ind</span> <span class="o">&gt;=</span> <span class="n">start</span> <span class="ow">and</span> <span class="n">ind</span> <span class="o">&lt;</span> <span class="n">stop</span><span class="p">:</span>
                            <span class="n">xes</span><span class="o">.</span><span class="n">append</span><span class="p">(</span> <span class="n">i</span> <span class="p">)</span> <span class="c1"># Adding original column index int</span>
                        <span class="n">ind</span> <span class="o">+=</span> <span class="mi">1</span>
                        <span class="k">if</span> <span class="n">ind</span> <span class="o">==</span> <span class="n">stop</span><span class="p">:</span>
                            <span class="k">break</span>
                <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span> <span class="nb">len</span><span class="p">(</span> <span class="bp">self</span><span class="o">.</span><span class="n">local</span><span class="o">.</span><span class="n">keys</span><span class="p">(</span> <span class="p">)</span> <span class="p">)</span> <span class="p">):</span>
                    <span class="c1"># i = index of the local column currently being considered</span>
                    <span class="k">if</span> <span class="n">ind</span> <span class="o">==</span> <span class="n">stop</span><span class="p">:</span>
                        <span class="k">break</span>
                    <span class="n">key</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">local</span><span class="o">.</span><span class="n">key_list</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
                    <span class="k">if</span> <span class="n">key</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">local_mask</span><span class="p">:</span>
                        <span class="k">if</span> <span class="n">ind</span> <span class="o">&gt;=</span> <span class="n">start</span> <span class="ow">and</span> <span class="n">ind</span> <span class="o">&lt;</span> <span class="n">stop</span><span class="p">:</span>
                            <span class="n">xes</span><span class="o">.</span><span class="n">append</span><span class="p">(</span> <span class="n">key</span> <span class="p">)</span> <span class="c1"># Adding local column key string</span>
                        <span class="n">ind</span> <span class="o">+=</span> <span class="mi">1</span>
                <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span> <span class="nb">len</span><span class="p">(</span> <span class="bp">self</span><span class="o">.</span><span class="n">calculated_columns</span> <span class="p">)</span> <span class="p">):</span>
                    <span class="c1"># i = index of the calculated column currently being</span>
                    <span class="c1"># considered</span>
                    <span class="k">if</span> <span class="n">ind</span> <span class="o">==</span> <span class="n">stop</span><span class="p">:</span>
                        <span class="k">break</span>
                    <span class="k">if</span> <span class="n">ind</span> <span class="o">&gt;=</span> <span class="n">start</span> <span class="ow">and</span> <span class="n">ind</span> <span class="o">&lt;</span> <span class="n">stop</span><span class="p">:</span>
                        <span class="n">xes</span><span class="o">.</span><span class="n">append</span><span class="p">(</span> <span class="bp">self</span><span class="o">.</span><span class="n">calculated_columns</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="p">)</span>
                               <span class="c1"># Adding calculated column string</span>
                    <span class="n">ind</span> <span class="o">+=</span> <span class="mi">1</span>
                <span class="k">return</span><span class="p">(</span> <span class="bp">self</span><span class="o">.</span><span class="n">_mat</span><span class="p">(</span> <span class="n">xes</span> <span class="p">)</span> <span class="p">)</span></div>

    <span class="k">def</span> <span class="nf">__setitem__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">key</span><span class="p">,</span> <span class="n">value</span> <span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">local</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="n">value</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">_ofs_start</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">numcols</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span> <span class="bp">self</span><span class="o">.</span><span class="n">_column_names</span> <span class="p">)</span>
        <span class="n">cp_len</span>  <span class="o">=</span> <span class="n">math</span><span class="o">.</span><span class="n">factorial</span><span class="p">(</span> <span class="n">numcols</span> <span class="p">)</span> \
                  <span class="o">//</span> <span class="mi">2</span> \
                  <span class="o">//</span> <span class="n">math</span><span class="o">.</span><span class="n">factorial</span><span class="p">(</span> <span class="n">numcols</span> <span class="o">-</span> <span class="mi">2</span> <span class="p">)</span>
        <span class="n">pwr_len</span> <span class="o">=</span> <span class="n">numcols</span> <span class="o">*</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">cache_powers</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span>
        <span class="n">cp_start</span><span class="p">,</span> <span class="n">pwr_start</span> <span class="o">=</span> <span class="n">numcols</span><span class="p">,</span> <span class="n">numcols</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">cache_crossproducts</span><span class="p">:</span>
            <span class="n">pwr_start</span> <span class="o">+=</span> <span class="n">cp_len</span>
        <span class="k">return</span><span class="p">(</span> <span class="n">cp_start</span><span class="p">,</span> <span class="n">pwr_start</span> <span class="p">)</span>

    <span class="k">def</span> <span class="nf">_ofs</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">internal_column_index</span><span class="p">,</span> <span class="n">lag</span><span class="o">=</span><span class="mi">0</span> <span class="p">):</span>
        <span class="sd">&#39;&#39;&#39;(for internal use).</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        interior_column_index : int</span>
<span class="sd">            the index number of the column in the shared data array, whether an</span>
<span class="sd">            original column or cached, calculated column.</span>
<span class="sd">        lag : int, optional</span>
<span class="sd">            This many rows towards the top of the matrix will be unhidden,</span>
<span class="sd">            without changing the total number of rows returned.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        the offset in the shared data array at which the column with the</span>
<span class="sd">        specified index number begins, adjusted to hide rows as necessary to</span>
<span class="sd">        reserve sufficient data for lags.  Error checking for appropriate lag</span>
<span class="sd">        values occurs in .vec( ) in order to have the same set of code apply to</span>
<span class="sd">        lagged local columns as well as lagged shared columns.</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="n">ofs</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">rows</span> <span class="o">*</span> <span class="n">internal_column_index</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">itemsize</span>
        <span class="n">ofs</span> <span class="o">+=</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">max_lag</span> <span class="o">-</span> <span class="n">lag</span><span class="p">)</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">itemsize</span>
        <span class="k">return</span><span class="p">(</span> <span class="n">ofs</span> <span class="p">)</span>

    <span class="k">def</span> <span class="nf">_vec</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">internal_column</span><span class="p">,</span> <span class="n">lag</span><span class="o">=</span><span class="mi">0</span> <span class="p">):</span>
        <span class="sd">&#39;&#39;&#39;(for internal use): returns the column of the shared data array at</span>
<span class="sd">        the requested index, in row vector/horizontal array form.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        internal_column : int or str</span>
<span class="sd">            Either an integer index for a column in the shared data array, or a</span>
<span class="sd">            string identifying either a column in the matrix of original</span>
<span class="sd">            columns or a local column by name.  Strings are accepted in order</span>
<span class="sd">            to allow calculated column retrieval methods to retrieve base</span>
<span class="sd">            columns via .get_column( ) without distinguishing between types.</span>
<span class="sd">        lag : int, optional</span>
<span class="sd">            (See ._ofs( ) docstring.)</span>

<span class="sd">        Special Values</span>
<span class="sd">        --------------</span>
<span class="sd">        - 1</span>
<span class="sd">            Returns `self[0]` for use representing the Intercept column in a</span>
<span class="sd">            list of column indexes.</span>

<span class="sd">        Raises</span>
<span class="sd">        ------</span>
<span class="sd">        ValueError</span>
<span class="sd">            If the requested lag exceeds self.max_lag.  The .max_lag attribute</span>
<span class="sd">            must be set prior to adding and/or retrieving columns involving</span>
<span class="sd">            lagged values.</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="k">if</span> <span class="n">lag</span> <span class="o">&gt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">max_lag</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span> <span class="s1">&#39;Requested lag of </span><span class="si">%d</span><span class="s1"> for column </span><span class="si">%s</span><span class="s1"> is greater &#39;</span>
                              <span class="s1">&#39;than the maximum lag </span><span class="si">%d</span><span class="s1">.&#39;</span>
                              <span class="o">%</span> <span class="p">(</span><span class="n">lag</span><span class="p">,</span> <span class="n">internal_column</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">max_lag</span><span class="p">)</span> <span class="p">)</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span> <span class="n">internal_column</span><span class="p">,</span> <span class="nb">str</span> <span class="p">):</span>
            <span class="k">if</span> <span class="n">internal_column</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_column_names</span><span class="p">:</span>
                <span class="n">internal_column</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_column_names</span><span class="o">.</span><span class="n">index</span><span class="p">(</span> <span class="n">internal_column</span> <span class="p">)</span>
            <span class="k">elif</span> <span class="n">internal_column</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">local</span><span class="o">.</span><span class="n">keys</span><span class="p">(</span> <span class="p">):</span>
                <span class="n">arr</span><span class="p">,</span> <span class="n">dt</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">local</span><span class="o">.</span><span class="n">_toBytes</span><span class="p">(</span> <span class="n">internal_column</span><span class="p">,</span> <span class="n">lag</span><span class="o">=</span><span class="n">lag</span> <span class="p">)</span>
                <span class="n">ret</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">fromstring</span><span class="p">(</span> <span class="n">arr</span><span class="p">,</span> <span class="n">dt</span> <span class="p">)</span>
        <span class="k">if</span> <span class="n">internal_column</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">:</span>
            <span class="k">return</span><span class="p">(</span> <span class="bp">self</span><span class="o">.</span><span class="n">power</span><span class="p">(</span> <span class="bp">self</span><span class="o">.</span><span class="n">_column_names</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="mi">0</span><span class="p">,</span> <span class="n">vector</span><span class="o">=</span><span class="s1">&#39;row&#39;</span> <span class="p">)</span> <span class="p">)</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span> <span class="n">internal_column</span><span class="p">,</span> <span class="nb">int</span> <span class="p">):</span>
            <span class="n">ofs</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_ofs</span><span class="p">(</span> <span class="n">internal_column</span><span class="p">,</span> <span class="n">lag</span><span class="o">=</span><span class="n">lag</span> <span class="p">)</span>
            <span class="n">dt</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">dtypes</span><span class="p">[</span><span class="n">internal_column</span><span class="p">]</span>
            <span class="n">ret</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">frombuffer</span><span class="p">(</span> <span class="bp">self</span><span class="o">.</span><span class="n">buffer</span><span class="p">,</span>
                                 <span class="n">dtype</span><span class="o">=</span><span class="n">dt</span><span class="p">,</span>
                                 <span class="n">count</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span>
                                 <span class="n">offset</span><span class="o">=</span><span class="n">ofs</span>
                                 <span class="p">)</span>
        <span class="k">if</span> <span class="s1">&#39;ret&#39;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="nb">dir</span><span class="p">(</span> <span class="p">):</span>
            <span class="k">raise</span> <span class="n">mathDictKeyError</span><span class="p">(</span> <span class="s1">&#39;</span><span class="si">%s</span><span class="s1"> is not a valid column identifier.&#39;</span>
                                    <span class="o">%</span> <span class="n">internal_column</span> <span class="p">)</span>
        <span class="k">return</span><span class="p">(</span> <span class="n">ret</span> <span class="p">)</span>

    <span class="k">def</span> <span class="nf">_mat</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">column_indexes</span><span class="p">,</span> <span class="n">lag</span><span class="o">=</span><span class="mi">0</span> <span class="p">):</span>
        <span class="sd">&#39;&#39;&#39;(for internal use): returns a matrix consisting of columns specified</span>
<span class="sd">        by their internal column identifier (index or local column name) in the</span>
<span class="sd">        column_indexes list.  Strings in the column_indexes list other than</span>
<span class="sd">        internal column identifiers are assumed to be calculated columns.  They</span>
<span class="sd">        are retrieved by through the .__getitem__( ) method that checks for</span>
<span class="sd">        pre-calculated columns by way of .power( ) and .crossproduct( ) before</span>
<span class="sd">        calculating a column.</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="n">ret</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span> <span class="p">)</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span> <span class="nb">len</span><span class="p">(</span> <span class="n">column_indexes</span> <span class="p">)</span> <span class="p">):</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span> <span class="n">column_indexes</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="nb">str</span> <span class="p">)</span> <span class="ow">and</span> \
               <span class="n">column_indexes</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">local</span><span class="o">.</span><span class="n">keys</span><span class="p">(</span> <span class="p">)</span> <span class="ow">and</span> \
               <span class="n">column_indexes</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_column_names</span><span class="p">:</span>
                <span class="n">ret</span><span class="o">.</span><span class="n">append</span><span class="p">(</span> <span class="bp">self</span><span class="o">.</span><span class="n">__getitem__</span><span class="p">(</span> <span class="n">column_indexes</span><span class="p">[</span><span class="n">i</span><span class="p">],</span>
                                              <span class="n">vector</span><span class="o">=</span><span class="s1">&#39;row&#39;</span> <span class="p">)</span> <span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">ret</span><span class="o">.</span><span class="n">append</span><span class="p">(</span> <span class="bp">self</span><span class="o">.</span><span class="n">_vec</span><span class="p">(</span> <span class="n">column_indexes</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">lag</span><span class="o">=</span><span class="n">lag</span> <span class="p">)</span> <span class="p">)</span>
        <span class="n">ret</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">stack</span><span class="p">(</span> <span class="n">ret</span><span class="p">,</span> <span class="mi">1</span> <span class="p">)</span>
        <span class="k">return</span><span class="p">(</span> <span class="n">ret</span> <span class="p">)</span>

<div class="viewcode-block" id="mathDict.get_column"><a class="viewcode-back" href="../ParallelRegression.html#ParallelRegression.mathDict.get_column">[docs]</a>    <span class="k">def</span> <span class="nf">get_column</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">column_name</span><span class="p">,</span> <span class="n">lag</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">vector</span><span class="o">=</span><span class="s1">&#39;column&#39;</span> <span class="p">):</span>
        <span class="sd">&#39;&#39;&#39;Returns the column with the specified name from either the matrix of</span>
<span class="sd">        original columns or the local column store.  No check is performed to</span>
<span class="sd">        ensure that the requested column is not masked, and calculated columns</span>
<span class="sd">        are not returned.</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="n">INTERNAL_NOTE</span> <span class="o">=</span> <span class="s1">&#39;&#39;&#39;</span>
<span class="s1">        All columns are stored as 1-dimensional arrays, which numpy perceives</span>
<span class="s1">        as row vectors unless they are transposed.  Except for when a slice or</span>
<span class="s1">        integer subscript causes .__getitem__( ) to call ._mat( ) directly,</span>
<span class="s1">        other methods pass `vector`(=&#39;column&#39; by default) to .get_column( ) so</span>
<span class="s1">        that .get_column( ) can transpose the vector.  Stored vectors are</span>
<span class="s1">        transposed via .get_column( ) calling ._mat( ) prior to manipulation or</span>
<span class="s1">        return by single-column-return methods such as .power( ) and</span>
<span class="s1">        .crossproduct( ).</span>
<span class="s1">        &#39;&#39;&#39;</span>
        <span class="k">if</span> <span class="n">vector</span> <span class="o">==</span> <span class="s1">&#39;column&#39;</span><span class="p">:</span>
            <span class="n">ret</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_mat</span><span class="p">(</span> <span class="p">[</span><span class="n">column_name</span><span class="p">],</span> <span class="n">lag</span><span class="o">=</span><span class="n">lag</span> <span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">ret</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_vec</span><span class="p">(</span> <span class="n">column_name</span><span class="p">,</span> <span class="n">lag</span><span class="o">=</span><span class="n">lag</span> <span class="p">)</span>
        <span class="k">return</span><span class="p">(</span> <span class="n">ret</span> <span class="p">)</span></div>

<div class="viewcode-block" id="mathDict.power"><a class="viewcode-back" href="../ParallelRegression.html#ParallelRegression.mathDict.power">[docs]</a>    <span class="k">def</span> <span class="nf">power</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">column_name</span><span class="p">,</span> <span class="n">power</span><span class="p">,</span> <span class="n">lag</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">vector</span><span class="o">=</span><span class="s1">&#39;column&#39;</span> <span class="p">):</span>
        <span class="sd">&#39;&#39;&#39;Returns the requested column with each cell raised to the requested</span>
<span class="sd">        power.  Checks to see if the power has been pre-calculated and returns</span>
<span class="sd">        the pre-calculated column if present.</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span> <span class="n">power</span><span class="p">,</span> <span class="nb">str</span> <span class="p">):</span>
            <span class="k">if</span> <span class="n">power</span><span class="o">.</span><span class="n">isdigit</span><span class="p">(</span> <span class="p">):</span>
                <span class="n">power</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span> <span class="n">power</span> <span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span> <span class="s1">&#39;</span><span class="si">%s</span><span class="s1"> is not a valid power.&#39;</span> <span class="o">%</span> <span class="n">power</span> <span class="p">)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">cache_powers</span> <span class="o">&gt;=</span> <span class="n">power</span> <span class="ow">and</span> \
           <span class="n">power</span> <span class="o">&gt;</span> <span class="mi">1</span> <span class="ow">and</span> \
           <span class="n">column_name</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_column_names</span><span class="p">:</span>
            <span class="n">index_base</span><span class="p">,</span> <span class="n">index</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_ofs_start</span>
            <span class="n">index</span> <span class="o">+=</span> <span class="nb">len</span><span class="p">(</span> <span class="bp">self</span><span class="o">.</span><span class="n">_column_names</span> <span class="p">)</span> <span class="o">*</span> <span class="p">(</span><span class="n">power</span> <span class="o">-</span> <span class="mi">2</span><span class="p">)</span>
            <span class="n">index</span> <span class="o">+=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_column_names</span><span class="o">.</span><span class="n">index</span><span class="p">(</span> <span class="n">column_name</span> <span class="p">)</span>
            <span class="n">ret</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_column</span><span class="p">(</span> <span class="n">index</span><span class="p">,</span> <span class="n">lag</span><span class="o">=</span><span class="n">lag</span><span class="p">,</span> <span class="n">vector</span><span class="o">=</span><span class="n">vector</span> <span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">ret</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_column</span><span class="p">(</span> <span class="n">column_name</span><span class="p">,</span> <span class="n">lag</span><span class="o">=</span><span class="n">lag</span><span class="p">,</span> <span class="n">vector</span><span class="o">=</span><span class="n">vector</span> <span class="p">)</span>
            <span class="n">ret</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">power</span><span class="p">(</span> <span class="n">ret</span><span class="p">,</span> <span class="n">power</span> <span class="p">)</span>
        <span class="k">return</span><span class="p">(</span> <span class="n">ret</span> <span class="p">)</span></div>

<div class="viewcode-block" id="mathDict.crosspower"><a class="viewcode-back" href="../ParallelRegression.html#ParallelRegression.mathDict.crosspower">[docs]</a>    <span class="k">def</span> <span class="nf">crosspower</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">column_a</span><span class="p">,</span> <span class="n">power_a</span><span class="p">,</span> <span class="n">column_b</span><span class="p">,</span> <span class="n">power_b</span><span class="p">,</span>
                   <span class="n">lag_a</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">lag_b</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">vector</span><span class="o">=</span><span class="s1">&#39;column&#39;</span> <span class="p">):</span>
        <span class="sd">&#39;&#39;&#39;Returns the product of two columns, each raised to the specified</span>
<span class="sd">        power.  Makes use of precalculated columns if applicable.</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="n">INTERNAL_NOTE</span> <span class="o">=</span> <span class="s1">&#39;&#39;&#39;</span>
<span class="s1">        Contains the logic for all column strings containing crossproducts</span>
<span class="s1">        after .__getitem__( ) applies regular expresions.</span>
<span class="s1">        &#39;&#39;&#39;</span>
        <span class="n">NoneSet</span> <span class="o">=</span> <span class="p">{</span><span class="kc">None</span><span class="p">,</span> <span class="s1">&#39;&#39;</span><span class="p">}</span>
        <span class="c1"># Lags</span>
        <span class="k">if</span> <span class="n">lag_a</span> <span class="ow">in</span> <span class="n">NoneSet</span><span class="p">:</span>
            <span class="n">lag_a</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">lag_a</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span> <span class="n">lag_a</span> <span class="p">)</span>
        <span class="k">if</span> <span class="n">lag_b</span> <span class="ow">in</span> <span class="n">NoneSet</span><span class="p">:</span>
            <span class="n">lag_b</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">lag_b</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span> <span class="n">lag_b</span> <span class="p">)</span>
        <span class="c1"># Powers</span>
        <span class="k">if</span> <span class="n">power_a</span> <span class="ow">in</span> <span class="n">NoneSet</span><span class="p">:</span>
            <span class="n">power_a</span> <span class="o">=</span> <span class="mi">1</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">power_a</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span> <span class="n">power_a</span> <span class="p">)</span>
        <span class="k">if</span> <span class="n">power_b</span> <span class="ow">in</span> <span class="n">NoneSet</span><span class="p">:</span>
            <span class="n">power_b</span> <span class="o">=</span> <span class="mi">1</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">power_b</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span> <span class="n">power_b</span> <span class="p">)</span>
        <span class="c1"># Math</span>
        <span class="n">ret</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">crossproduct</span><span class="p">(</span> <span class="n">column_a</span><span class="p">,</span>
                                 <span class="n">column_b</span><span class="p">,</span>
                                 <span class="n">lag_a</span><span class="o">=</span><span class="n">lag_a</span><span class="p">,</span>
                                 <span class="n">lag_b</span><span class="o">=</span><span class="n">lag_b</span><span class="p">,</span>
                                 <span class="n">vector</span><span class="o">=</span><span class="n">vector</span> <span class="p">)</span>
        <span class="k">if</span> <span class="n">power_a</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">ret</span> <span class="o">=</span> <span class="n">ret</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">power</span><span class="p">(</span> <span class="n">column_a</span><span class="p">,</span>
                                    <span class="n">power_a</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span>
                                    <span class="n">lag</span><span class="o">=</span><span class="n">lag_a</span><span class="p">,</span>
                                    <span class="n">vector</span><span class="o">=</span><span class="n">vector</span> <span class="p">)</span>
        <span class="k">if</span> <span class="n">power_b</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">ret</span> <span class="o">=</span> <span class="n">ret</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">power</span><span class="p">(</span> <span class="n">column_b</span><span class="p">,</span>
                                    <span class="n">power_b</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span>
                                    <span class="n">lag</span><span class="o">=</span><span class="n">lag_b</span><span class="p">,</span>
                                    <span class="n">vector</span><span class="o">=</span><span class="n">vector</span> <span class="p">)</span>
        <span class="k">return</span><span class="p">(</span> <span class="n">ret</span> <span class="p">)</span></div>

<div class="viewcode-block" id="mathDict.crossproduct"><a class="viewcode-back" href="../ParallelRegression.html#ParallelRegression.mathDict.crossproduct">[docs]</a>    <span class="k">def</span> <span class="nf">crossproduct</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">column_a</span><span class="p">,</span> <span class="n">column_b</span><span class="p">,</span>
                     <span class="n">lag_a</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">lag_b</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">vector</span><span class="o">=</span><span class="s1">&#39;column&#39;</span> <span class="p">):</span>
        <span class="sd">&#39;&#39;&#39;Returns a column in which each row `i` is `column_a[i]` *</span>
<span class="sd">        `column_b[i]`.  Checks to see if crossproducts have been pre-calculated</span>
<span class="sd">        and returns the pre-calculated column if present.  If `column_a` and</span>
<span class="sd">        `column_b` identify the same column, the requested is transfered to the</span>
<span class="sd">        .power( ) method.</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="k">if</span> <span class="n">column_a</span> <span class="o">==</span> <span class="n">column_b</span><span class="p">:</span>
            <span class="k">return</span><span class="p">(</span> <span class="bp">self</span><span class="o">.</span><span class="n">power</span><span class="p">(</span> <span class="n">column_a</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="n">vector</span><span class="o">=</span><span class="n">vector</span> <span class="p">)</span> <span class="p">)</span>
        <span class="n">orig_columns</span> <span class="o">=</span> <span class="n">column_a</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_column_names</span> <span class="ow">and</span> \
                       <span class="n">column_b</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_column_names</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">cache_crossproducts</span> <span class="o">==</span> <span class="kc">True</span> <span class="ow">and</span> \
           <span class="n">lag_a</span> <span class="o">==</span> <span class="n">lag_b</span> <span class="ow">and</span> \
           <span class="n">orig_columns</span><span class="p">:</span>
            <span class="n">indices</span> <span class="o">=</span> <span class="p">[</span><span class="n">i</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span> <span class="nb">len</span><span class="p">(</span> <span class="bp">self</span><span class="o">.</span><span class="n">_column_names</span> <span class="p">)</span> <span class="p">)]</span>
            <span class="n">indices</span> <span class="o">=</span> <span class="p">[</span><span class="n">i</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">itertools</span><span class="o">.</span><span class="n">combinations</span><span class="p">(</span> <span class="n">indices</span><span class="p">,</span> <span class="mi">2</span> <span class="p">)]</span>
            <span class="n">cp_index</span> <span class="o">=</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_column_names</span><span class="o">.</span><span class="n">index</span><span class="p">(</span> <span class="n">column_a</span> <span class="p">),</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">_column_names</span><span class="o">.</span><span class="n">index</span><span class="p">(</span> <span class="n">column_b</span> <span class="p">))</span>
            <span class="k">if</span> <span class="n">cp_index</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">cp_index</span><span class="p">[</span><span class="mi">0</span><span class="p">]:</span>
                <span class="n">cp_index_one</span><span class="p">,</span> <span class="n">cp_index_zero</span> <span class="o">=</span> <span class="n">cp_index</span>
                <span class="n">cp_index</span> <span class="o">=</span> <span class="p">(</span><span class="n">cp_index_zero</span><span class="p">,</span> <span class="n">cp_index_one</span><span class="p">)</span>
            <span class="n">cp_index</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_ofs_start</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="n">indices</span><span class="o">.</span><span class="n">index</span><span class="p">(</span> <span class="n">cp_index</span> <span class="p">)</span>
            <span class="k">return</span><span class="p">(</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_column</span><span class="p">(</span> <span class="n">cp_index</span><span class="p">,</span> <span class="n">lag</span><span class="o">=</span><span class="n">lag_a</span><span class="p">,</span> <span class="n">vector</span><span class="o">=</span><span class="n">vector</span> <span class="p">)</span> <span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">ret</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_column</span><span class="p">(</span> <span class="n">column_a</span><span class="p">,</span> <span class="n">lag</span><span class="o">=</span><span class="n">lag_a</span><span class="p">,</span> <span class="n">vector</span><span class="o">=</span><span class="n">vector</span> <span class="p">)</span>
            <span class="n">ret</span> <span class="o">=</span> <span class="n">ret</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_column</span><span class="p">(</span> <span class="n">column_b</span><span class="p">,</span> <span class="n">lag</span><span class="o">=</span><span class="n">lag_b</span><span class="p">,</span> <span class="n">vector</span><span class="o">=</span><span class="n">vector</span> <span class="p">)</span>
        <span class="k">return</span><span class="p">(</span> <span class="n">ret</span> <span class="p">)</span></div>

<div class="viewcode-block" id="mathDict.mask_all"><a class="viewcode-back" href="../ParallelRegression.html#ParallelRegression.mathDict.mask_all">[docs]</a>    <span class="k">def</span> <span class="nf">mask_all</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">except_intercept</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">clear_calculated</span><span class="o">=</span><span class="kc">True</span> <span class="p">):</span>
        <span class="sd">&#39;&#39;&#39;Masks the Intercept column (by default), every column in the matrix</span>
<span class="sd">        of original columns, and every local column, leaving calculated columns</span>
<span class="sd">        unaffected (by default).</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        except_intercept : boolean, optional</span>
<span class="sd">            If True, then the Intercept will be unmasked regardless of its</span>
<span class="sd">            state prior to this method call.</span>
<span class="sd">        clear_calculated : boolean, optional</span>
<span class="sd">            If True, then the list of calculated columns will be deleted.</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_mask</span> <span class="o">=</span> <span class="p">[</span><span class="kc">True</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span> <span class="nb">len</span><span class="p">(</span> <span class="bp">self</span><span class="o">.</span><span class="n">_column_names</span> <span class="p">)</span> <span class="o">+</span> <span class="mi">1</span> <span class="p">)]</span>
        <span class="k">for</span> <span class="n">column</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">local</span><span class="o">.</span><span class="n">keys</span><span class="p">(</span> <span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">local_mask</span><span class="o">.</span><span class="n">add</span><span class="p">(</span> <span class="n">column</span> <span class="p">)</span>
        <span class="k">if</span> <span class="n">except_intercept</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_mask</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="k">if</span> <span class="n">clear_calculated</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">calculated_columns</span> <span class="o">=</span> <span class="p">[]</span></div>

<div class="viewcode-block" id="mathDict.unmask_all"><a class="viewcode-back" href="../ParallelRegression.html#ParallelRegression.mathDict.unmask_all">[docs]</a>    <span class="k">def</span> <span class="nf">unmask_all</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&#39;&#39;&#39;Unmasks the Intercept column and every column in the matrix of</span>
<span class="sd">        original columns.</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_mask</span> <span class="o">=</span> <span class="p">[</span><span class="kc">False</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">local_mask</span><span class="o">.</span><span class="n">clear</span><span class="p">(</span> <span class="p">)</span></div>

<div class="viewcode-block" id="mathDict.set_mask"><a class="viewcode-back" href="../ParallelRegression.html#ParallelRegression.mathDict.set_mask">[docs]</a>    <span class="k">def</span> <span class="nf">set_mask</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">column_name</span><span class="p">,</span> <span class="n">mask</span><span class="o">=</span><span class="kc">True</span> <span class="p">):</span>
        <span class="sd">&#39;&#39;&#39;Sets the mask of the specified column to the specified value,</span>
<span class="sd">        extending the length of the mask sequence if necessary.  If</span>
<span class="sd">        `column_name` == &#39;Intercept&#39;, then it sets the mask of the Intercept</span>
<span class="sd">        column instead.</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="k">if</span> <span class="n">column_name</span> <span class="o">==</span> <span class="s1">&#39;Intercept&#39;</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_mask</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">mask</span>
            <span class="k">return</span><span class="p">(</span> <span class="p">)</span>
        <span class="k">elif</span> <span class="n">column_name</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_column_names</span><span class="p">:</span>
            <span class="n">index</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_column_names</span><span class="o">.</span><span class="n">index</span><span class="p">(</span> <span class="n">column_name</span> <span class="p">)</span> <span class="o">+</span> <span class="mi">1</span>
            <span class="k">if</span> <span class="n">index</span> <span class="o">&gt;=</span> <span class="nb">len</span><span class="p">(</span> <span class="bp">self</span><span class="o">.</span><span class="n">_mask</span> <span class="p">):</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_mask</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span> <span class="p">[</span><span class="kc">False</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> \
                                    <span class="nb">range</span><span class="p">(</span> <span class="nb">len</span><span class="p">(</span> <span class="bp">self</span><span class="o">.</span><span class="n">_mask</span> <span class="p">),</span> <span class="n">index</span> <span class="o">+</span> <span class="mi">1</span> <span class="p">)]</span> <span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_mask</span><span class="p">[</span><span class="n">index</span><span class="p">]</span> <span class="o">=</span> <span class="n">mask</span>
        <span class="k">elif</span> <span class="n">column_name</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">local</span><span class="o">.</span><span class="n">keys</span><span class="p">(</span> <span class="p">)</span> <span class="ow">and</span> <span class="n">mask</span> <span class="o">==</span> <span class="kc">True</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">local_mask</span><span class="o">.</span><span class="n">add</span><span class="p">(</span> <span class="n">column_name</span> <span class="p">)</span>
        <span class="k">elif</span> <span class="n">column_name</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">local</span><span class="o">.</span><span class="n">keys</span><span class="p">(</span> <span class="p">)</span> <span class="ow">and</span> <span class="n">mask</span> <span class="o">==</span> <span class="kc">False</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">local_mask</span><span class="o">.</span><span class="n">discard</span><span class="p">(</span> <span class="n">column_name</span> <span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">KeyError</span><span class="p">(</span> <span class="s1">&#39;</span><span class="si">%s</span><span class="s1"> is not a valid column name.&#39;</span> <span class="o">%</span> <span class="n">column_name</span> <span class="p">)</span></div>

<div class="viewcode-block" id="mathDict.add"><a class="viewcode-back" href="../ParallelRegression.html#ParallelRegression.mathDict.add">[docs]</a>    <span class="k">def</span> <span class="nf">add</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">column_string</span> <span class="p">):</span>
        <span class="sd">&#39;&#39;&#39;Adds column_string to the matrix represented by the mathDict( ), and</span>
<span class="sd">        returns the mathDict( ) if successful.</span>

<span class="sd">        Raises</span>
<span class="sd">        ------</span>
<span class="sd">        UnsupportedColumn(Warning)</span>
<span class="sd">            If `column_string` is neither the name of a shared or local column,</span>
<span class="sd">            nor something that mathDict( ) can calculate therefrom.  `.args[1]`</span>
<span class="sd">            == `.columns` is a list of the unsupported column(s).</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="k">if</span> <span class="n">column_string</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_column_names</span> <span class="ow">or</span> \
           <span class="n">column_string</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">local</span> <span class="ow">or</span> \
           <span class="n">column_string</span> <span class="o">==</span> <span class="s1">&#39;Intercept&#39;</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">set_mask</span><span class="p">(</span> <span class="n">column_name</span><span class="o">=</span><span class="n">column_string</span><span class="p">,</span> <span class="n">mask</span><span class="o">=</span><span class="kc">False</span> <span class="p">)</span>
            <span class="k">return</span><span class="p">(</span> <span class="bp">self</span> <span class="p">)</span>
        <span class="k">elif</span> <span class="n">column_string</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">calculated_columns</span><span class="p">:</span>
            <span class="k">return</span><span class="p">(</span> <span class="bp">self</span> <span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">column_string</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">strings_checked</span><span class="p">:</span>
                <span class="k">try</span><span class="p">:</span>
                    <span class="n">attempt</span> <span class="o">=</span> <span class="bp">self</span><span class="p">[</span><span class="n">column_string</span><span class="p">]</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">strings_checked</span><span class="o">.</span><span class="n">add</span><span class="p">(</span> <span class="n">column_string</span> <span class="p">)</span>
                <span class="k">except</span> <span class="n">mathDictKeyError</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
                    <span class="k">raise</span> <span class="n">UnsupportedColumn</span><span class="p">(</span> <span class="s2">&quot;mathDict( ) neither contains a &quot;</span>
                         <span class="s2">&quot;column named, nor supports the calculation of, &#39;</span><span class="si">%s</span><span class="s2">&#39;.&quot;</span>
                         <span class="o">%</span> <span class="n">column_string</span><span class="p">,</span> <span class="p">[</span><span class="n">column_string</span><span class="p">]</span> <span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">calculated_columns</span><span class="o">.</span><span class="n">append</span><span class="p">(</span> <span class="n">column_string</span> <span class="p">)</span>
            <span class="k">return</span><span class="p">(</span> <span class="bp">self</span> <span class="p">)</span></div>

<div class="viewcode-block" id="mathDict.add_from_RHS"><a class="viewcode-back" href="../ParallelRegression.html#ParallelRegression.mathDict.add_from_RHS">[docs]</a>    <span class="k">def</span> <span class="nf">add_from_RHS</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">formula</span> <span class="p">):</span>
        <span class="sd">&#39;&#39;&#39;Adds columns to the matrix represented by the mathDict( ) based on</span>
<span class="sd">        terms in the right hand side of a string representation of a formula.</span>

<span class="sd">        If there is one or more &#39;~&#39; characters in the formula string,</span>
<span class="sd">        everything to the left of the first &#39;~&#39; character will be ignored.</span>
<span class="sd">        Then, the string will be divided into `column_string`s by splitting on</span>
<span class="sd">        &#39;+&#39; and &#39;-&#39; characters  that are not enclosed within brackets, and</span>
<span class="sd">        .add( column_string ) will be attempted for each column string.</span>

<span class="sd">        Note: Subtracting in lieu of adding negatives is not currently</span>
<span class="sd">        supported, but there is no error checking for this.  Formula strings</span>
<span class="sd">        split on the minus sign in anticipation of a subsequent release</span>
<span class="sd">        supporting subtraction directly.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        self : mathDict</span>
<span class="sd">            If there were zero &#39;~&#39; characters in the original string and every</span>
<span class="sd">            .add( ) attempt was successful.</span>
<span class="sd">        string</span>
<span class="sd">            If there were one or more &#39;~&#39; characters in the original string,</span>
<span class="sd">            then the substring to the left of the first &#39;~&#39; character, stripped</span>
<span class="sd">            of padding whitespaces, is returned if/when every .add( ) attempt</span>
<span class="sd">            is successful.</span>

<span class="sd">        Raises</span>
<span class="sd">        ------</span>
<span class="sd">        UnsupportedColumn(Warning)</span>
<span class="sd">            If one or more column strings is unsupported.  `.args[1]` ==</span>
<span class="sd">            `.columns` is a list of the unsupported column(s).  `.LHS` contains</span>
<span class="sd">            the string to the left of the first `~`, if any, stripped of</span>
<span class="sd">            padding whitespaces.  All supported columns are still added even</span>
<span class="sd">            when an unsupported column occurds mid-formula.</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="n">LHS</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="n">unsupported</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span> <span class="p">)</span>
        <span class="k">if</span> <span class="n">formula</span><span class="o">.</span><span class="n">count</span><span class="p">(</span> <span class="s1">&#39;~&#39;</span> <span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">LHS</span><span class="p">,</span> <span class="n">formula</span> <span class="o">=</span> <span class="n">formula</span><span class="o">.</span><span class="n">split</span><span class="p">(</span> <span class="s1">&#39;~&#39;</span><span class="p">,</span> <span class="mi">1</span> <span class="p">)</span>
        <span class="k">for</span> <span class="n">term</span> <span class="ow">in</span> <span class="n">terms_in</span><span class="p">(</span> <span class="n">formula</span> <span class="p">):</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">add</span><span class="p">(</span> <span class="n">term</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span> <span class="s1">&#39; &#39;</span><span class="p">,</span> <span class="s1">&#39;&#39;</span> <span class="p">)</span> <span class="p">)</span>
            <span class="k">except</span> <span class="n">UnsupportedColumn</span> <span class="k">as</span> <span class="n">w</span><span class="p">:</span>
                <span class="n">unsupported</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span> <span class="n">w</span><span class="o">.</span><span class="n">columns</span> <span class="p">)</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span> <span class="n">unsupported</span> <span class="p">)</span> <span class="o">==</span> <span class="mi">0</span> <span class="ow">and</span> <span class="n">LHS</span> <span class="o">==</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">return</span><span class="p">(</span> <span class="bp">self</span> <span class="p">)</span>
        <span class="k">if</span> <span class="n">LHS</span> <span class="o">!=</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">LHS</span> <span class="o">=</span> <span class="n">LHS</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span> <span class="s1">&#39; &#39;</span><span class="p">,</span> <span class="s1">&#39;&#39;</span> <span class="p">)</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span> <span class="n">unsupported</span> <span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">UnsupportedColumn</span><span class="p">(</span> <span class="s2">&quot;One or more RHS terms could not be &quot;</span>
                                     <span class="s2">&quot;added.  RHS: &#39;</span><span class="si">%s</span><span class="s2">&#39;.&quot;</span>
                                     <span class="o">%</span> <span class="n">formula</span><span class="p">,</span> <span class="n">unsupported</span><span class="p">,</span> <span class="n">LHS</span><span class="o">=</span><span class="n">LHS</span> <span class="p">)</span>
        <span class="k">return</span><span class="p">(</span> <span class="n">LHS</span> <span class="p">)</span></div>

<div class="viewcode-block" id="mathDict.config_to_dict"><a class="viewcode-back" href="../ParallelRegression.html#ParallelRegression.mathDict.config_to_dict">[docs]</a>    <span class="k">def</span> <span class="nf">config_to_dict</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&#39;&#39;&#39;Returns a dict( ) subclass object containing the configuration of</span>
<span class="sd">        this mathDict( ) matrix that has a .rebuild( SharedDataArray=REQUIRED )</span>
<span class="sd">        method to recreate the mathDict( ) in a different process.</span>

<span class="sd">        *NOTE: Hypothesis information is not stored.*</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="n">config</span>                        <span class="o">=</span> <span class="n">mathDictConfig</span><span class="p">(</span> <span class="p">)</span>
        <span class="n">config</span><span class="p">[</span><span class="s1">&#39;items&#39;</span><span class="p">]</span>               <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">items</span>
        <span class="n">config</span><span class="p">[</span><span class="s1">&#39;_column_names&#39;</span><span class="p">]</span>       <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_column_names</span>
        <span class="n">config</span><span class="p">[</span><span class="s1">&#39;mask&#39;</span><span class="p">]</span>                <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_mask</span>
        <span class="n">config</span><span class="p">[</span><span class="s1">&#39;dtypes&#39;</span><span class="p">]</span>              <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">dtypes</span>
        <span class="n">config</span><span class="p">[</span><span class="s1">&#39;calculated_columns&#39;</span><span class="p">]</span>  <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">calculated_columns</span>
        <span class="n">config</span><span class="p">[</span><span class="s1">&#39;cache_crossproducts&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">cache_crossproducts</span>
        <span class="n">config</span><span class="p">[</span><span class="s1">&#39;cache_powers&#39;</span><span class="p">]</span>        <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">cache_powers</span>
        <span class="n">config</span><span class="p">[</span><span class="s1">&#39;max_lag&#39;</span><span class="p">]</span>             <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">max_lag</span>
        <span class="n">config</span><span class="p">[</span><span class="s1">&#39;terms&#39;</span><span class="p">]</span>               <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">terms</span>
        <span class="k">return</span><span class="p">(</span> <span class="n">config</span> <span class="p">)</span></div>

<div class="viewcode-block" id="mathDict.iter_map"><a class="viewcode-back" href="../ParallelRegression.html#ParallelRegression.mathDict.iter_map">[docs]</a>    <span class="k">def</span> <span class="nf">iter_map</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">arg_iterable</span><span class="p">,</span>
                       <span class="n">func</span><span class="p">,</span>
                       <span class="n">placement</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span>
                       <span class="n">process_count</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                       <span class="n">use_kwargs</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                       <span class="n">number_results</span><span class="o">=</span><span class="kc">False</span> <span class="p">):</span>
        <span class="sd">&#39;&#39;&#39;Comparable to .map( ) except that it returns an unsorted iterable </span>
<span class="sd">        instead of a list( ).</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        arg_iterable : iterable of tuples</span>
<span class="sd">            tuple of positional arguments to be passed into `func`.  The final </span>
<span class="sd">            value in the tuple can be a dict( ) of keyword arguments if </span>
<span class="sd">            `use_kwargs` is set to True.</span>
<span class="sd">        func : function</span>
<span class="sd">            The function to be called.  It must be pickleable.</span>
<span class="sd">        placement : int or string, optional</span>
<span class="sd">            If an integer, then the matrix will be inserted as a positional</span>
<span class="sd">            argument at this location.  If a string, then the matrix will be</span>
<span class="sd">            passed in as a keyword argument using this keyword.</span>
<span class="sd">        process_count : int, optional</span>
<span class="sd">            The number of child processes to launch.  If this is not set, then</span>
<span class="sd">            Python will try to figure it out using a minimum of two processes,</span>
<span class="sd">            but Python isn&#39;t good at figuring it out so it is always better to</span>
<span class="sd">            provide this argument.</span>
<span class="sd">        use_kwargs : bool</span>
<span class="sd">            If True, then the final value in each tuple of arguments will be </span>
<span class="sd">            treated as a dict( ) of keyword arguments for `func`.</span>
<span class="sd">        number_results : bool</span>
<span class="sd">            If True, each result will be provided in the form of a tuple in </span>
<span class="sd">            which the first value is the position of the argument tuple in </span>
<span class="sd">            `arg_iterable` from which the result was computed, and the second </span>
<span class="sd">            value is the result itself.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        Iterable</span>
<span class="sd">            Results in unsorted, iterable form.</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="n">ProcessQueue</span> <span class="o">=</span> <span class="n">Queue</span><span class="p">(</span> <span class="p">)</span>
        <span class="n">ReturnQueue</span> <span class="o">=</span> <span class="n">Queue</span><span class="p">(</span> <span class="p">)</span>
        <span class="n">procList</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span> <span class="p">)</span>
        <span class="k">if</span> <span class="n">process_count</span> <span class="o">==</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">process_count</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span> <span class="n">cpu_count</span><span class="p">(</span> <span class="p">),</span> <span class="mi">2</span> <span class="p">)</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span> <span class="n">process_count</span> <span class="p">):</span>
            <span class="n">p</span> <span class="o">=</span> <span class="n">Process</span><span class="p">(</span> <span class="n">target</span><span class="o">=</span><span class="n">_mapper</span><span class="p">,</span>
                         <span class="n">args</span><span class="o">=</span><span class="p">(</span><span class="n">ProcessQueue</span><span class="p">,</span>
                               <span class="n">ReturnQueue</span><span class="p">,</span>
                               <span class="bp">self</span><span class="o">.</span><span class="n">buffer</span><span class="p">,</span>
                               <span class="bp">self</span><span class="o">.</span><span class="n">config_to_dict</span><span class="p">(</span> <span class="p">),</span>
                               <span class="n">func</span><span class="p">,</span>
                               <span class="n">placement</span> <span class="p">)</span>
                         <span class="p">)</span>
            <span class="n">p</span><span class="o">.</span><span class="n">start</span><span class="p">(</span> <span class="p">)</span>
            <span class="n">procList</span><span class="o">.</span><span class="n">append</span><span class="p">(</span> <span class="n">p</span> <span class="p">)</span>
        <span class="n">kwargs</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span> <span class="p">)</span>
        <span class="k">if</span> <span class="n">number_results</span><span class="p">:</span>
            <span class="n">rid</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="k">for</span> <span class="n">args</span> <span class="ow">in</span> <span class="n">arg_iterable</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">use_kwargs</span><span class="p">:</span>
                    <span class="n">kwargs</span> <span class="o">=</span> <span class="n">args</span><span class="p">[</span><span class="nb">len</span><span class="p">(</span> <span class="n">args</span> <span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span>
                    <span class="n">pargs</span> <span class="o">=</span> <span class="n">args</span><span class="p">[:</span><span class="nb">len</span><span class="p">(</span> <span class="n">args</span> <span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">pargs</span> <span class="o">=</span> <span class="n">args</span>
                <span class="n">ProcessQueue</span><span class="o">.</span><span class="n">put</span><span class="p">(</span> <span class="p">(</span><span class="n">rid</span><span class="p">,</span> <span class="n">pargs</span><span class="p">,</span> <span class="n">kwargs</span><span class="p">)</span> <span class="p">)</span>
                <span class="n">rid</span> <span class="o">+=</span> <span class="mi">1</span>
        <span class="k">elif</span> <span class="n">use_kwargs</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">args</span> <span class="ow">in</span> <span class="n">arg_iterable</span><span class="p">:</span>
                <span class="n">kwargs</span> <span class="o">=</span> <span class="n">args</span><span class="p">[</span><span class="nb">len</span><span class="p">(</span> <span class="n">args</span> <span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span>
                <span class="n">pargs</span> <span class="o">=</span> <span class="n">args</span><span class="p">[:</span><span class="nb">len</span><span class="p">(</span> <span class="n">args</span> <span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span>
                <span class="n">ProcessQueue</span><span class="o">.</span><span class="n">put</span><span class="p">(</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">pargs</span><span class="p">,</span> <span class="n">kwargs</span><span class="p">)</span> <span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">args</span> <span class="ow">in</span> <span class="n">arg_iterable</span><span class="p">:</span>
                <span class="c1">## Yes, this involves redundant code.  It also minimizes</span>
                <span class="c1">## branching in an algorithm that could be looped through tens</span>
                <span class="c1">## of thousands or in some scenarios millions of times.</span>
                <span class="n">ProcessQueue</span><span class="o">.</span><span class="n">put</span><span class="p">(</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">args</span><span class="p">,</span> <span class="n">kwargs</span><span class="p">)</span> <span class="p">)</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span> <span class="nb">len</span><span class="p">(</span> <span class="n">procList</span> <span class="p">)</span> <span class="p">):</span>
            <span class="n">ProcessQueue</span><span class="o">.</span><span class="n">put</span><span class="p">(</span> <span class="s1">&#39;Terminate.&#39;</span> <span class="p">)</span>
        <span class="n">termination_count</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">while</span> <span class="n">termination_count</span> <span class="o">&lt;</span> <span class="nb">len</span><span class="p">(</span> <span class="n">procList</span> <span class="p">):</span>
            <span class="n">QueueObject</span> <span class="o">=</span> <span class="n">ReturnQueue</span><span class="o">.</span><span class="n">get</span><span class="p">(</span> <span class="p">)</span>
            <span class="k">if</span> <span class="n">QueueObject</span> <span class="o">==</span> <span class="s1">&#39;Terminated.&#39;</span><span class="p">:</span>
                <span class="n">termination_count</span> <span class="o">+=</span> <span class="mi">1</span>
            <span class="k">elif</span> <span class="n">number_results</span><span class="p">:</span>
                <span class="k">yield</span><span class="p">(</span> <span class="n">QueueObject</span> <span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">yield</span><span class="p">(</span> <span class="n">QueueObject</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="p">)</span></div>

<div class="viewcode-block" id="mathDict.map"><a class="viewcode-back" href="../ParallelRegression.html#ParallelRegression.mathDict.map">[docs]</a>    <span class="k">def</span> <span class="nf">map</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">arg_iterable</span><span class="p">,</span>
                  <span class="n">func</span><span class="p">,</span>
                  <span class="n">placement</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span>
                  <span class="n">process_count</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                  <span class="n">use_kwargs</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                  <span class="n">ordered</span><span class="o">=</span><span class="kc">False</span> <span class="p">):</span>
        <span class="sd">&#39;&#39;&#39;Uses parallel processes and shared memory to call `func` with each </span>
<span class="sd">        tuple of arguments, also passing in the matrix as an argument.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        arg_iterable : iterable of tuples</span>
<span class="sd">            tuple of positional arguments to be passed into `func`.  The final </span>
<span class="sd">            value in the tuple can be a dict( ) of keyword arguments if </span>
<span class="sd">            `use_kwargs` is set to True.</span>
<span class="sd">        func : function</span>
<span class="sd">            The function to be called.  It must be pickleable.</span>
<span class="sd">        placement : int or string, optional</span>
<span class="sd">            If an integer, then the matrix will be inserted as a positional</span>
<span class="sd">            argument at this location.  If a string, then the matrix will be</span>
<span class="sd">            passed in as a keyword argument using this keyword.</span>
<span class="sd">        process_count : int, optional</span>
<span class="sd">            The number of child processes to launch.  If this is not set, then</span>
<span class="sd">            Python will try to figure it out using a minimum of two processes,</span>
<span class="sd">            but Python isn&#39;t good at figuring it out so it is always better to</span>
<span class="sd">            provide this argument.</span>
<span class="sd">        use_kwargs : bool</span>
<span class="sd">            If True, then the final value in each tuple of arguments will be </span>
<span class="sd">            treated as a dict( ) of keyword arguments for `func`.</span>
<span class="sd">        ordered : bool</span>
<span class="sd">            If True, then the results will be listed in the order of the </span>
<span class="sd">            argument tuples.  Otherwise, results may be in any order.  Note: </span>
<span class="sd">            argument tuples are processed asynchronously (out-of-sequence) </span>
<span class="sd">            either way. This option sorts the results after they have been </span>
<span class="sd">            computed.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        list</span>
<span class="sd">            Results in list( ) form.</span>

<span class="sd">        Example</span>
<span class="sd">        -------</span>
<span class="sd">        &gt;&gt;&gt; def sum_row( matrix, row ):</span>
<span class="sd">        &gt;&gt;&gt;     # Put this in a_file.py and import it if you receive pickle-</span>
<span class="sd">        &gt;&gt;&gt;     # related errors.</span>
<span class="sd">        &gt;&gt;&gt;     return( sum( matrix[row,:] ) )</span>
<span class="sd">        &gt;&gt;&gt; matrix = np.array( [i for i in range( 24 )] ).reshape( (6, 4) )</span>
<span class="sd">        &gt;&gt;&gt; RA, MD = mathDictMaker.fromMatrix( matrix, integer=True )</span>
<span class="sd">        &gt;&gt;&gt; res = MD.map( [(i,) for i in range( 6 )], sum_row, ordered=True )</span>
<span class="sd">        &gt;&gt;&gt; print( res )</span>
<span class="sd">        [6, 22, 38, 54, 70, 86]</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="n">retList</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span> <span class="p">)</span>
        <span class="k">for</span> <span class="n">ret</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">iter_map</span><span class="p">(</span> <span class="n">arg_iterable</span><span class="o">=</span><span class="n">arg_iterable</span><span class="p">,</span>
                                  <span class="n">func</span><span class="o">=</span><span class="n">func</span><span class="p">,</span>
                                  <span class="n">placement</span><span class="o">=</span><span class="n">placement</span><span class="p">,</span>
                                  <span class="n">process_count</span><span class="o">=</span><span class="n">process_count</span><span class="p">,</span>
                                  <span class="n">use_kwargs</span><span class="o">=</span><span class="n">use_kwargs</span><span class="p">,</span>
                                  <span class="n">number_results</span><span class="o">=</span><span class="n">ordered</span> <span class="p">):</span>
            <span class="n">retList</span><span class="o">.</span><span class="n">append</span><span class="p">(</span> <span class="n">ret</span> <span class="p">)</span>
        <span class="k">if</span> <span class="n">ordered</span><span class="p">:</span>
            <span class="n">retList</span><span class="o">.</span><span class="n">sort</span><span class="p">(</span> <span class="p">)</span>
            <span class="n">retList</span> <span class="o">=</span> <span class="p">[</span><span class="n">tpl</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="k">for</span> <span class="n">tpl</span> <span class="ow">in</span> <span class="n">retList</span><span class="p">]</span>
        <span class="k">return</span><span class="p">(</span> <span class="n">retList</span> <span class="p">)</span></div></div>

<span class="k">class</span> <span class="nc">TestCase</span><span class="p">(</span><span class="n">unittest</span><span class="o">.</span><span class="n">TestCase</span><span class="p">):</span>
    <span class="sd">&#39;&#39;&#39;Included solely for internal use.</span>
<span class="sd">    &#39;&#39;&#39;</span>
    <span class="n">_dirname</span>   <span class="o">=</span> <span class="s1">&#39;test_files/&#39;</span>
    <span class="n">_rfilename</span> <span class="o">=</span> <span class="n">_dirname</span> <span class="o">+</span> <span class="s1">&#39;exp_&#39;</span>
    <span class="n">_wfilename</span> <span class="o">=</span> <span class="n">_dirname</span> <span class="o">+</span> <span class="s1">&#39;act_&#39;</span>
    <span class="k">def</span> <span class="nf">assertDictUnsortedEqual</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">dictA</span><span class="p">,</span> <span class="n">dictB</span> <span class="p">):</span>
        <span class="sd">&#39;&#39;&#39;Compares two dict( )s in which each entry is expected to have an</span>
<span class="sd">        iterable for its value.</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">assertSetEqual</span><span class="p">(</span> <span class="nb">set</span><span class="p">(</span> <span class="n">dictA</span><span class="o">.</span><span class="n">keys</span><span class="p">(</span> <span class="p">)</span> <span class="p">),</span> <span class="nb">set</span><span class="p">(</span> <span class="n">dictB</span><span class="o">.</span><span class="n">keys</span><span class="p">(</span> <span class="p">)</span> <span class="p">)</span> <span class="p">)</span>
        <span class="k">for</span> <span class="n">key</span> <span class="ow">in</span> <span class="n">dictA</span><span class="o">.</span><span class="n">keys</span><span class="p">(</span> <span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">assertSetEqual</span><span class="p">(</span> <span class="nb">set</span><span class="p">(</span> <span class="n">dictA</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="p">),</span> <span class="nb">set</span><span class="p">(</span> <span class="n">dictB</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="p">)</span> <span class="p">)</span>

    <span class="nd">@contextmanager</span>
    <span class="k">def</span> <span class="nf">assertRaisesWithMessage</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">e</span><span class="p">,</span> <span class="n">msg</span><span class="p">,</span> <span class="n">index</span><span class="o">=</span><span class="mi">0</span> <span class="p">):</span>
        <span class="k">with</span> <span class="bp">self</span><span class="o">.</span><span class="n">assertRaises</span><span class="p">(</span> <span class="n">e</span> <span class="p">)</span> <span class="k">as</span> <span class="n">cm</span><span class="p">:</span>
            <span class="k">yield</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">assertEqual</span><span class="p">(</span> <span class="n">cm</span><span class="o">.</span><span class="n">exception</span><span class="o">.</span><span class="n">args</span><span class="p">[</span><span class="n">index</span><span class="p">],</span> <span class="n">msg</span> <span class="p">)</span>

    <span class="k">def</span> <span class="nf">assertFileLineSetEqual</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">f1</span><span class="p">,</span> <span class="n">f2</span><span class="p">,</span> <span class="n">msg</span><span class="o">=</span><span class="kc">None</span> <span class="p">):</span>
        <span class="n">f1</span> <span class="o">=</span> <span class="n">TestCase</span><span class="o">.</span><span class="n">_dirname</span> <span class="o">+</span> <span class="n">f1</span>
        <span class="n">f2</span> <span class="o">=</span> <span class="n">TestCase</span><span class="o">.</span><span class="n">_dirname</span> <span class="o">+</span> <span class="n">f2</span>
        <span class="n">lines1</span> <span class="o">=</span> <span class="nb">open</span><span class="p">(</span> <span class="n">f1</span><span class="p">,</span> <span class="s1">&#39;r&#39;</span> <span class="p">)</span><span class="o">.</span><span class="n">readlines</span><span class="p">(</span> <span class="p">)</span>
        <span class="n">lines2</span> <span class="o">=</span> <span class="nb">open</span><span class="p">(</span> <span class="n">f2</span><span class="p">,</span> <span class="s1">&#39;r&#39;</span> <span class="p">)</span><span class="o">.</span><span class="n">readlines</span><span class="p">(</span> <span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">assertEqual</span><span class="p">(</span> <span class="nb">len</span><span class="p">(</span> <span class="n">lines1</span> <span class="p">),</span> <span class="nb">len</span><span class="p">(</span> <span class="n">lines2</span> <span class="p">)</span> <span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">assertSetEqual</span><span class="p">(</span> <span class="nb">set</span><span class="p">(</span> <span class="n">lines1</span> <span class="p">),</span> <span class="nb">set</span><span class="p">(</span> <span class="n">lines2</span> <span class="p">),</span> <span class="n">msg</span> <span class="p">)</span>

    <span class="nd">@contextmanager</span>
    <span class="k">def</span> <span class="nf">assertStreamFileEqual</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">filename</span><span class="p">,</span> <span class="n">encoding</span><span class="o">=</span><span class="kc">None</span> <span class="p">):</span>
        <span class="n">_rfilename</span> <span class="o">=</span> <span class="n">TestCase</span><span class="o">.</span><span class="n">_rfilename</span> <span class="o">+</span> <span class="n">filename</span>
        <span class="n">_wfilename</span> <span class="o">=</span> <span class="n">TestCase</span><span class="o">.</span><span class="n">_wfilename</span> <span class="o">+</span> <span class="n">filename</span>
        <span class="n">stream</span> <span class="o">=</span> <span class="n">StringIO</span><span class="p">(</span> <span class="p">)</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="k">yield</span><span class="p">(</span> <span class="n">stream</span> <span class="p">)</span>
        <span class="k">finally</span><span class="p">:</span>
            <span class="n">expected</span> <span class="o">=</span> <span class="s1">&#39;&#39;</span>
            <span class="k">with</span> <span class="n">suppress</span><span class="p">(</span><span class="ne">FileNotFoundError</span><span class="p">):</span>
                <span class="k">if</span> <span class="n">encoding</span> <span class="o">!=</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="n">expected</span> <span class="o">=</span> <span class="nb">open</span><span class="p">(</span> <span class="n">_rfilename</span><span class="p">,</span>
                                    <span class="s1">&#39;r&#39;</span><span class="p">,</span>
                                    <span class="n">encoding</span><span class="o">=</span><span class="n">encoding</span> <span class="p">)</span><span class="o">.</span><span class="n">read</span><span class="p">(</span> <span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">expected</span> <span class="o">=</span> <span class="nb">open</span><span class="p">(</span> <span class="n">_rfilename</span><span class="p">,</span> <span class="s1">&#39;r&#39;</span> <span class="p">)</span><span class="o">.</span><span class="n">read</span><span class="p">(</span> <span class="p">)</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">assertMultiLineEqual</span><span class="p">(</span> <span class="n">stream</span><span class="o">.</span><span class="n">getvalue</span><span class="p">(</span> <span class="p">),</span> <span class="n">expected</span> <span class="p">)</span>
            <span class="k">except</span> <span class="ne">AssertionError</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
                <span class="n">stream</span><span class="o">.</span><span class="n">seek</span><span class="p">(</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span> <span class="p">)</span>
                <span class="k">if</span> <span class="n">encoding</span> <span class="o">!=</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="n">wf</span> <span class="o">=</span> <span class="nb">open</span><span class="p">(</span> <span class="n">_wfilename</span><span class="p">,</span>
                               <span class="s1">&#39;w&#39;</span><span class="p">,</span>
                               <span class="n">encoding</span><span class="o">=</span><span class="n">encoding</span>
                             <span class="p">)</span><span class="o">.</span><span class="n">writelines</span><span class="p">(</span> <span class="n">stream</span><span class="o">.</span><span class="n">readlines</span><span class="p">(</span> <span class="p">)</span> <span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">wf</span> <span class="o">=</span> <span class="nb">open</span><span class="p">(</span> <span class="n">_wfilename</span><span class="p">,</span>
                               <span class="s1">&#39;w&#39;</span> <span class="p">)</span><span class="o">.</span><span class="n">writelines</span><span class="p">(</span> <span class="n">stream</span><span class="o">.</span><span class="n">readlines</span><span class="p">(</span> <span class="p">)</span> <span class="p">)</span>
                <span class="k">raise</span> <span class="n">e</span>

    <span class="k">class</span> <span class="nc">assertStdoutFileEqual</span><span class="p">(</span><span class="n">ContextDecorator</span><span class="p">):</span>
        <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">filename</span><span class="p">,</span> <span class="n">parent</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">encoding</span><span class="o">=</span><span class="kc">None</span> <span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_old_target</span> <span class="o">=</span> <span class="kc">None</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_rfilename</span> <span class="o">=</span> <span class="n">TestCase</span><span class="o">.</span><span class="n">_rfilename</span> <span class="o">+</span> <span class="n">filename</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_wfilename</span> <span class="o">=</span> <span class="n">TestCase</span><span class="o">.</span><span class="n">_wfilename</span> <span class="o">+</span> <span class="n">filename</span>

            <span class="k">if</span> <span class="n">encoding</span> <span class="o">!=</span> <span class="kc">None</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_encoding</span> <span class="o">=</span> <span class="n">encoding</span>
            <span class="k">if</span> <span class="n">parent</span> <span class="o">!=</span> <span class="kc">None</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_parent</span> <span class="o">=</span> <span class="n">parent</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_parent</span> <span class="o">=</span> <span class="n">unittest</span><span class="o">.</span><span class="n">TestCase</span><span class="p">(</span> <span class="p">)</span>

        <span class="k">def</span> <span class="nf">__enter__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_old_target</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">sys</span><span class="p">,</span> <span class="s1">&#39;stdout&#39;</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_new_stream</span> <span class="o">=</span> <span class="n">StringIO</span><span class="p">(</span> <span class="p">)</span>
            <span class="nb">setattr</span><span class="p">(</span> <span class="n">sys</span><span class="p">,</span> <span class="s1">&#39;stdout&#39;</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_new_stream</span> <span class="p">)</span>
            <span class="k">return</span><span class="p">(</span> <span class="bp">self</span><span class="o">.</span><span class="n">_new_stream</span> <span class="p">)</span>

        <span class="k">def</span> <span class="nf">__exit__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">exc_type</span><span class="p">,</span> <span class="n">exc</span><span class="p">,</span> <span class="n">exc_tb</span><span class="p">):</span>
            <span class="nb">setattr</span><span class="p">(</span> <span class="n">sys</span><span class="p">,</span> <span class="s1">&#39;stdout&#39;</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_old_target</span> <span class="p">)</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">exc_type</span> <span class="o">==</span> <span class="n">exc</span> <span class="o">==</span> <span class="n">exc_tb</span> <span class="o">==</span> <span class="kc">None</span><span class="p">:</span>
                <span class="k">return</span><span class="p">(</span> <span class="kc">False</span> <span class="p">)</span>
            <span class="n">expected</span> <span class="o">=</span> <span class="s1">&#39;&#39;</span>
            <span class="k">with</span> <span class="n">suppress</span><span class="p">(</span><span class="ne">FileNotFoundError</span><span class="p">):</span>
                <span class="k">if</span> <span class="nb">getattr</span><span class="p">(</span> <span class="bp">self</span><span class="p">,</span> <span class="s1">&#39;_encoding&#39;</span><span class="p">,</span> <span class="kc">None</span> <span class="p">)</span> <span class="o">!=</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="k">with</span> <span class="nb">open</span><span class="p">(</span> <span class="bp">self</span><span class="o">.</span><span class="n">_rfilename</span><span class="p">,</span>
                               <span class="s1">&#39;r&#39;</span><span class="p">,</span>
                               <span class="n">encoding</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_encoding</span> <span class="p">)</span> <span class="k">as</span> <span class="n">rf</span><span class="p">:</span>
                        <span class="n">expected</span> <span class="o">=</span> <span class="n">rf</span><span class="o">.</span><span class="n">read</span><span class="p">(</span> <span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="k">with</span> <span class="nb">open</span><span class="p">(</span> <span class="bp">self</span><span class="o">.</span><span class="n">_rfilename</span><span class="p">,</span> <span class="s1">&#39;r&#39;</span> <span class="p">)</span> <span class="k">as</span> <span class="n">rf</span><span class="p">:</span>
                        <span class="n">expected</span> <span class="o">=</span> <span class="n">rf</span><span class="o">.</span><span class="n">read</span><span class="p">(</span> <span class="p">)</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="n">unittest</span><span class="o">.</span><span class="n">TestCase</span><span class="o">.</span><span class="n">assertMultiLineEqual</span><span class="p">(</span> <span class="bp">self</span><span class="o">.</span><span class="n">_parent</span><span class="p">,</span>
                                       <span class="bp">self</span><span class="o">.</span><span class="n">_new_stream</span><span class="o">.</span><span class="n">getvalue</span><span class="p">(</span> <span class="p">),</span> <span class="n">expected</span> <span class="p">)</span>
            <span class="k">except</span> <span class="ne">AssertionError</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_new_stream</span><span class="o">.</span><span class="n">seek</span><span class="p">(</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span> <span class="p">)</span>
                <span class="k">if</span> <span class="nb">getattr</span><span class="p">(</span> <span class="bp">self</span><span class="p">,</span> <span class="s1">&#39;_encoding&#39;</span><span class="p">,</span> <span class="kc">None</span> <span class="p">)</span> <span class="o">!=</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="n">wf</span> <span class="o">=</span> <span class="nb">open</span><span class="p">(</span> <span class="bp">self</span><span class="o">.</span><span class="n">_wfilename</span><span class="p">,</span>
                               <span class="s1">&#39;w&#39;</span><span class="p">,</span>
                               <span class="n">encoding</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_encoding</span>
                             <span class="p">)</span><span class="o">.</span><span class="n">writelines</span><span class="p">(</span> <span class="bp">self</span><span class="o">.</span><span class="n">_new_stream</span><span class="o">.</span><span class="n">readlines</span><span class="p">(</span> <span class="p">)</span> <span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">wf</span> <span class="o">=</span> <span class="nb">open</span><span class="p">(</span> <span class="bp">self</span><span class="o">.</span><span class="n">_wfilename</span><span class="p">,</span>
                               <span class="s1">&#39;w&#39;</span>
                             <span class="p">)</span><span class="o">.</span><span class="n">writelines</span><span class="p">(</span> <span class="bp">self</span><span class="o">.</span><span class="n">_new_stream</span><span class="o">.</span><span class="n">readlines</span><span class="p">(</span> <span class="p">)</span> <span class="p">)</span>
                <span class="k">raise</span> <span class="n">e</span>

<span class="k">if</span> <span class="n">__name__</span> <span class="o">==</span> <span class="s2">&quot;__main__&quot;</span><span class="p">:</span>
    <span class="k">pass</span>
</pre></div>

          </div>
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
<div id="searchbox" style="display: none" role="search">
  <h3>Quick search</h3>
    <form class="search" action="../search.html" method="get">
      <div><input type="text" name="q" /></div>
      <div><input type="submit" value="Go" /></div>
      <input type="hidden" name="check_keywords" value="yes" />
      <input type="hidden" name="area" value="default" />
    </form>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../genindex.html" title="General Index"
             >index</a></li>
        <li class="nav-item nav-item-0"><a href="../index.html">ParallelRegression v1.0.0b2 - tools for conducting parallel analysis of a shared memory data set</a> &#187;</li>
          <li class="nav-item nav-item-1"><a href="index.html" >Module code</a> &#187;</li> 
      </ul>
    </div>
    <div class="footer" role="contentinfo">
        &#169; Copyright 2017, Richard C. Bellamy.
    </div>
  </body>
</html>